% LaTeX source for ``Think Python: How to Think Like a Computer Scientist''
% Copyright (c)  2012  Allen B. Downey.

% License: Creative Commons Attribution-NonCommercial 3.0 Unported License.
% http://creativecommons.org/licenses/by-nc/3.0/
% Traduzione italiana di Andrea Zanella andreazanella@tiscali.it

%\documentclass[10pt,b5paper]{book}
\documentclass[10pt]{book}
\usepackage[width=5.5in,height=8.5in,
  hmarginratio=3:2,vmarginratio=1:1]{geometry}

% for some of these packages, you might have to install
% texlive-latex-extra (in Ubuntu)

\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{mathpazo}
\usepackage{url}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{exercise}                        % texlive-latex-extra
\usepackage{makeidx}
\usepackage{setspace}
\usepackage{hevea}                           
\usepackage{upquote}
\usepackage{appendix}
\usepackage[italian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{latexsym}
\usepackage[bookmarks]{hyperref}

\title{Pensare in Python}
\author{Allen B. Downey}
\newcommand{\thetitle}{Pensare in Python: Come pensare da Informatico}
\newcommand{\theversion}{2.0.15 - Rev. 1}
\newcommand{\thedate}{Marzo 2015}

% these styles get translated in CSS for the HTML version
\newstyle{a:link}{color:black;}
\newstyle{p+p}{margin-top:1em;margin-bottom:1em}
\newstyle{img}{border:0px}

% change the arrows
\setlinkstext
  {\imgsrc[ALT="Previous"]{back.png}}
  {\imgsrc[ALT="Up"]{up.png}}
  {\imgsrc[ALT="Next"]{next.png}}

\makeindex

\newif\ifplastex
\plastexfalse

\begin{document}

\frontmatter

% PLASTEX ONLY
\ifplastex
    \usepackage{localdef}
    \maketitle

\newcount\anchorcnt
\newcommand*{\Anchor}[1]{%
  \@bsphack%
    \Hy@GlobalStepCount\anchorcnt%
    \edef\@currentHref{anchor.\the\anchorcnt}% 
    \Hy@raisedlink{\hyper@anchorstart{\@currentHref}\hyper@anchorend}% 
    \M@gettitle{}\label{#1}% 
    \@esphack%
}


\else
% skip the following for plastex

\newtheorem{exercise}{Esercizio}[chapter]

% LATEXONLY

\input{latexonly}

\begin{latexonly}

\renewcommand{\blankpage}{\thispagestyle{empty} \quad \newpage}

%\blankpage
%\blankpage

% TITLE PAGES FOR LATEX VERSION

%-half title--------------------------------------------------
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge Pensare in Python}\\
{\Large Come pensare da Informatico}
\end{spacing}

\vspace{0.25in}

Versione \theversion

\thedate

\vfill

\end{flushright}

%--verso------------------------------------------------------

\blankpage
\blankpage
%\clearemptydoublepage
%\pagebreak
%\thispagestyle{empty}
%\vspace*{6in}

%--title page--------------------------------------------------
\pagebreak
\thispagestyle{empty}

\begin{flushright}
\vspace*{2.0in}

\begin{spacing}{3}
{\huge Pensare in Python}\\
{\Large Come pensare da Informatico}
\end{spacing}

\vspace{0.25in}

Versione \theversion

\thedate

\vspace{1in}


{\Large
Allen Downey\\
}


\vspace{0.5in}

{\Large Green Tea Press}

{\small Needham, Massachusetts}

%\includegraphics[width=1in]{figs/logo1.pdf}
\vfill

\end{flushright}


%--copyright--------------------------------------------------
\pagebreak
\thispagestyle{empty}

{\small
Copyright \copyright ~2012 Allen Downey.


\vspace{0.2in}

\begin{flushleft}
Green Tea Press       \\
9 Washburn Ave        \\
Needham MA 02492
\end{flushleft}

È concessa l'autorizzazione a copiare, distribuire e/o modificare questo documento sotto i termini della Creative Commons Attribution-NonCommercial 3.0 Unported License, che è scaricabile dal sito \url{http://creativecommons.org/licenses/by-nc/3.0/}.

La forma originale di questo libro è in codice sorgente \LaTeX\ . La compilazione del sorgente \LaTeX\ ha l'effetto di generare una rappresentazione di un testo indipendente dal dispositivo, che può essere successivamente convertito in altri formati e stampato.

Il codice sorgente \LaTeX\ di questo libro è disponibile all'indirizzo
\url{http://www.thinkpython.com}.

\vspace{0.2in}
Traduzione di Andrea Zanella (andreazanella@tiscali.it).


\vspace{0.2in}

} % end small

\end{latexonly}


% HTMLONLY

\begin{htmlonly}

% TITLE PAGE FOR HTML VERSION

{\Large \thetitle}

{\large Allen B. Downey}

Versione \theversion

\thedate

\setcounter{chapter}{-1}

\end{htmlonly}

\fi
% END OF THE PART WE SKIP FOR PLASTEX


\chapter{Prefazione}

\section*{La strana storia di questo libro}

Nel gennaio 1999 mi stavo preparando a tenere un corso introduttivo di programmazione in Java. Lo insegnavo per la terza volta, ma la cosa stava diventando per me frustrante. Il tasso di insuccesso nel corso era troppo elevato, e anche per gli studenti che venivano promossi, il livello globale di apprendimento era troppo basso.

Uno dei problemi che avevo individuato erano i libri. Troppo grandi, con troppi dettagli non necessari su Java e privi di una guida di alto livello su come programmare. E tutti soffrivano dell' ``effetto botola'': cominciavano in modo semplice, procedevano gradualmente e poi, verso il Capitolo 5, mancava il pavimento sotto i piedi. Gli studenti si trovavano con troppo nuovo materiale e troppo velocemente, e io passavo il resto del semestre a raccogliere i cocci.

Due settimane prima dell'inizio delle lezioni, decisi allora di scrivere un libro tutto mio. I miei obiettivi erano:

\begin{itemize}

\item Mantenerlo breve. Gli studenti preferiscono leggere 10 pagine piuttosto che 50.

\item Prestare attenzione ai vocaboli. Cercai di ridurre al minimo i termini gergali e di spiegare ciascun termine la prima volta che veniva usato.

\item Costruire gradualmente. Per evitare le ``botole'', presi gli argomenti più ostici suddividendoli in una serie di piccoli passi.

\item Focalizzare sulla programmazione, non sul linguaggio di programmazione. Inclusi la minima parte necessaria di Java e tralasciai il resto.

\end{itemize}

Mi serviva un titolo, così d'istinto scelsi {\em Come pensare da Informatico}.

La prima versione era grezza, ma funzionò. Gli studenti lo lessero, e capirono abbastanza da permettermi di impiegare il tempo della lezione per gli argomenti più difficili, per quelli interessanti e (cosa più importante) per la parte pratica.

Pubblicai il libro sotto la GNU Free Documentation License, che permette ai fruitori di copiare, modificare, e distribuire il libro.

\index{GNU Free Documentation License}
\index{Free Documentation License, GNU}

Ma il bello venne dopo. Jeff Elkner, insegnante di liceo in Virginia, utilizzò il mio libro adattandolo per Python. Mi mandò una copia della sua versione, e io ebbi la insolita esperienza di imparare Python leggendo il mio stesso libro. Con la Green Tea Press, pubblicai la prima versione Python nel 2001.
\index{Elkner, Jeff}

Nel 2003 cominciai a lavorare all'Olin College, ed ottenni di insegnare Python per la prima volta. Il contrasto con Java fu abissale. Gli studenti dovettero faticare meno, impararono di più, lavorarono su progetti più interessanti, e in generale si divertirono di più.
\index{Olin College}

Negli ultimi nove anni, ho continuato a sviluppare il libro, correggendo errori, migliorando alcuni esempi e aggiungendo nuovo materiale, soprattutto esercizi.

Il risultato è questo libro, che ora ha il meno grandioso titolo 
{\em Pensare in Python}.  Ecco alcune novità:

\begin{itemize}

\item Ho aggiunto un paragrafo sul debug alla fine di ciascun capitolo. Questi paragrafi presentano le tecniche generali per scovare ed evitare gli errori, e le avvertenze sui trabocchetti di Python.

\item Ho aggiunto altri esercizi, da brevi test di apprendimento ad alcuni progetti sostanziosi, scrivendo per la maggior parte di essi la soluzione.

\item Ho aggiunto una serie di esercitazioni - esempi più articolati con esercizi, soluzioni e discussione. Alcuni sono basati su Swampy, una raccolta di programmi in Python che ho scritto a supporto delle mie lezioni. Swampy, il codice degli esempi e alcune soluzioni sono disponibili sul sito 
  \url{http://thinkpython.com}.
  
\item Ho ampliato la trattazione sui metodi di sviluppo di un programma e sugli schemi fondamentali di progettazione.

\item Ho aggiunto delle appendici sul debug, l'analisi degli algoritmi e i diagrammi ULM con Lumpy.

\end{itemize}

Spero che troviate piacevole utilizzare questo libro, e che vi aiuti ad imparare a programmare e a pensare, almeno un pochino, da informatici.


Allen B. Downey \\
Needham MA\\

Allen Downey è Professore di Informatica presso il Franklin W. Olin College of Engineering.


\section*{Ringraziamenti}

Grazie infinite a Jeff Elkner, che ha adattato il mio libro su Java in Python, ha dato inizio a questo progetto e mi ha introdotto in quello che poi è diventato il mio linguaggio di programmazione preferito. 
\index{Elkner, Jeff}

Grazie anche a Chris Meyers, che ha contribuito ad alcuni paragrafi di
{\em How to Think Like a Computer Scientist}.
\index{Meyers, Chris}

Grazie alla Free Software Foundation per aver sviluppato la GNU Free Documentation License, che ha aiutato a rendere possibile la mia collaborazione con Jeff e Chris, e a Creative Commons per la licenza che uso attualmente.
\index{GNU Free Documentation License}
\index{Free Documentation License, GNU}
\index{Creative Commons}

Grazie ai redattori di Lulu che hanno lavorato su
{\em How to Think Like a Computer Scientist}.

Grazie a tutti gli studenti che hanno usato le versioni precedenti di questo libro e a tutti coloro (elencati di seguito) che hanno contribuito inviando correzioni e suggerimenti.


\section*{Elenco dei collaboratori}

\index{collaboratori}
Più di 100 lettori premurosi e dalla vista aguzza hanno inviato suggerimenti e correzioni negli anni passati. Il loro contributo e l'entusiasmo per questo progetto, sono stati di enorme aiuto.

Se volete proporre suggerimenti o correzioni, inviate una email a 
{\tt feedback@thinkpython.com}. Se farò delle modifiche in seguito al vostro contributo, sarete aggiunti all'elenco dei collaboratori (a meno che non chiediate di non comparire).

Se includete almeno parte della frase in cui si trova l'errore, mi faciliterete la ricerca. Vanno bene anche numeri di pagina e di paragrafo, ma sono meno agevoli da trattare. Grazie!

\begin{itemize}

\small
\item Lloyd Hugh Allen ha inviato una correzione al Paragrafo 8.4.

\item Yvon Boulianne ha inviato una correzione a un errore di semantica nel Capitolo 5.

\item Fred Bremmer ha inviato una correzione al Paragrafo 2.1.

\item Jonah Cohen ha scritto gli script Perl per convertire i sorgenti
LaTeX di questo libro in un meraviglioso HTML.

\item Michael Conlon ha inviato una correzione grammaticale nel Capitolo 2
e un miglioramento dello stile nel Capitolo 1, e ha iniziato la discussione sugli aspetti tecnici degli interpreti.

\item Benoit Girard ha inviato una correzione ad un umoristico errore nel Paragrafo 5.6.

\item Courtney Gleason e Katherine Smith hanno scritto {\tt horsebet.py},
che veniva usato come esercitazione in una versione precedente del libro. Ora il loro programma si può trovare sul sito web.

\item Lee Harr ha sottoposto più correzioni di quelle che è possibile elencare in questo spazio, e pertanto andrebbe considerato come uno dei principali revisori del testo.

\item James Kaylin è uno studente che ha usato il libro. Ha sottoposto numerose correzioni.

\item David Kershaw ha sistemato la funzione guasta {\tt catTwice} nel Paragrafo
3.10.

\item Eddie Lam ha mandato molte correzioni ai Capitoli 1, 2, e 3.
Ha anche sistemato il Makefile in modo che crei un indice alla prima esecuzione e ha aiutato nell'impostazione dello schema delle versioni.  

\item Man-Yong Lee ha inviato una correzione al codice di esempio nel Paragrafo 2.4.  

\item David Mayo ha puntualizzato che la parola ``inconsciamente' nel Capitolo 1 doveva essere cambiata in ``subconsciamente''.

\item Chris McAloon ha inviato alcune correzioni ai Paragrafi 3.9 e
3.10.

\item Matthew J. Moelter è un collaboratore di lunga data che ha inviato numerose correzioni e suggerimenti al libro.  

\item Simon Dicon Montford ha comunicato una definizione di funzione mancante e alcuni errori di battitura nel Capitolo 3. Ha anche trovato un errore nella funzione {\tt incremento} nel Capitolo 13.

\item John Ouzts ha corretto la definizione di ``valore di ritorno'' nel Capitolo 3.

\item Kevin Parks ha inviato preziosi commenti e suggerimenti su come migliorare la distribuzione del libro.

\item David Pool ha inviato un errore di battitura nel glossario del Capitolo 1, e gentili parole di incoraggiamento.

\item Michael Schmitt ha inviato correzioni al capitolo sui file e le eccezioni.

\item Robin Shaw ha evidenziato un errore nel Paragrafo 13.1 dove la funzione printTime veniva usata in un esempio senza essere definita.

\item Paul Sleigh ha trovato un errore nel Capitolo 7 e un bug nello script Perl di Jonah Cohen che genera HTML a partire da LaTeX.

\item Craig T. Snydal sta provando il testo in un corso presso la Drew
University. Ha contribuito con alcuni preziosi consigli e correzioni.

\item Ian Thomas e i suoi studenti stanno usando il testo in un corso di programmazione. Sono i primi a collaudare i capitoli della seconda metà del libro, e hanno apportato numerose correzioni e suggerimenti.

\item Keith Verheyden ha inviato una correzione al Capitolo 3.

\item Peter Winstanley ci ha portato a conoscenza di un annoso errore nel nostro carattere latin nel Capitolo 3.

\item Chris Wrobel ha apportato correzioni al codice nel capitolo su file I/O ed eccezioni. 

\item Moshe Zadka ha dato un inestimabile contributo a questo progetto. Oltre a scrivere la prima bozza del capitolo sui Dizionari, è stato una continua fonte di indicazioni nei primi abbozzi di questo libro.

\item Christoph Zwerschke ha inviato alcune correzioni e suggerimenti pedagogici, e ha spiegato la differenza tra {\em gleich} e {\em selbe}.

\item James Mayer ci ha mandato correzioni a un sacco di errori di battitura e di dizione, compresi due nell'elenco dei collaboratori.

\item Hayden McAfee ha colto una incongruenza, fonte di probabile confusione, tra due esempi.

\item Angel Arnal fa parte del gruppo internazionale di traduttori e lavora sulla versione spagnola. Ha trovato anche alcuni errori nella versione inglese.

\item Tauhidul Hoque e Lex Berezhny hanno creato le illustrazioni del Capitolo 1 e migliorato molte delle altre.

\item Il Dr. Michele Alzetta ha colto un errore nel Capitolo 8 e inviato alcuni interessanti commenti pedagogici su Fibonacci e Old Maid.

\item Andy Mitchell ha trovato un errore di battitura nel Capitolo1 e un esempio non funzionante nel Capitolo 2.

\item Kalin Harvey ha suggerito un chiarimento nel Capitolo 7 e ha trovato alcuni errori di battitura.

\item Christopher P. Smith ha trovato alcuni errori di battitura e ci ha aiutato ad aggiornare il libro a Python 2.2 .

\item David Hutchins ha trovato un errore di battitura nella Premessa.

\item Gregor Lingl insegna Python in un liceo di Vienna, in Austria. Sta lavorando alla traduzione tedesca del libro e ha trovato un paio di brutti errori nel Capitolo 5.

\item Julie Peters ha trovato un errore di battitura nella Premessa.

\item Florin Oprina ha inviato un miglioramento in {\tt makeTime},
una correzione in {\tt printTime}, e un simpatico errore di battitura.

\item D.~J.~Webre ha suggerito un chiarimento nel Capitolo 3.

\item Ken ha trovato una manciata di errori nei Capitoli 8, 9 e 11.

\item Ivo Wever ha trovato un errore di battitura nel Capitolo 5 e ha suggerito un chiarimento nel Capitolo 3.

\item Curtis Yanko ha suggerito un chiarimento nel Capitolo 2.

\item Ben Logan ha evidenziato alcuni errori di battitura e dei problemi nella trasposizione del libro in HTML.

\item Jason Armstrong ha notato una parola mancante nel Capitolo 2.

\item Louis Cordier ha notato un punto del Capitolo 16 dove il codice non corrispondeva al testo.

\item Brian Cain ha suggerito dei chiarimenti nei Capitoli 2 e 3.

\item Rob Black ha inviato un'ampia raccolta di correzioni, inclusi alcuni cambiamenti per Python 2.2.

\item Jean-Philippe Rey dell'Ecole Centrale di Parigi ha inviato un buon numero di correzioni, inclusi degli aggiornamenti per Python 2.2 e altri preziosi miglioramenti.

\item Jason Mader della George Washington University ha dato parecchi utili suggerimenti e correzioni.

\item Jan Gundtofte-Bruun ci ha ricordato che ``a error'' è un errore.

\item Abel David e Alexis Dinno ci hanno ricordato che il plurale di
``matrix'' è ``matrices'', non ``matrixes''.  Questo errore è rimasto nel libro per anni, ma due lettori con le stesse iniziali lo hanno segnalato nello stesso giorno. Curioso.

\item Charles Thayer ci ha spronati a sbarazzarci dei due punti che avevamo messo alla fine di alcune istruzioni, e a fare un uso più appropriato di ``argomenti'' e ``parametri''.

\item Roger Sperberg ha indicato un brano dalla logica contorta nel Capitolo 3.

\item Sam Bull ha evidenziato un paragrafo confuso nel Capitolo 2.

\item Andrew Cheung ha evidenziato due istanze di ``uso prima di def.''

\item C. Corey Capel ha notato una parola mancante nel Terzo Teorema del Debugging e un errore di battitura nel Capitolo 4.

\item Alessandra ha aiutato a sistemare un po' di confusione nelle Tartarughe.

\item Wim Champagne ha trovato un errore in un esempio di dizionario.

\item Douglas Wright ha trovato un problema con la divisione intera in
{\tt arco}.

\item Jared Spindor ha trovato alcuni scarti alla fine di una frase.

\item Lin Peiheng ha inviato una serie di suggerimenti molto utili.

\item Ray Hagtvedt ha sottoposto due errori e un non-abbastanza-errore.

\item Torsten H\"{u}bsch ha evidenziato un'incongruenza in Swampy.

\item Inga Petuhhov ha corretto un esempio nel Capitolo 14.

\item Arne Babenhauserheide ha inviato alcune utili correzioni.

\item Mark E. Casida è bravo bravo a trovare parole ripetute.

\item Scott Tyler ha inserito una che mancava. E ha poi inviato una pila di correzioni.

\item Gordon Shephard ha inviato alcune correzioni, tutte in email separate.

\item Andrew Turner {\tt ha tro}vato un errore nel Capitolo 8.

\item Adam Hobart ha sistemato un problema con la divisione intera in
{\tt arco}.

\item Daryl Hammond e Sarah Zimmerman hanno osservato che ho servito {\tt math.pi} troppo presto. E Zim ha trovato un errore di battitura.

\item George Sass ha trovato un bug in un Paragrafo sul Debug.

\item Brian Bingham ha suggerito l'Esercizio~\ref{exrotatepairs}.

\item Leah Engelbert-Fenton ha osservato che avevo usate {\tt tuple}
come nome di variabile, contro le mie stesse affermazioni. E poi ha trovato una manciata di errori di battitura e un ``uso prima di def.''

\item Joe Funke ha trovato un errore di battitura.

\item Chao-chao Chen ha trovato un'incoerenza nell'esempio su Fibonacci.

\item Jeff Paine conosce la differenza tra space e spam.

\item Lubos Pintes ha corretto un errore di battitura.

\item Gregg Lind e Abigail Heithoff hanno suggerito l'Esercizio~\ref{checksum}.

\item Max Hailperin ha inviato parecchie correzioni e suggerimenti.  Max è uno degli autori dello straordinario {\em Concrete Abstractions}, che potreste prendere in considerazione dopo aver letto questo libro.

\item Chotipat Pornavalai ha trovato un errore in un messaggio di errore.

\item Stanislaw Antol ha mandato un elenco di suggerimenti molto utili.

\item Eric Pashman ha inviato parecchie correzioni ai Capitoli 4--11.

\item Miguel Azevedo ha trovato alcuni errori di battitura.

\item Jianhua Liu ha inviato un lungo elenco di correzioni.

\item Nick King ha trovato una parola mancante.

\item Martin Zuther ha inviato un lungo elenco di suggerimenti.

\item Adam Zimmerman ha trovato un'incongruenza nella mia istanza di un' ``istanza'' e qualche altro errore.

\item Ratnakar Tiwari ha suggerito una nota a pié di pagina per spiegare i triangoli degeneri.

\item Anurag Goel ha suggerito un'altra soluzione per \verb"alfabetica"
e alcune altre correzioni. E sa come si scrive Jane Austen.

\item Kelli Kratzer ha evidenziato un errore di battitura.

\item Mark Griffiths ha osservato un esempio poco chiaro nel Capitolo 3.

\item Roydan Ongie ha trovato un errore nel mio metodo di Newton.

\item Patryk Wolowiec mi ha aiutato a risolvere un problema con la versione HTML.

\item Mark Chonofsky mi ha riferito di una nuova parola riservata in Python 3.

\item Russell Coleman mi ha aiutato con la geometria.

\item Wei Huang ha evidenziato alcuni errori tipografici.

\item Karen Barber ha trovato il più vecchio errore di battitura del libro.

\item Nam Nguyen ha trovato un errore di battitura e ha osservato che avevo usato uno schema di Decoratore senza farne menzione.

\item St\'{e}phane Morin ha inviato alcune correzioni e suggerimenti.

\item Paul Stoop ha corretto un errore di battitura in \verb+usa_solo+.

\item Eric Bronner ha notato un po' di confusione nella discussione dell'ordine delle operazioni.

\item Alexandros Gezerlis ha fissato un nuovo standard per il numero e la qualità dei suoi suggerimenti. Gli siamo profondamente grati!

\item Gray Thomas distingue la sua destra dalla sua sinistra.

\item Giovanni Escobar Sosa ha inviato un lungo elenco di correzioni e suggerimenti.

\item Alix Etienne ha sistemato uno degli URL.

\item Kuang He ha trovato un errore di battitura.

\item Daniel Neilson ha corretto un errore nell'ordine delle operazioni.

\item Will McGinnis ha evidenziato che {\tt polilinea} era definita in modo diverso in due punti.

\item Swarup Sahoo ha notato un punto e virgola mancante.

\item Frank Hecker ha osservato un esercizio poco spiegato e alcuni collegamenti non funzionanti.

\item Animesh B mi ha aiutato a spiegare meglio un esempio poco chiaro.

\item Martin Caspersen ha trovato due errori di arrotondamento.

\item Gregor Ulm ha inviato alcune correzioni e suggerimenti.

\item Dimitrios Tsirigkas ha suggerito di chiarire meglio un esercizio.

\item Carlos Tafur ha inviato una pagina di correzioni e suggerimenti.

\item Martin Nordsletten ha trovato un bug nella soluzione di un esercizio.

\item Lars O.D. Christensen ha trovato un riferimento non funzionante.

\item Victor Simeone ha trovato un errore di battitura.

\item Sven Hoexter ha osservato che una variabile di nome {\tt input}
oscura una funzione predefinita.

\item Viet Le ha trovato un errore di battitura.

\item Stephen Gregory ha evidenziato il problema di {\tt cmp} in Python 3.

\item Matthew Shultz mi ha comunicato un collegamento non funzionante.

\item Lokesh Kumar Makani mi ha comunicato alcuni collegamenti non funzionanti e dei cambiamenti nei messaggi di errore.

\item Ishwar Bhat ha corretto la mia formulazione dell'ultimo teorema di Fermat.

\item Brian McGhie ha suggerito un chiarimento.

\item Andrea Zanella ha tradotto il libro in italiano e, strada facendo, ha inviato alcune correzioni.

% ENDCONTRIB

\end{itemize}

\normalsize
\clearemptydoublepage

% TABLE OF CONTENTS
\begin{latexonly}

\tableofcontents

\clearemptydoublepage

\end{latexonly}

% START THE BOOK
\mainmatter

\chapter{Lo scopo del programma}

Lo scopo di questo libro è insegnarvi a pensare da informatici. Questo modo di pensare combina alcune delle migliori caratteristiche della matematica, dell'ingegneria e delle scienze naturali. Come i matematici, gli informatici usano linguaggi formali per esprimere concetti (nella fattispecie, elaborazioni). Come gli ingegneri, progettano cose, assemblano singoli componenti in sistemi e valutano costi e benefici tra le varie alternative. Come gli scienziati, osservano il comportamento di sistemi complessi, formulano ipotesi e verificano previsioni.
\index{risoluzione di problemi}

La più importante capacità di un informatico è quella di risolvere problemi. Risolvere problemi significa riuscire a schematizzarli, pensare creativamente alle possibili soluzioni ed esprimerle in modo chiaro ed accurato. Ne deriva che imparare a programmare è un'eccellente opportunità di mettere in pratica l'abilità di risolvere problemi. Ecco perché questo capitolo è chiamato ``Lo scopo del programma''.

Da una parte, vi verrà insegnato a programmare, che già di per sé è un'utile   capacità. Dall'altra, userete la programmazione come un mezzo per raggiungere   uno scopo. Man mano che procederemo, quello scopo vi diverrà più chiaro.

\section{Il linguaggio di programmazione Python}
\index{programmazione!linguaggio di}
\index{linguaggio!di programmazione}

Il linguaggio di programmazione che imparerete si chiama Python. Python è un   esempio di {\bf linguaggio di alto livello}; altri linguaggi di alto livello   di cui potreste aver sentito parlare sono il C, il C++, il Perl ed il Java.

Esistono anche {\bf linguaggi di basso livello}, talvolta chiamati ``linguaggi macchina'' o ``linguaggi assembly''. Detto in breve, i computer possono eseguire soltanto programmi scritti in linguaggi di basso livello: i programmi scritti in un linguaggio di alto livello devono essere elaborati prima di poter essere eseguiti. Questo procedimento di elaborazione impiega del tempo e rappresenta un piccolo svantaggio dei linguaggi di alto livello.
\index{portabilità}
\index{linguaggio!di alto livello}
\index{linguaggio!di basso livello}

I vantaggi d'altra parte sono enormi. In primo luogo, è molto più facile programmare in un linguaggio ad alto livello: questi tipi di programmi sono più veloci da scrivere, più corti e facilmente leggibili, ed è più probabile che siano corretti. In secondo luogo, i linguaggi di alto livello sono {\bf portabili}; portabilità significa che essi possono essere eseguiti su tipi di computer diversi con poche modifiche o addirittura nessuna. I programmi scritti in linguaggi di basso livello possono essere eseguiti solo su un tipo di computer e devono essere riscritti per essere trasportati su un altro sistema.

Questi vantaggi sono talmente evidenti che quasi tutti i programmi sono scritti in linguaggi di alto livello, lasciando spazio ai linguaggi di basso livello solo in poche applicazioni specializzate.
\index{compilare}
\index{interpretare}

I programmi di alto livello vengono trasformati in programmi di basso livello eseguibili dal computer tramite due tipi di elaborazione: l'{\bf interpretazione} e la {\bf compilazione}. Un interprete legge il programma di alto livello e lo esegue, trasformando ogni riga di istruzioni in un'azione. L'interprete elabora il programma un po' alla volta, alternando la lettura delle istruzioni all'esecuzione dei comandi che le istruzioni descrivono. La Figura~\ref{fig.interpret} mostra la struttura di un interprete.
\index{codice sorgente}
\index{codice oggetto}
\index{eseguibile}

\begin{figure}
\centerline
{\includegraphics[scale=0.9]{figs/interpret.pdf}}
\caption{Un interprete elabora il programma un po' per volta, leggendo le righe ed eseguendo i calcoli alternativamente.}
\label{fig.interpret}
\end{figure}

Un compilatore legge il programma di alto livello e lo traduce completamente in basso livello, prima che il programma venga eseguito. In questo caso il programma di alto livello viene chiamato {\bf codice sorgente}, ed il programma tradotto {\bf codice oggetto} o {\bf eseguibile}. Dopo che un programma è stato compilato, può essere eseguito ripetutamente senza che si rendano necessarie ulteriori operazioni di traduzione. La Figura~\ref{fig.compile} mostra la struttura di un compilatore.

\begin{figure}
\centerline
{\includegraphics[scale=0.9]{figs/compile.pdf}}
\caption{Un compilatore traduce il codice sorgente in codice oggetto, che viene avviato da un esecutore hardware.}
\label{fig.compile}
\end{figure}

Python è considerato un linguaggio interpretato perché i programmi Python sono eseguiti da un interprete. Ci sono due modalità di usare l'interprete: la {\bf modalità interattiva} e la {\bf modalità script}. In modalità interattiva (detta anche ``a riga di comando'') si scrivono i programmi in Python e l'interprete elabora immediatamente il risultato:
\index{modalità interattiva}
\index{modalità script}

\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
%
La sequenza di caporali, \verb">>>", è chiamata {\bf prompt}, ed è l'indicazione con cui l'interprete comunica che è pronto ad accettare comandi. Se avete scritto {\tt 1 + 1}, l'interprete risponde con {\tt 2}.
\index{prompt}

In alternativa alla riga di comando, si può scrivere e salvare un programma in un file di testo semplice, chiamato {\bf script}, ed usare l'interprete per eseguire il contenuto del file. Per convenzione, i file contenenti programmi Python hanno nomi che terminano con l'estensione {\tt .py} .
\index{script}

Per eseguire lo script, dobbiamo comunicare all'interprete il nome del file. Se avete uno script chiamato {\tt dinsdale.py} e state lavorando in una finestra di comando UNIX, digitate {\tt python dinsdale.py}. In altri ambienti di lavoro, i dettagli dell'esecuzione dei programmi variano. Potete trovare le istruzioni per il vostro sistema sul sito web di Python \url{http://python.org}.
\index{test!modalità interattiva}

Lavorare in modalità interattiva è conveniente per provare piccoli pezzi di codice, perché si possono inserire ed eseguire immediatamente. Ma per qualcosa di più di poche righe, è meglio salvare il codice in uno script, per poterlo eseguire o modificare in futuro senza doverlo riscrivere da capo ogni volta.


\section{Che cos'è un programma?}

Un {\bf programma} è una sequenza di istruzioni che spiegano come effettuare una elaborazione. L'elaborazione può essere sia di tipo matematico, come la soluzione di un sistema di equazioni o il calcolo delle radici di un polinomio, sia di tipo simbolico, come la ricerca e sostituzione di un testo in un documento oppure (strano ma vero) la compilazione di un programma.
\index{programma}

I dettagli sono diversi per ciascun linguaggio di programmazione, ma un piccolo gruppo di istruzioni è praticamente comune a tutti i linguaggi:

\begin{description}

\item[input:] ricezione di dati da tastiera, da un file o da un altro       dispositivo.

\item[output:] scrittura di dati sullo schermo, su un file o trasmissione ad    altro dispositivo.

\item[matematiche:] esecuzione di semplici operazioni matematiche, quali        l'addizione e la moltiplicazione.

\item[condizionali:] controllo di certe condizioni ed esecuzione della       sequenza di istruzioni appropriata.

\item[ripetizione:] ripetizione di un'azione, di solito con qualche      variazione.

\end{description}

Che ci crediate o no, questo è più o meno tutto ciò che serve. Tutti i   programmi che avete usato, non importa quanto complessi, sono fatti di istruzioni che assomigliano a queste. Possiamo affermare che la programmazione non è altro che la suddivisione di un compito grande e complesso in una serie di sotto-compiti via via più piccoli, finché non risultano sufficientemente semplici da essere eseguiti da una di queste istruzioni fondamentali.
\index{algoritmo}

Questo concetto può sembrare un po' vago, ma lo riprenderemo quando parleremo di {\bf algoritmi}.

\section{Che cos'è il debug?}
\index{debug}
\index{bug}

La programmazione è soggetta ad errori. Per ragioni bizzarre, gli errori di programmazione sono chiamati {\bf bug}, ed il procedimento della loro ricerca e correzione è chiamato {\bf debug}.
\index{debug}
\index{bug}

Ci sono tre tipi di errori nei quali si incorre durante la programmazione: gli errori di sintassi, gli errori in esecuzione e gli errori di semantica. È utile analizzarli singolarmente per facilitarne l'individuazione.

\subsection{Errori di sintassi}
\index{sintassi!errore di}
\index{errore!di sintassi}
\index{errore!messaggio di}

Python può eseguire un programma solo se il programma è sintatticamente corretto, altrimenti l'elaborazione fallisce e l'interprete restituisce un messaggio d'errore. La {\bf sintassi} si riferisce alla struttura di un programma e alle regole che la governano. Ad esempio, le parentesi devono essere sempre presenti a coppie corrispondenti, così{\tt (1 + 2)} è corretto, ma {\tt 8)} è un {\bf errore di sintassi}.
\index{sintassi} 
\index{parentesi!corrispondenza}
\index{cummings, e. e.}

Nelle lingue naturali, chi legge può tollerare la maggior parte degli errori di sintassi, tanto che gli inglesi possono leggere le poesie di e.e. cummings [prive di punteggiatura, NdT] senza emettere ``messaggi d'errore''. Ma Python non è così permissivo: se c'è un singolo errore di sintassi da qualche parte nel programma, Python visualizzerà un messaggio d'errore e ne interromperà l'esecuzione, rendendo impossibile proseguire. Durante le prime settimane della vostra carriera di programmatori, probabilmente passerete molto tempo a cercare errori di sintassi. Via via che acquisirete esperienza, questi si faranno meno numerosi e vi risulterà sempre più facile rintracciarli.

\subsection{Errori in esecuzione}
\label{runtime}

Il secondo tipo di errore è l'{\bf errore in esecuzione} (o di {\em runtime}), così chiamato perché l'errore non appare finché il programma non viene eseguito. Questi errori sono anche chiamati {\bf eccezioni} perché indicano che è accaduto qualcosa di eccezionale (e di spiacevole) nel corso dell'esecuzione.
\index{errore!in esecuzione}
\index{errore!di runtime}
\index{eccezione}
\index{linguaggio!sicuro}

Gli errori in esecuzione sono rari nei semplici programmi che vedrete nei primissimi capitoli, e potrebbe passare un po' di tempo prima di incontrarne uno.


\subsection{Errori di semantica}
\index{semantica}
\index{semantica!errore di}
\index{errore!di semantica}
\index{errore!messaggio di}

Il terzo tipo di errore è l'{\bf errore di semantica} (o di logica). In presenza di un errore di semantica, il programma verrà eseguito senza problemi, nel senso che il computer non genererà messaggi d'errore durante l'esecuzione; tuttavia il risultato non sarà quello che vi aspettate. Sarà qualcosa di diverso, ma questo qualcosa è esattamente ciò che voi avete detto di fare al computer.

Il problema sta nel fatto che il programma che avete scritto non è quello che volevate scrivere: il significato del programma (o la sua semantica) è sbagliato. L'identificazione degli errori di semantica può essere complicata perché richiede di lavorare a ritroso, partendo dai risultati dell'esecuzione e cercando di risalire a che cosa non sia andato per il verso giusto.

\subsection{Debug sperimentale}

Una delle più importanti abilità che acquisirete è la capacità di effettuare il debug (o ``rimozione degli errori''). Sebbene questa possa essere un'operazione noiosa, è anche una delle parti più intellettualmente vivaci, stimolanti ed interessanti della programmazione.
\index{debug!sperimentale}

In un certo senso il debug può essere paragonato al lavoro investigativo. Siete messi di fronte a degli indizi e dovete ricostruire i processi e gli eventi che hanno portato ai risultati che avete ottenuto.

Il debug è come una scienza sperimentale: dopo aver ipotizzato quello che può essere andato storto, modificate il programma e riprovate. Se l'ipotesi era corretta, allora avete saputo predire il risultato della modifica e vi siete avvicinati di un ulteriore passo verso un programma funzionante. Se l'ipotesi era sbagliata, dovete formularne un'altra. Come disse Sherlock Holmes: ``Quando hai eliminato l'impossibile, qualsiasi cosa rimanga, per quanto improbabile, deve essere la verità''
(A. Conan Doyle, {\em Il segno dei quattro})
\index{Holmes, Sherlock}
\index{Doyle, Arthur Conan}

Per alcuni, programmazione e debug sono la stessa cosa, intendendo con questo che la programmazione è un procedimento di graduale rimozione degli errori, fino a quando il programma non fa quello che vogliamo. L'idea è quella di partire da un programma che fa {\em qualcosa}, e facendo piccole modifiche ed eliminando gli errori, man mano che si procede si dovrebbe avere in ogni momento un programma funzionante sempre più completo.

Linux, per fare un esempio, è un sistema operativo che contiene migliaia di righe di codice, ma nacque come un semplice programma che Linus Torvalds usò per esplorare il chip Intel 80386. Secondo Larry Greenfields, ``Uno dei progetti iniziali di Linus era un programma che doveva trasformare una sequenza di AAAA in BBBB e viceversa. Questo in seguito diventò Linux''. ({\em The Linux Users' Guide} Beta Version 1).
\index{Linux}

I capitoli successivi vi forniranno ulteriori spunti sia per quanto riguarda il debug che per altre pratiche di programmazione.


\section{Linguaggi formali e linguaggi naturali}
\index{linguaggio!formale}
\index{linguaggio!naturale}

I {\bf linguaggi naturali} sono le lingue parlate, tipo l'inglese, l'italiano, lo spagnolo. Non sono stati ``progettati'' da qualcuno e, anche se è stato imposto un certo ordine nel loro sviluppo, si sono evoluti naturalmente.

I {\bf linguaggi formali} sono linguaggi progettati per specifiche   applicazioni. Per fare qualche esempio, la notazione matematica è un linguaggio formale particolarmente indicato ad esprimere relazioni tra numeri e simboli; i chimici usano un linguaggio formale per rappresentare la struttura delle molecole; e, cosa più importante dal nostro punto di vista, 

\begin{quote}
{\bf I linguaggi di programmazione sono linguaggi formali che sono
   stati progettati per esprimere delle elaborazioni.}
\end{quote}

I linguaggi formali tendono ad avere regole rigide per quanto riguarda la sintassi. Per esempio,
$3 + 3 = 6$ è una espressione matematica sintatticamente corretta, mentre
$3 + = 3 \mbox{\$} 6$ non lo è.
$H_2O$ è un simbolo chimico sintatticamente corretto, contrariamente a $_2Zz$ .

Le regole sintattiche hanno due aspetti, che riguardano i {\bf simboli} e la
{\bf struttura}. I simboli (in inglese {\em token}) sono gli elementi di base del linguaggio, quali possono essere le parole in letteratura, i numeri in matematica e gli elementi chimici in chimica. Uno dei problemi con 
$3 + = 3 \mbox{\$} 6$ è che \( \$ \) non è un simbolo valido in matematica
(almeno per quanto mi risulta). Allo stesso modo, $_2Zz$ non è valido perché nessun elemento chimico è identificato dal simbolo $Zz$.
\index{simbolo}
\index{token}
\index{struttura}

Il secondo aspetto riguarda la struttura di un'espressione, cioè il modo in cui i simboli sono disposti. L'espressione
$3 + = 3$ è strutturalmente non valida perché, anche se $+$ e $=$ sono dei simboli validi, non è possibile che uno segua immediatamente l'altro. Allo stesso modo, il pedice numerico nelle formule chimiche deve essere scritto dopo il simbolo dell'elemento chimico, e non prima.

\vspace{0.2in}
\begin{exercise}

Scrivete una frase ben strutturata nella vostra lingua, contenente dei simboli non validi. Poi scrivete un'altra frase con tutti simboli validi ma con una struttura non valida.

\end{exercise}

Quando leggete una frase in italiano o un'espressione in un linguaggio formale, dovete analizzare quale sia la struttura della frase (in un linguaggio naturale, questa operazione viene effettuata subconsciamente). Questo processo di analisi è chiamato {\bf parsing}.
\index{parsing}

Per esempio, quando sentite la frase ``Mangiare la foglia'', comprendete che ``la foglia'' è l'oggetto e ``mangiare'' è il predicato verbale.  Una volta   analizzata la frase, potete coglierne il significato (ovvero la semantica della frase). Partendo dal presupposto che sappiate cosa sia una ``foglia'' e cosa significhi ``mangiare'', riuscirete a comprendere il significato generale della frase.

Anche se i linguaggi formali e quelli naturali condividono molte    caratteristiche (simboli, struttura, sintassi e semantica), ci sono delle   significative differenze:
\index{ambiguità}
\index{ridondanza}
\index{letteralità}

\begin{description}

\item[ambiguità:] i linguaggi naturali ne sono pieni, ed il significato viene   ottenuto anche grazie ad altri indizi ricavati dal contesto. I linguaggi formali sono progettati per essere quasi o completamente privi di ambiguità, e ciò comporta che ciascuna dichiarazione ha un unico significato, indipendente dal contesto.

\item[ridondanza:] per evitare l'ambiguità e ridurre le incomprensioni, i linguaggi naturali impiegano molta ridondanza e sono spesso sovrabbondanti. I linguaggi formali sono meno ridondanti e più concisi.

\item[letteralità:] i linguaggi naturali sono pieni di frasi idiomatiche e metafore. Se dico: ``Mangiare la foglia'', presumibilmente non c'è nessuna foglia e nessuno che la mangi (è un modo di dire di una persona che si rende conto di come stanno realmente le cose). I linguaggi formali invece esprimono esattamente ciò che dicono.

\end{description}

Poiché siamo tutti cresciuti parlando un linguaggio naturale, la nostra lingua madre, spesso abbiamo difficoltà ad adattarci ai linguaggi formali. In un certo senso la differenza tra linguaggi naturali e formali è come quella esistente tra poesia e prosa, ma in misura decisamente più evidente:
\index{poesia}
\index{prosa}

\begin{description}

\item[Poesia:] le parole sono usate tanto per il loro suono che per il loro     significato, e la poesia nel suo complesso crea un effetto o una risposta emotiva. L'ambiguità è non solo frequente, ma spesso addirittura voluta.

\item[Prosa:] il significato letterale delle parole è più importante, con la    struttura che contribuisce a fornire maggior significato. La prosa può essere soggetta ad analisi più facilmente della poesia, ma può risultare ancora ambigua.

\item[Programmi:] il significato di un programma per computer è non ambiguo e    assolutamente letterale, e può essere compreso nella sua totalità con l'analisi dei simboli e della struttura.

\end{description}

Ecco alcuni suggerimenti per la lettura dei programmi e degli altri linguaggi formali. Primo, ricordate che i linguaggi formali sono molto più ricchi di       significato dei linguaggi naturali, per questo è necessario più tempo per leggerli e comprenderli. Poi, la struttura dei linguaggi formali è molto importante e di solito non è bene leggerli dall'alto in basso, da sinistra a destra, come avviene per un testo letterario: imparate ad analizzare il programma nella vostra testa, identificandone i simboli ed interpretandone la struttura. Infine, i dettagli sono importanti: piccoli errori di ortografia e punteggiatura sono spesso trascurabili nei linguaggi naturali, ma fanno una enorme differenza in quelli formali.


\section{Il primo programma}
\label{hello}
\index{Ciao, Mondo!}

Per tradizione, il primo programma scritto in un nuovo linguaggio è
chiamato ``Ciao, Mondo!'', perché tutto ciò che fa è scrivere a video le parole ``Ciao, Mondo!'', e niente di più. In Python questo programma si scrive così:

\begin{verbatim}
print 'Ciao, Mondo!'
\end{verbatim}
%
Questo è un esempio di {\bf istruzione print}, che a dispetto del nome non stampa
nulla su carta, limitandosi invece a visualizzare un valore scrivendolo sullo schermo. In questo caso ciò che viene ``stampato'' sono le parole:

\begin{verbatim}
Ciao, Mondo!
\end{verbatim}
%
Gli apici nell'istruzione segnano l'inizio e la fine del valore da stampare e non appaiono nel risultato.
\index{apici}
\index{print, istruzione}
\index{istruzione!print}

Nell'ultima versione di Python, Python 3, la sintassi è leggermente cambiata:

\begin{verbatim}
print('Ciao, Mondo!')
\end{verbatim}
%
Le parentesi indicano che, in questo caso, {\tt print} è una funzione. Torneremo a parlare di funzioni nel Capitolo~\ref{funcchap}.
\index{funzione} \index{print, funzione} \index{Python 3}

In questo libro, adotterò la classica istruzione {\tt print}. Se voi utilizzate Python 3, dovrete adattarla come indicato sopra. Ma a parte questa, ci saranno pochissime altre differenze a cui dovrete prestare attenzione.


\section{Debug}
\index{debug}

È opportuno leggere questo libro davanti al computer, in modo da poter provare gli esempi man mano che procedete nella lettura. Potete eseguire la maggior parte degli esempi in modalità interattiva, ma se scrivete il codice in uno script sarà più facile provare delle variazioni.

Ogni volta che sperimentate una nuova caratteristica, dovreste provare ad inserire degli errori. Ad esempio, nel programma ``Ciao, mondo!'', cosa succede se dimenticate uno dei due apici? O entrambi? O se scrivete sbagliato {\tt print}?
\index{errore!messaggio di}

Esperimenti di questo tipo aiutano a ricordare quello che avete letto; aiutano anche nel debug, perché in questo modo imparate a conoscere il significato dei messaggi di errore. È meglio fare errori ora e di proposito, che più avanti e accidentalmente.

La programmazione, e specialmente il debug, a volte fanno emergere emozioni forti. Se siete alle prese con un bug difficile, vi può capitare di sentirvi arrabbiati, scoraggiati o in difficoltà.

Ci sono prove che le persone tendono naturalmente a rapportarsi con i computer come se fossero esseri umani. Se funzionano bene, li pensiamo come compagni di squadra, e quando sono ostinati o rudi, li trattiamo come trattiamo la gente rude o ostinata (Reeves and Nass, {\it The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places}).
\index{debug!risposta emotiva}
\index{emotività, nel debug}

Prepararsi a reazioni simili può aiutarvi ad affrontarle. Un possibile approccio è quello di pensare al computer come ad un impiegato con alcuni punti di forza, come velocità e precisione, e particolari debolezze, come mancanza di empatia e incapacità di cogliere il quadro generale.

Il vostro compito è di essere un buon manager: trovare il modo di trarre vantaggio dai pregi e mitigare i difetti. E trovare il modo di usare le vostre emozioni per affrontare i problemi, senza lasciare che le vostre reazioni interferiscano con la vostra capacità di lavorare in modo efficace.

Imparare a dare la caccia agli errori può essere noioso, ma è un'abilità preziosa, utile anche per tante altre attività oltre alla programmazione. Alla fine di ogni capitolo trovate un Paragrafo dedicato al debug, come questo, con le mie riflessioni in merito. Spero vi siano di aiuto!



\section{Glossario}

\begin{description}

\item[soluzione di problemi:]  Il procedimento di formulare un problema, trovare una soluzione ed esprimerla.
\index{soluzione di problemi}

\item[linguaggio di alto livello:]  Un linguaggio di programmazione come Python, progettato per essere facilmente leggibile e utilizzabile dagli uomini.
\index{linguaggio!di alto livello}

\item[linguaggio di basso livello:]  Un linguaggio di programmazione che è progettato per essere facilmente eseguibile da un computer; è chiamato anche    ``linguaggio macchina'' o ``linguaggio assembly''.
\index{linguaggio!di basso livello}

\item[portabilità:]  Caratteristica di un programma di poter essere eseguito su computer di tipo diverso.
\index{portabilità}

\item[interpretare:]  Eseguire un programma scritto in un linguaggio di alto livello traducendolo una riga alla volta.
\index{interpretare}

\item[compilare:]  Tradurre tutto in una volta un programma scritto in un linguaggio di alto livello in un linguaggio di basso livello, preparandolo alla successiva esecuzione.
\index{compilare}

\item[codice sorgente:]  Un programma in linguaggio di alto livello prima di essere compilato.
\index{codice sorgente}

\item[codice oggetto:]  Il risultato ottenuto da un compilatore dopo aver tradotto il codice sorgente.
\index{codice oggetto}

\item[eseguibile:]  Altro nome per indicare il codice oggetto pronto per essere eseguito.
\index{eseguibile}

\item[prompt:] Serie di caratteri mostrati dall'interprete per indicare che è pronto a ricevere input dall'utente.
\index{prompt}

\item[script:] Programma memorizzato in un file, di solito destinato ad      essere interpretato.
\index{script}

\item[modalità interattiva:] Modo di usare l'interprete di Python che consiste nello scrivere comandi ed espressioni al prompt.
\index{modalità interattiva}

\item[modalità script:] Modo di usare l'interprete Python che consiste nel leggere ed eseguire le istruzioni contenute in uno script.
\index{modalità script}

\item[programma:] Serie di istruzioni che specificano come effettuare          un'elaborazione.
\index{programma}

\item[algoritmo:]  Procedimento generale usato per risolvere una particolare categoria di problemi.
\index{algoritmo}

\item[bug:]  Un errore in un programma.
\index{bug}

\item[debug:]  Operazione di ricerca e di rimozione di ciascuno dei tre tipi di errori di programmazione.
\index{debug}

\item[sintassi:]  La struttura di un programma.
\index{sintassi}

\item[errore di sintassi:]  Errore in un programma che ne rende impossibile l'analisi (il programma non può quindi essere interpretato o compilato).
\index{sintassi!errore di}

\item[eccezione:]  Errore (detto anche di {\em runtime}) che si verifica mentre il programma viene eseguito.
\index{eccezione}

\item[semantica:]  Il significato logico di un programma.
\index{semantica}

\item[errore di semantica:]   Errore nel programma tale per cui esso produce risultati diversi da quello che il programmatore intendeva.
\index{semantica!errore di}

\item[linguaggio naturale:]  Qualunque linguaggio parlato che si è evoluto spontaneamente nel tempo.
\index{linguaggio!naturale}

\item[linguaggio formale:]  Qualunque linguaggio progettato per scopi specifici, quali la rappresentazione di concetti matematici o programmi per computer (tutti i linguaggi di programmazione sono linguaggi formali).
\index{linguaggio!formale}

\item[simbolo o {\em token}:]  Uno degli elementi di base della struttura sintattica di un programma, analogo a una parola nei linguaggi naturali.
\index{simbolo}
\index{token}

\item[parsing:]  Esame e analisi della struttura sintattica di un programma.
\index{parsing}

\item[istruzione print:]  Istruzione che ordina all'interprete Python di visualizzare un valore sullo schermo.
\index{print, istruzione}
\index{istruzione!print}


\end{description}


\section{Esercizi}

\begin{exercise}

Con un browser web, visitate il sito Internet di Python \url{http://python.org}.
Queste pagine contengono informazioni su Python e collegamenti ad altre pagine correlate, e vi consentono di consultare la documentazione di Python.

Ad esempio, se inserite {\tt print} nel campo di ricerca, il primo link che appare è la documentazione dell'istruzione {\tt print}. In questo momento non vi sarà tutto quanto chiaro, ma è bene sapere che c'è.
\index{documentazione}
\index{python.org}

\end{exercise}

\begin{exercise}

Lanciate l'interprete di Python e scrivete {\tt help()} per avviare la guida in linea. Oppure scrivete \verb"help('print')" per avere informazioni sull'istruzione {\tt print}.

Se qualcosa non funziona, probabilmente dovete installare della documentazione aggiuntiva o specificare una variabile di ambiente; i dettagli dipendono dal vostro sistema operativo e dalla versione di Python.
\index{guida in linea}

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Avviate l'interprete di Python e utilizzatelo come calcolatrice. La sintassi di Python per le operazioni è quasi la stessa della notazione matematica consueta. Per esempio i simboli {\tt +}, {\tt -} e {\tt /} denotano rispettivamente addizione, sottrazione, divisione. Il simbolo per la moltiplicazione è {\tt *}.

Se correte una gara di 10 chilometri in 43 minuti e 30 secondi, qual è il vostro tempo medio sul miglio? E la vostra velocità media in miglia all'ora? (Suggerimento: un miglio equivale a 1,61 km)
\index{calcolatrice}
\index{passo di corsa}

\end{exercise}




\chapter{Variabili, espressioni ed istruzioni}

\section{Valori e tipi}
\index{valore}
\index{tipo}
\index{stringa}

Un {\bf valore} è uno degli elementi fondamentali con cui un programma lavora, come lo sono una lettera dell'alfabeto nella scrittura o un numero in matematica. I valori che abbiamo visto finora sono
{\tt 1}, {\tt 2}, e
\verb"'Ciao, Mondo!'".

Questi valori appartengono a {\bf tipi} diversi:
{\tt 2} è un numero intero, e \verb"'Ciao, Mondo!'" è una {\bf stringa},
così chiamata perché contiene una serie di caratteri. Voi (e l'interprete) potete identificare le stringhe dal fatto che sono racchiuse tra due apici.
\index{apici}

Se non sapete a quale tipo appartenga un dato valore, l'interprete ve lo può dire:

\begin{verbatim}
>>> type('Ciao, Mondo')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
%
Ovviamente le stringhe sono di tipo {\tt str} e gli interi di
   tipo {\tt int}. Non è invece ovvio che i numeri con il punto
   decimale siano di tipo {\tt float}: questi numeri sono rappresentati
   in un formato chiamato ``a virgola mobile'' o {\bf floating-point}.
\index{tipo}
\index{string, tipo}
\index{tipo!str}
\index{int, tipo}
\index{tipo!int}
\index{float, tipo}
\index{tipo!float}

\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
%
Cosa dire di valori come \verb"'17'" e \verb"'3.2'"?
Sembrano a prima vista dei numeri, ma notate che sono racchiusi tra apici e questo sicuramente significa qualcosa. Infatti non sono numeri, ma stringhe:
\index{apici}

\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
%


Quando scrivete numeri grandi, potrebbe venirvi l'idea di usare delle virgole per delimitare i gruppi di tre cifre, come in {\tt 1,000,000}. [Python utilizza la notazione anglosassone, per cui i separatori delle migliaia sono le virgole, mentre il punto è usato per separare le cifre decimali, NdT]. Questo non è un numero intero valido in Python, ma è comunque un qualcosa di consentito:

\begin{verbatim}
>>> 1,000,000
(1, 0, 0)
\end{verbatim}
%
Anche se non è quello che ci aspettavamo! Python in questo caso interpreta 1,000,000 come una sequenza di tre interi separati da virgole. Questo è il primo esempio di errore di semantica che abbiamo incontrato: il codice funziona senza produrre errori, ma fa qualcosa di diverso da quello che noi riteniamo ``giusto''.
\index{semantica!errore di}
\index{errore!di semantica}
\index{errore!messaggio di}



\section{Variabili}
\label{variables}
\index{variabile}
\index{istruzione!di assegnazione}

Una delle caratteristiche più potenti in un linguaggio di programmazione è la capacità di lavorare con le {\bf variabili}. Una variabile è un nome che fa riferimento ad un valore.

Un'{\bf istruzione di assegnazione} crea nuove variabili e assegna loro un valore:

\begin{verbatim}
>>> messaggio = 'Ed ora qualcosa di completamente diverso'
>>> n = 17
>>> pi = 3.1415926535897932
\end{verbatim}
%
Questo esempio effettua tre assegnazioni. La prima assegna una stringa
ad una nuova variabile chiamata {\tt messaggio}; la seconda assegna il numero intero {\tt 17} alla variabile {\tt n}; la terza assegna il valore decimale approssimato di $\pi$ alla variabile {\tt pi}.
\index{diagramma!di stato}

Un modo comune di rappresentare le variabili sulla carta è scriverne il nome con una freccia che punta al valore della variabile. Questo tipo di illustrazione è chiamato {\bf diagramma di stato} perché mostra lo stato in cui si trova la variabile. La Figura~\ref{fig.state2} illustra il risultato delle istruzioni di assegnazione dell'esempio precedente.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/state2.pdf}}
\caption{Diagramma di stato.}
\label{fig.state2}
\end{figure}

Il tipo di una variabile è il tipo del valore a cui essa fa riferimento.

\begin{verbatim}
>>> type(messaggio)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}

\vspace{0.2in}
\begin{exercise}

Se inserite un intero con uno zero iniziale, potreste ottenere un errore inatteso:

\begin{verbatim}
>>> codicepostale = 02492
                        ^
SyntaxError: invalid token
\end{verbatim}

Altri numeri sembrano funzionare, ma i risultati sono bizzarri:

\begin{verbatim}
>>> codicepostale = 02132
>>> codicepostale
1114
\end{verbatim}

Riuscite a capire cosa sta succedendo? Suggerimento: provate con i valori
 {\tt 01}, {\tt 010}, {\tt 0100} e {\tt 01000}.
\index{ottale}

\end{exercise}



\section{Nomi delle variabili e parole chiave riservate}
\index{parola chiave}

Generalmente, i programmatori scelgono dei nomi significativi per le loro variabili, in modo da documentare a che cosa servono.

I nomi delle variabili possono essere lunghi a piacere e possono contenere sia lettere che numeri, ma devono sempre iniziare con una lettera. È possibile usare anche le lettere maiuscole, ma è bene che il nome cominci con una lettera minuscola (vedremo più avanti perché). Ricordate comunque che l'interprete le considera diverse, pertanto Numero, NUmEro e numero sono variabili diverse.

Il carattere di sottolineatura \verb"_", può far parte di un nome: è usato spesso in nomi di variabile composti da più parole (per esempio 
\verb"il_mio_nome" o \verb"monty_python".)
\index{underscore, carattere}

Se assegnate un nome non valido alla variabile, otterrete un errore di sintassi:

\begin{verbatim}
>>> 76tromboni = 'grande banda'
SyntaxError: invalid syntax
>>> altro@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Zymurgy Teorico Avanzato'
SyntaxError: invalid syntax
\end{verbatim}
%
{\tt 76tromboni} non è valido perché non inizia con una lettera.
{\tt altro@} non è valido perché contiene un carattere non ammesso (la chiocciola {\tt @}). Ma cosa c'è di sbagliato in {\tt class}?

Succede che {\tt class} è una delle {\bf parole chiave riservate} di Python. L'interprete utilizza queste parole per riconoscere la struttura del programma, pertanto non possono essere usate come nomi di variabili.
\index{parola chiave}

Python 2 ha 31 parole chiave riservate:

\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
%
In Python 3, {\tt exec} non è più una parola riservata, ma lo è {\tt nonlocal}.

È consigliabile tenere questa lista a portata di mano: se l'interprete ha problemi con il nome che volete assegnare ad una variabile e non ne capite il motivo, provate a controllare se si trova in questa lista.


\section{Operatori e operandi}
\index{operatore!aritmetico}
\index{operando}
\index{espressione}

Gli {\bf operatori} sono simboli speciali usati per rappresentare calcoli come l'addizione e la moltiplicazione. I valori a cui si applicano gli operatori sono detti {\bf operandi}.

Gli operatori {\tt +}, {\tt -}, {\tt *}, {\tt /} e {\tt **}
eseguono nell'ordine addizione, sottrazione, moltiplicazione, divisione ed elevamento a potenza, come negli esempi seguenti:

\begin{verbatim}
20+32   ore-1   ore*60+minuti   minuti/60   5**2   (5+9)*(15-7)
\end{verbatim}
%
In altri linguaggi, viene usato \verb"^" per le potenze, ma in Python è un operatore bitwise chiamato XOR. Non tratteremo questi operatori in questo libro, ma potete eventualmente approfondire l'argomento sul sito \url{http://wiki.python.org/moin/BitwiseOperators}.
\index{operatore!bitwise}

In Python 2, l'operatore di divisione potrebbe comportarsi in modo inatteso:

\begin{verbatim}
>>> minuti = 59
>>> minuti/60
0
\end{verbatim}
%
Il valore di {\tt minuti} è 59, e nell'aritmetica convenzionale 59 diviso 60 fa 0,98333 e non 0. La ragione di questa discrepanza è che Python compie una {\bf divisione intera}. Quando entrambi gli operandi sono interi, anche il risultato è un intero; la divisione intera tronca la parte decimale, e in questo esempio arrotonda a 0.

In Python 3, invece, il risultato di questa divisione è un decimale {\tt float}, e per eseguire una divisione intera si usa un nuovo operatore: {\tt //}
\index{Python 3}
\index{divisione!intera}
\index{divisione!a virgola mobile}

Tuttavia, se almeno uno degli operandi è un numero decimale, Python esegue una divisione decimale e il risultato è un {\tt float}:

\begin{verbatim}
>>> minuti/60.0
0.98333333333333328
\end{verbatim}


\section{Espressioni e istruzioni}

Un'{\bf espressione} è una combinazione di valori, variabili e operatori. Un valore è considerato già di per sé un'espressione, come pure una variabile, per cui quelle che seguono sono tutte delle espressioni valide (supponendo che alla variabile {\tt x} sia già stato assegnato un valore):
\index{espressione}
\index{valutazione}

\begin{verbatim}
17
x
x + 17
\end{verbatim}
%
Un'{\bf istruzione} è una porzione di codice che l'interprete Python può eseguire. Abbiamo già visto due tipi di istruzioni: istruzioni di stampa ({\tt print}) e istruzioni di assegnazione.

Tecnicamente, un'espressione è anche un'istruzione, ma è forse più semplice considerarle come cose distinte. La differenza fondamentale è che l'espressione contiene un valore, l'istruzione no.


\section{Modalità interattiva e modalità script}

Uno dei vantaggi di lavorare con un linguaggio interpretato è quello di poter provare pezzi di codice in modalità interattiva prima di inserirli in uno script. Ma tra le due modalità, ci sono delle differenze che possono disorientare.
\index{modalità interattiva}
\index{modalità script}

Per esempio, usando Python come una calcolatrice, potreste scrivere:

\begin{verbatim}
>>> miglia = 26.2
>>> miglia * 1.61
42.182
\end{verbatim}

La prima riga assegna un valore a {\tt miglia}, e non ha alcun effetto visibile. La seconda riga è un'espressione, e l'interprete la valuta e ne mostra il risultato. Vediamo così che una maratona misura circa 42 chilometri.

Ma se scrivete lo stesso codice in uno script e lo eseguite, non otterrete alcun riscontro. In modalità script, un'espressione, di per sé, non ha effetti visibili. In realtà Python valuta l'espressione, ma non ne mostra il risultato finché non gli dite esplicitamente di farlo:

\begin{verbatim}
miglia = 26.2
print miglia * 1.61
\end{verbatim}

Questo comportamento inizialmente può confondere.

Uno script di solito contiene una sequenza di istruzioni. Se ci sono più istruzioni, i risultati compaiono man mano che le istruzioni vengono eseguite.

Per esempio lo script:

\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
%
visualizza questo:

\begin{verbatim}
1
2
\end{verbatim}
%
mentre l'istruzione di assegnazione non produce alcun output sullo schermo.

\vspace{0.2in}
\begin{exercise}

Scrivete le seguenti istruzioni nell'interprete Python per vedere quali effetti producono:

\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
%
Ora scrivete le stesse istruzioni in uno script ed eseguitelo. Qual è il risultato? Modificate lo script trasformando ciascuna espressione in un'istruzione print, ed eseguitelo nuovamente.
\end{exercise}


\section{Ordine delle operazioni}
\index{ordine delle operazioni}
\index{regole di precedenza}
\index{PEMDAS}

Quando più operatori compaiono in un'espressione, l'ordine in cui viene eseguito il calcolo dipende dalle {\bf regole di precedenza}. Python segue le stesse regole di precedenza usate in matematica. L'acronimo {\bf PEMDAS} è un modo utile per ricordare le regole:
\index{parentesi!priorità nella precedenza}

\begin{itemize}

\item {\bf P}arentesi: hanno il più alto livello di precedenza e possono  essere usate per far valutare l'espressione in qualsiasi ordine volete.    Dato che le espressioni tra parentesi sono valutate per prime, {\tt 2 * (3-1)} fa 4, e {\tt (1+1)**(5-2)} fa 8. Potete usare le parentesi per rendere più leggibile un'espressione come in {\tt (minuti * 100) / 60}, anche se questo non influisce sul risultato.

\item {\bf E}levamento a potenza: ha la priorità successiva, così
{\tt 2**1+1} fa 3, e non 4, e {\tt 3*1**3} fa 3, e non 27.

\item {\bf M}oltiplicazione e {\bf D}ivisione hanno la stessa priorità, superiore ad {\bf A}ddizione e {\bf S}ottrazione, anch'esse aventi la stessa priorità. {\tt 2*3-1} fa 5, e non 4, e {\tt 6+4/2} fa 8, e non 5.

\item Gli operatori con la stessa priorità sono valutati da sinistra verso destra (eccetto la potenza), così nell'espressione {\tt gradi / 2 * pi}, la divisione viene calcolata per prima e il risultato viene moltiplicato per {\tt pi}.  Per dividere per $2 \pi$, dovete usare le parentesi o scrivere {\tt gradi / 2 / pi}.

\end{itemize}

Personalmente, non mi sforzo molto di ricordare le regole di precedenza per gli altri operatori. Se non ne sono certo guardando un'espressione, inserisco le parentesi per fugare ogni dubbio.

\section{Operazioni sulle stringhe}
\index{stringa!operazioni}
\index{operatore!stringa}

In genere non potete effettuare operazioni matematiche sulle stringhe, anche se il loro contenuto sembra essere un numero, quindi gli esempi che seguono non sono validi.

\begin{verbatim}
'2'-'1'    'uova'/'facili'    'terzo'*'una magia'
\end{verbatim}
%
L'operatore {\tt +} invece funziona con le stringhe, anche se non si comporta nel modo consueto: in questo caso esegue il {\bf concatenamento}, cioè unisce le stringhe collegandole ai due estremi. Per esempio:
\index{concatenamento}

\begin{verbatim}
primo = 'bagno'
secondo = 'schiuma'
print primo + secondo
\end{verbatim}
%
Il risultato a video di questo programma è {\tt bagnoschiuma}.

Anche l'operatore {\tt *} funziona sulle stringhe: ne esegue la ripetizione. Per esempio, \verb"'Spam'*3" dà \verb"'SpamSpamSpam'". Uno degli operandi deve essere una stringa, l'altro un numero intero.

Questo utilizzo di {\tt +} e {\tt *} è coerente per analogia con l'addizione e la moltiplicazione in matematica. Così come {\tt 4*3} è equivalente a {\tt 4+4+4}, ci aspettiamo che \verb"'Spam'*3" sia lo stesso di
\verb"'Spam'+'Spam'+'Spam'", ed effettivamente è così. D'altro canto, c'è un particolare sostanziale che rende diverse la somma e la moltiplicazione di numeri interi e di stringhe. Riuscite a pensare ad una proprietà che ha l'addizione ma che non vale per il concatenamento di stringhe?
\index{commutatività}


\section{Commenti}
\index{commento}

Man mano che il programma cresce di dimensioni e diventa più complesso, diventa anche sempre più difficile da leggere. I linguaggi formali sono ricchi di significato, e può risultare difficile capire a prima vista cosa fa un pezzo di codice o perché è stato scritto in un certo modo.

Per questa ragione, è buona abitudine aggiungere delle note ai vostri   programmi, per spiegare in linguaggio naturale cosa sta facendo il programma nelle sue varie parti. Queste note sono chiamate {\bf commenti}, e sono demarcate dal simbolo \verb"#":

\begin{verbatim}
# calcola la percentuale di ora trascorsa
percentuale = (minuti * 100) / 60
\end{verbatim}
%
In questo caso il commento appare su una riga a sé stante. Potete anche inserire un commento alla fine di una riga:


\begin{verbatim}
percentuale = (minuti * 100) / 60     # percentuale di un'ora
\end{verbatim}
%
Qualsiasi cosa scritta dopo il simbolo {\tt \#} e fino alla fine della riga, viene trascurata nell'esecuzione del programma e non ha alcun effetto. 

I commenti più utili sono quelli che documentano caratteristiche del codice di non immediata comprensione. È ragionevole supporre che chi legge il codice possa capire {\em cosa} esso faccia; è molto più utile spiegare {\em perché}.

Questo commento è ridondante e inutile:

\begin{verbatim}
v = 5     # assegna 5 a v
\end{verbatim}
%
Questo commento contiene un'informazione utile che non è contenuta nel codice:

\begin{verbatim}
v = 5     # velocita' in metri/secondo 
\end{verbatim}
%
Dei buoni nomi di variabile possono ridurre la necessità di commenti, ma nomi lunghi possono complicare la lettura, pertanto va trovato un giusto compromesso.


\section{Debug}
\index{debug}

Giunti a questo punto, l'errore di sintassi che è più probabile commettere è di assegnare un nome non valido a una variabile, come {\tt class} e {\tt yield}, che sono parole chiave riservate, oppure \verb"strano~lavoro" e \verb"US$", che contengono caratteri non ammessi.
\index{sintassi!errore di}
\index{errore!di sintassi}

Se inserite uno spazio nel nome di una variabile, Python li interpreta come due operandi senza un operatore:

\begin{verbatim}
>>> brutto nome = 5
SyntaxError: invalid syntax
\end{verbatim}
%
Per gli errori di sintassi, il messaggio di errore non è di grande aiuto. I messaggi più comuni sono {\tt SyntaxError: invalid syntax} e
{\tt SyntaxError: invalid token}, nessuno dei quali è molto informativo.
\index{errore!messaggio di}
\index{uso prima di def}
\index{eccezione}
\index{errore!in esecuzione}
\index{errore!di runtime}

L'errore in esecuzione più frequente è un ``uso prima di def'' cioè cercare di utilizzare una variabile prima di averle assegnato un valore. Questo può succedere anche se scrivete il nome di una variabile sbagliato: 

\begin{verbatim}
>>> capitale = 327.68
>>> interesse = capitlae * tasso
NameError: name 'capitlae' is not defined
\end{verbatim}
%
I caratteri maiuscoli e minuscoli nei nomi delle variabili sono considerati diversi, per cui {\tt LaTeX} non è la stessa cosa di {\tt latex}.
\index{case-sensitivity, nomi di variabile}
\index{semantica!errore di}
\index{errore!di semantica}

La causa più probabile di errore di semantica è l'ordine delle operazioni. Per esempio, se per valutare l'operazione:
 $\frac{1}{2 \pi}$,
scrivete:

\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
%
dato che la divisione viene calcolata per prima, ottenete invece $\pi / 2$, che non è la stessa cosa! Python non ha modo di capire cosa volevate veramente scrivere, per cui in questo caso non vi risulta un messaggio di errore, ma una risposta sbagliata.
\index{ordine delle operazioni}


\section{Glossario}

\begin{description}

\item[valore:]  Una delle unità fondamentali di dati, come un numero o una stringa, che un programma può manipolare.
\index{valore}

\item[tipo:] Una categoria di valori. I tipi che abbiamo visto finora sono i numeri interi (tipo {\tt int}), i numeri in virgola mobile (tipo {\tt
float}), e le stringhe (tipo {\tt str}).
\index{tipo}

\item[intero:] Tipo di dati che rappresenta i numeri interi.
\index{intero}

\item[virgola mobile:] Tipo di dati che rappresenta i numeri con parte decimale; è detto anche {\em floating-point}.
\index{floating-point}
\index{virgola mobile}

\item[stringa:] Tipo di dati che rappresenta sequenze di caratteri.
\index{stringa}

\item[variabile:]  Un nome che fa riferimento ad un valore.
\index{variabile}

\item[istruzione:]  Parte di codice che rappresenta un comando o un'azione.    Finora abbiamo visto istruzioni di assegnazione e istruzioni di stampa.
\index{istruzione}

\item[assegnazione:]  Istruzione che assegna un valore ad una variabile.
\index{assegnazione}

\item[diagramma di stato:]  Rappresentazione grafica di una serie di variabili e dei valori ai quali esse si riferiscono.
\index{diagramma!di stato}

\item[parola chiave riservata:]  Parola chiave che il linguaggio usa per analizzare il programma e che non può essere usata come nome di variabile o di funzione, come {\tt if}, {\tt  def}, e {\tt while}.
\index{parola chiave}

\item[operatore:]  Simbolo speciale che rappresenta un'operazione semplice tipo
          l'addizione, la moltiplicazione o il concatenamento di stringhe.
\index{operatore}

\item[operando:]  Uno dei valori sui quali agisce un operatore.
\index{operando}

\item[divisione intera:] Operazione che divide due numeri e tronca la parte decimale.
\index{divisione intera}

\item[espressione:]  Combinazione di variabili, operatori e valori che rappresentano un unico valore risultante.
\index{espressione}

\item[valutare:]  Semplificare un'espressione eseguendo una serie di operazioni per produrre un singolo valore.
\index{valutazione}

\item[regole di precedenza:]  Insieme di regole che determinano l'ordine dei calcoli di espressioni complesse in cui sono presenti più operandi ed operatori.
\index{regole di precedenza}
\index{precedenza}

\item[concatenare:]  Unire due stringhe tramite l'accodamento della seconda alla prima.
\index{concatenamento}

\item[commento:]  Informazione inserita in un programma riguardante il significato di una sua parte; non ha alcun effetto sull'esecuzione del programma
ma serve solo per facilitarne la comprensione.
\index{commento}

\end{description}


\section{Esercizi}

\begin{exercise}

Supponiamo di eseguire le seguenti istruzioni di assegnazione:

\begin{verbatim}
larghezza = 17
altezza = 12.0
delimitatore = '.'
\end{verbatim}

Per ognuna delle seguenti espressioni, scrivetene il valore e il tipo (del valore risultante)

\begin{enumerate}

\item {\tt larghezza/2}

\item {\tt larghezza/2.0}

\item {\tt altezza/3}

\item {\tt 1 + 2 * 5}

\item {\tt delimitatore * 5}

\end{enumerate}

Usate l'interprete Python per controllare le vostre risposte.
\end{exercise}

\vspace{0.2in}
\begin{exercise}

Fate un po' di pratica con l'interprete Python usandolo come calcolatrice:
\index{calcolatrice}

\begin{enumerate}

\item Il volume di una sfera di raggio $r$ è $\frac{4}{3} \pi r^3$.
  Che volume ha una sfera di raggio 5? Suggerimento: 392,7 è sbagliato!

\item Il prezzo di copertina di un libro è \verb"€" 24,95, ma una libreria ottiene il
  40\% di sconto. I costi di spedizione sono \verb"€" 3 per la prima copia e 75 centesimi per ogni copia aggiuntiva. Qual è il costo totale di 60 copie?

\item Se uscite di casa alle 6:52 di mattina e correte 1 miglio a ritmo blando (8:15 al miglio), poi 3 miglia a ritmo moderato (7:12 al miglio), quindi 1 altro miglio a ritmo blando, a che ora tornate a casa per colazione?
\index{passo di corsa}

\end{enumerate}
\end{exercise}


\chapter{Funzioni}
\label{funcchap}

\section{Chiamate di funzione}
\label{functionchap}
\index{funzione!chiamata di}

Nell'ambito della programmazione, una {\bf funzione} è una sequenza di istruzioni che esegue un calcolo, alla quale viene assegnato un nome.  Per definire una funzione, dovete specificarne il nome e scrivere la sequenza di istruzioni. In un secondo tempo, potete ``chiamare'' la funzione mediante il nome che le avete assegnato. 
Abbiamo già visto un esempio di una {\bf chiamata di funzione}:

\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
%
Il nome di questa funzione è {\tt type}. L'espressione tra parentesi è chiamata {\bf argomento} della funzione, e il risultato che produce è il tipo di valore dell'argomento che abbiamo inserito.
\index{parentesi!argomento in}

Si usa dire che una funzione ``prende'' o ``riceve'' un argomento e ``ritorna'' o ``restituisce'' un risultato.  Il risultato è detto {\bf valore di ritorno}.
\index{argomento}
\index{valore di ritorno}


\section{Funzioni di conversione di tipo}
\index{conversione!di tipo}
\index{tipo!conversione di}

% from Elkner:
% comment on whether these things are _really_ functions?
% use max as an example of a built-in?

% my reply:
% they are on the list of ``built-in functions'' so I am
% willing to call them functions.

Python fornisce una raccolta di funzioni predefinite o {\em built-in}, che convertono i valori da un tipo all'altro. La funzione {\tt int} prende un dato valore e lo converte, se possibile, in intero. Se la conversione è impossibile compare un messaggio d'errore:
\index{int, funzione}
\index{funzione!int}

\begin{verbatim}
>>> int('32')
32
>>> int('Ciao')
ValueError: invalid literal for int(): Ciao
\end{verbatim}
%
{\tt int} può anche convertire valori in virgola mobile in interi, ma non arrotonda bensì tronca la parte decimale.

\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
%
La funzione {\tt float} converte interi e stringhe in numeri a virgola mobile:
\index{float, funzione}
\index{funzione!float}

\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
%
Infine, {\tt str} converte l'argomento in una stringa:
\index{str, funzione}
\index{funzione!str}

\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
%



\section{Funzioni matematiche}
\index{funzioni matematiche}


Python è provvisto di un modulo matematico che contiene le più comuni operazioni matematiche. Un {\bf modulo} è un file che contiene una raccolta di funzioni correlate.
\index{modulo}
\index{oggetto!modulo}

Prima di poter usare le funzioni di un modulo, dobbiamo dire all'interprete di caricare il modulo in memoria. Questa operazione viene detta ``importazione'':

\begin{verbatim}
>>> import math
\end{verbatim}
%
Questa istruzione crea un {\bf oggetto modulo} chiamato math. Se stampate l'oggetto modulo ottenete alcune informazioni su di esso:

\begin{verbatim}
>>> print math
<module 'math' (built-in)>
\end{verbatim}
%
L'oggetto modulo contiene le funzioni e le variabili definite all'interno del modulo stesso. Per chiamare una funzione inclusa in un modulo, dobbiamo specificare nell'ordine il nome del modulo che la contiene e il nome della funzione, separati da un punto. Questo formato è chiamato {\bf notazione a punto} o {\em dot notation}.
\index{dot notation}
\index{notazione a punto}

\begin{verbatim}
>>> rapporto = potenza_segnale / potenza_rumore
>>> decibel = 10 * math.log10(rapporto)

>>> radianti = 0.7
>>> altezza = math.sin(radianti)
\end{verbatim}
%
Il primo esempio utilizza \verb"log10" per calcolare un rapporto segnale/rumore in decibel (a condizione che siano stati definiti i valori di \verb"potenza_segnale" e \verb"potenza_rumore").  Il modulo math contiene anche {\tt log}, che calcola i logaritmi naturali in base {\tt e}.
\index{log, funzione}
\index{funzione!log}
\index{seno, funzione}
\index{radiante}
\index{funzione!trigonometrica}


Il secondo esempio calcola il seno della variabile {\tt radianti}. Il nome della variabile spiega già che {\tt sin} e le altre funzioni trigonometriche ({\tt cos}, {\tt tan}, ecc.) accettano argomenti espressi in radianti. Per convertire da gradi in radianti occorre dividere per 360 e moltiplicare per $2 \pi$:

\begin{verbatim}
>>> gradi = 45
>>> radianti = gradi / 360.0 * 2 * math.pi
>>> math.sin(radianti)
0.707106781187
\end{verbatim}
%
L'espressione {\tt math.pi} ricava la variabile {\tt pi} dal modulo matematico. Il suo valore è un'approssimazione di $\pi$, accurata a circa 15 cifre. 
\index{pi}

Se ricordate la trigonometria, potete verificare il risultato precedente confrontandolo con la radice quadrata di due diviso due:
\index{sqrt, funzione}
\index{funzione!sqrt}

\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
%

\section{Composizione}
\index{composizione}

Finora, abbiamo considerato gli elementi di un programma - variabili, espressioni e istruzioni - separatamente, senza parlare di come utilizzarli insieme.

Una delle caratteristiche più utili dei linguaggi di programmazione è la loro capacità di prendere dei piccoli pezzi e {\bf comporli} tra loro. Per esempio, l'argomento di una funzione può essere un qualunque tipo di espressione, incluse operazioni aritmetiche:

\begin{verbatim}
x = math.sin(gradi / 360.0 * 2 * math.pi)
\end{verbatim}
%
E anche chiamate di funzione:

\begin{verbatim}
x = math.exp(math.log(x+1))
\end{verbatim}
%
Potete mettere quasi ovunque un valore o un'espressione a piacere, con una eccezione: il lato sinistro di una istruzione di assegnazione deve essere un nome di una variabile. Ogni altra espressione darebbe un errore di sintassi (vedremo più avanti le eccezioni a questa regola).

\begin{verbatim}
>>> minuti = ore * 60                 # giusto
>>> ore * 60 = minuti                 # sbagliato!
SyntaxError: can't assign to operator
\end{verbatim}
%
\index{SyntaxError}
\index{eccezione!SyntaxError}


\section{Aggiungere nuove funzioni}

Finora abbiamo soltanto usato solo funzioni che sono parte integrante di Python, ma è anche possibile aggiungerne di nuove.
Una {\bf definizione di funzione} specifica il nome di una nuova funzione e la sequenza di istruzioni che viene eseguita quando la funzione viene chiamata.
\index{funzione}
\index{funzione!definizione di}
\index{definizione!di funzione}

Ecco un esempio:

\begin{verbatim}
def stampa_brani():
    print "Terror di tutta la foresta egli e',"
    print "Con l'ascia in mano si sente un re."
\end{verbatim}
%
{\tt def} è una parola chiave riservata che indica la definizione di una nuova funzione. Il nome della funzione è \verb"stampa_brani".  Le regole per i nomi delle funzioni sono le stesse dei nomi delle variabili: lettere, numeri e alcuni segni di interpunzione sono permessi, ma il primo carattere non può essere un numero. Non si possono usare parole riservate, e bisogna evitare di avere una funzione e una variabile con lo stesso nome.
\index{def, parola chiave}
\index{parola chiave!def}
\index{argomento}

Le parentesi vuote dopo il nome indicano che la funzione non accetta alcun argomento.
\index{parentesi!vuote}
\index{intestazione}
\index{corpo}
\index{indentazione}
\index{due punti}

La prima riga della definizione di funzione è chiamata {\bf intestazione};
il resto è detto {\bf corpo}. L'intestazione deve terminare con i due punti e il corpo deve essere indentato, cioè deve avere un rientro rispetto all'intestazione. Per convenzione, l'indentazione è sempre di quattro spazi (vedi Paragrafo~\ref{editor}). Il corpo può contenere un qualsiasi numero di istruzioni.

Le stringhe nelle istruzioni print sono racchiuse tra virgolette (`` ''). Le virgolette e gli apici (' ') sono equivalenti; la maggioranza degli utenti usa gli apici, eccetto nei casi in cui nel testo da stampare sono contenuti degli apici (che possono essere usati anche come apostrofi o accenti). In questi casi, bisogna usare le virgolette.
\index{ellissi}

Se scrivete una funzione in modalità interattiva, l'interprete mette tre puntini di sospensione ({\em ...}) per indicare che la definizione non è completa:

\begin{verbatim}
>>> def stampa_brani():
...     print "Terror di tutta la foresta egli e',"
...     print "Con l'ascia in mano si sente un re."
...
\end{verbatim}
%
Per concludere la funzione, dovete inserire una riga vuota (questo non è necessario in uno script).

La definizione di una funzione crea una variabile con lo stesso nome:

\begin{verbatim}
>>> print stampa_brani
<function stampa_brani at 0xb7e99e9c>
>>> type(stampa_brani)
<type 'function'>
\end{verbatim}
%
Il valore di \verb"stampa_brani" è un {\bf oggetto funzione}, che è di tipo \verb"'function'".
\index{oggetto!funzione}

La sintassi per chiamare la nuova funzione è la stessa che abbiamo visto per le funzioni predefinite:

\begin{verbatim}
>>> stampa_brani()
Terror di tutta la foresta egli e',
Con l'ascia in mano si sente un re.
\end{verbatim}
%
Una volta definita una funzione, si può utilizzarla all'interno di un'altra funzione. Per esempio, per ripetere due volte il brano precedente possiamo scrivere una funzione \verb"ripeti_brani":

\begin{verbatim}
def ripeti_brani():
    stampa_brani()
    stampa_brani()
\end{verbatim}
%
E quindi chiamare \verb"ripeti_brani":

\begin{verbatim}
>>> ripeti_brani()
Terror di tutta la foresta egli e',
Con l'ascia in mano si sente un re.
Terror di tutta la foresta egli e',
Con l'ascia in mano si sente un re.
\end{verbatim}
%
Ma a dire il vero, la canzone non fa così!


\section{Definizioni e utilizzi}
\index{funzione!definizione di}

Raggruppando assieme i frammenti di codice del Paragrafo precedente il programma diventa:

\begin{verbatim}
def stampa_brani():
    print "Terror di tutta la foresta egli e',"
    print "Con l'ascia in mano si sente un re."

def ripeti_brani):
    stampa_brani()
    stampa_brani()

ripeti_brani()
\end{verbatim}
%
Questo programma contiene due definizioni di funzione: \verb"stampa_brani" e
\verb"ripeti_brani".  Le definizioni di funzione sono eseguite come le altre istruzioni, ma il loro effetto è solo quello di creare una nuova funzione. Le istruzioni all'interno di una definizione non sono eseguite finché la funzione non viene chiamata, e la definizione di per sé non genera alcun risultato.
\index{uso prima di def}

Come potete immaginare, una funzione deve essere definita prima di poterla usare: la definizione della funzione deve sempre precedere la sua chiamata.
\vspace{0.2in}
\begin{exercise}

Spostate l'ultima riga del programma all'inizio, per fare in modo che la chiamata della funzione appaia prima della definizione. Eseguite il programma e guardate che tipo di messaggio d'errore ottenete.

\end{exercise}
\vspace{0.2in}
\begin{exercise}

Riportate la chiamata della funzione al suo posto, e spostate la definizione di \verb"stampa_brani" dopo la definizione di \verb"ripeti_brani". Cosa succede quando eseguite il programma?

\end{exercise}


\section{Flusso di esecuzione}
\index{flusso di esecuzione}

Per assicurarvi che una funzione sia definita prima del suo uso, dovete conoscere l'ordine in cui le istruzioni vengono eseguite, cioè il {\bf flusso di esecuzione} del programma.

L'esecuzione inizia sempre dalla prima riga del programma e le istruzioni sono eseguite una alla volta dall'alto verso il basso.

Le definizioni di funzione non alterano il flusso di esecuzione del programma ma va ricordato che le istruzioni all'interno delle funzioni non vengono eseguite fino a quando la funzione non viene chiamata. 

Una chiamata di funzione è una sorta di deviazione nel flusso di esecuzione: invece di proseguire con l'istruzione successiva, il flusso salta alla prima riga della funzione chiamata ed esegue tutte le sue istruzioni; alla fine della funzione il flusso riprende dal punto dov'era stato deviato.

Sinora è tutto abbastanza semplice, ma dovete tenere conto che una funzione può chiamarne un'altra al suo interno. Nel bel mezzo di una funzione, il programma può dover eseguire le istruzioni situate in un'altra funzione. Ma mentre esegue la nuova funzione, il programma può doverne eseguire un'altra ancora!

Fortunatamente, Python sa tener bene traccia di dove si trova, e ogni volta che una funzione viene completata il programma ritorna al punto che aveva lasciato. Giunto all'ultima istruzione, dopo averla eseguita, il programma termina.

Morale della favola? Quando leggete un programma non limitatevi sempre a farlo dall'alto in basso. Spesso ha più senso cercare di seguire il flusso di esecuzione.


\section{Parametri e argomenti}
\label{parametri}
\index{parametro}
\index{funzione!parametro di}
\index{argomento}
\index{funzione!argomento di}

Alcune delle funzioni che abbiamo visto richiedono degli argomenti. Per esempio, se volete trovare il seno di un numero chiamando la funzione {\tt math.sin}, dovete passarle quel numero come argomento. Alcune funzioni ricevono più di un argomento: a {\tt math.pow} ne servono due, che sono la base e l'esponente dell'operazione di elevamento a potenza. 

All'interno della funzione, gli argomenti che le vengono passati sono assegnati ad altrettante variabili chiamate {\bf parametri}. Ecco un esempio di una funzione che riceve un argomento:
\index{parentesi!parametri in}

\begin{verbatim}
def stampa2volte(bruce):
    print bruce
    print bruce
\end{verbatim}
%
Questa funzione assegna l'argomento ricevuto ad un parametro chiamato {\tt bruce}. Quando la funzione viene chiamata, stampa il valore del parametro (qualunque esso sia) due volte.

Questa funzione lavora con qualunque valore che possa essere stampato.

\begin{verbatim}
>>> stampa2volte('Spam')
Spam
Spam
>>> stampa2volte(17)
17
17
>>> stampa2volte(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
%
Le stesse regole di composizione che valgono per le funzioni predefinite si applicano anche alle funzioni definite dall'utente, pertanto possiamo usare come argomento per \verb"stampa2volte" qualsiasi espressione:
\index{composizione}

\begin{verbatim}
>>> stampa2volte('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> stampa2volte(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
%
L'argomento viene valutato prima della chiamata alla funzione, pertanto nell'esempio appena proposto le espressioni \verb"'Spam '*4" e
{\tt math.cos(math.pi)} vengono valutate una volta sola.
\index{argomento}

Potete anche usare una variabile come argomento di una funzione:

\begin{verbatim}
>>> michael = 'Eric, the half a bee.'
>>> stampa2volte(michael)
Eric, the half a bee.
Eric, the half a bee.
\end{verbatim}
%
Il nome della variabile che passiamo come argomento ({\tt michael}) non ha niente a che fare con il nome del parametro nella definizione della funzione ({\tt bruce}).  Non ha importanza come era stato denominato il valore di partenza (nel codice chiamante); qui in \verb"stampa2volte", chiamiamo tutto quanto {\tt bruce}.


\section{Variabili e parametri sono locali}
\index{variabile!locale}

Quando create una variabile in una funzione, essa è {\bf locale},
cioè esiste solo all'interno della funzione. Per esempio:
\index{parentesi!parametri in}

\begin{verbatim}
def cat2volte(parte1, parte2):
    cat = parte1 + parte2
    stampa2volte(cat)
\end{verbatim}
%
Questa funzione prende due argomenti, li concatena e poi ne stampa il risultato due volte. Ecco un esempio che la utilizza:
\index{concatenamento}

\begin{verbatim}
>>> riga1 = 'Bing tiddle '
>>> riga2 = 'tiddle bang.'
>>> cat2volte(riga1, riga2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
\end{verbatim}
%
Quando \verb"cat2volte" termina, la variabile {\tt cat} viene distrutta. Se provassimo a stamparla, otterremmo infatti un messaggio d'errore:
\index{NameError}
\index{eccezione!NameError}

\begin{verbatim}
>>> print cat
NameError: name 'cat' is not defined
\end{verbatim}
%
Anche i parametri sono locali: al di fuori della funzione \verb"stampa2volte", non esiste alcuna cosa chiamata {\tt bruce}.
\index{parametri}


\section{Diagrammi di stack}
\label{stackdiagram}
\index{diagramma!di stack}
\index{funzione!frame di}
\index{frame}

Per tenere traccia di quali variabili possono essere usate e dove, è talvolta utile disegnare un {\bf diagramma di stack}. Come i diagrammi di stato, i diagrammi di stack mostrano il valore di ciascuna variabile, ma in più indicano a quale funzione essa appartiene.


Ogni funzione è rappresentata da un {\bf frame}, un riquadro con il nome della funzione a fianco e la lista dei suoi parametri e delle sue variabili all'interno. Il diagramma di stack nel caso dell'esempio precedente, è illustrato in Figura~\ref{fig.stack}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/stack.pdf}}
\caption{Diagramma di stack.}
\label{fig.stack}
\end{figure}


I frame sono disposti in una pila che indica quale funzione ne ha chiamata un'altra e così via. Nell'esempio, \verb"stampa2volte" è stata chiamata da \verb"cat2volte", e \verb"cat2volte" è stata a sua volta chiamata da 
\verb"__main__", che è un nome speciale per il frame principale. Quando si crea una variabile che è esterna ad ogni funzione, essa appartiene a 
\verb"__main__".

Ogni parametro fa riferimento allo stesso valore del suo argomento corrispondente. Così, {\tt parte1} ha lo stesso valore di
{\tt riga1}, {\tt parte2} ha lo stesso valore di {\tt riga2},
e {\tt bruce} ha lo stesso valore di {\tt cat}.

Se si verifica un errore durante la chiamata di una funzione, Python mostra il nome della funzione, il nome della funzione che l'ha chiamata, il nome della funzione che a sua volta ha chiamato quest'ultima e così via, fino a raggiungere il primo livello che è sempre \verb"__main__".

Ad esempio se cercate di accedere a {\tt cat} dall'interno di
\verb"stampa2volte", ottenete un errore di tipo {\tt NameError}:

\begin{verbatim}
Traceback (innermost last):
  File "test.py", line 13, in __main__
    cat2volte(riga1, riga2)
  File "test.py", line 5, in cat2volte
    stampa2volte(cat)
  File "test.py", line 9, in stampa2volte
    print cat
NameError: name 'cat' is not defined
\end{verbatim}
%
Questo elenco di funzioni è detto {\bf traceback}. Il traceback vi dice in quale file è avvenuto l'errore, e in quale riga, e quale funzione era in esecuzione in quel momento. Mostra anche la riga di codice che ha causato l'errore.
\index{traceback}

L'ordine delle funzioni nel traceback è lo stesso di quello dei frame nel diagramma di stack. La funzione attualmente in esecuzione si trova in fondo all'elenco.


\section{Funzioni produttive e funzioni vuote}
\index{funzione!produttiva}
\index{funzione!vuota} 

Alcune delle funzioni che abbiamo usato, tipo le funzioni matematiche, restituiscono dei risultati; in mancanza di definizioni migliori, personalmente le chiamo {\bf funzioni produttive}.  Altre funzioni, come \verb"stampa2volte", eseguono un'azione ma non restituiscono alcun valore. Le chiameremo {\bf funzioni vuote}.

Quando chiamate una funzione produttiva, quasi sempre è per fare qualcosa di utile con il suo risultato, tipo assegnarlo a una variabile o usarlo come parte di un'espressione.

\begin{verbatim}
x = math.cos(radianti)
aureo = (math.sqrt(5) + 1) / 2
\end{verbatim}
%
Se chiamate una funzione in modalità interattiva, Python ne mostra il risultato:

\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
%
Ma in uno script, se chiamate una funzione produttiva così come è, il valore di ritorno è perso!

\begin{verbatim}
math.sqrt(5)
\end{verbatim}
%
Questo script in effetti calcola la radice quadrata di 5, ma non conserva nè visualizza il risultato, per cui non è di grande utilità.
\index{modalità interattiva}
\index{modalità script}

Le funzioni vuote possono visualizzare qualcosa sullo schermo o avere qualche altro effetto, ma non restituiscono un valore. Se provate comunque ad assegnare il risultato ad una variabile, ottenete un valore speciale chiamato
{\tt None} (nulla).
\index{None, valore speciale}
\index{valore speciale!None}

\begin{verbatim}
>>> risultato = stampa2volte('Bing')
Bing
Bing
>>> print risultato
None
\end{verbatim}
%
Il valore {\tt None} non è la stessa cosa della stringa \verb"'None'". 
È un valore speciale che appartiene ad un tipo tutto suo:

\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
%
Le funzioni che abbiamo scritto finora, sono tutte vuote. Cominceremo a scriverne di produttive tra alcuni capitoli.


\section{Perché le funzioni?}
\index{funzione!motivi}

Potrebbe non esservi ancora ben chiaro perché valga la pena di suddividere il programma in funzioni. Ecco alcuni motivi:

\begin{itemize}

\item Creare una nuova funzione vi dà modo di dare un nome a un gruppo di istruzioni, rendendo il programma più facile da leggere e da correggere.

\item Le funzioni possono rendere un programma più breve eliminando il codice ripetitivo. Se in un secondo tempo dovete fare una modifica, basterà farla in un posto solo.

\item Dividere un programma lungo in funzioni vi permette di correggere le parti una per una, per poi assemblarle in un complesso funzionante.

\item Funzioni ben fatte sono spesso utili per più programmi. Quando ne avete scritta e corretta una, la potete riutilizzare tale e quale.

\end{itemize}


\section{Importare con {\tt from}}

Python fornisce due metodi per importare i moduli. Ne abbiamo già incontrato uno:

\begin{verbatim}
>>> import math
>>> print math
<module 'math' (built-in)>
>>> print math.pi
3.14159265359
\end{verbatim}
%
Quando importate {\tt math}, ottenete un oggetto modulo di nome {\tt math}
che contiene delle costanti come {\tt pi} (il pi-greco) e funzioni come {\tt sin} e {\tt exp}.

Ma se tentate di accedere a {\tt pi} direttamente, otterrete un errore.

\begin{verbatim}
>>> print pi
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'pi' is not defined
\end{verbatim}
%
Un'alternativa è di importare un oggetto da un modulo in questa maniera:

\begin{verbatim}
>>> from math import pi
\end{verbatim}
%
Ora potete accedere a {\tt pi} direttamente, senza usare la notazione a punto.
\index{dot notation}

\begin{verbatim}
>>> print pi
3.14159265359
\end{verbatim}
%
Oppure potete usare l'operatore asterisco per importare {\it tutto} da un modulo:

\begin{verbatim}
>>> from math import *
>>> cos(pi)
-1.0
\end{verbatim}

Il vantaggio di importare tutto dal modulo matematico è che il vostro codice diventa più conciso. Per contro, potrebbero insorgere delle omonimie tra nomi definiti in moduli diversi, o tra un nome del modulo importato e una delle vostre variabili.


\section{Debug}
\label{editor}
\index{debug}

Se usate un editor di testo per scrivere gli script, potreste incontrare dei problemi nell'indentare il codice con spazi e tabulazioni. Il modo migliore per evitare problemi di questo tipo è usare esclusivamente gli spazi, non le tabulazioni. La maggior parte degli editor studiati per Python lo fanno in modo predefinito, ma alcuni no.
\index{spazi}

Tabulazioni e spazi di solito sono invisibili, rendendo difficoltoso il debug: cercate quindi di usare un editor che gestisca l'indentazione automaticamente.

Non dimenticate di salvare il programma prima di eseguirlo. Alcuni ambienti di sviluppo lo fanno automaticamente, ma altri no. In quest'ultimo caso, il programma che eseguite potrebbe non essere lo stesso che state guardando nell'editor.

Il debug può richiedere molto tempo se continuate a eseguire tutte le volte lo stesso programma non corretto!

Siate certi che il codice che state guardando sia lo stesso che eseguite. Se avete qualche dubbio, mettete qualcosa come \verb"print 'ciao'" all'inizio del programma ed eseguitelo di nuovo. Se non vi compare \verb"ciao", allora non state eseguendo il programma giusto!




\section{Glossario}

\begin{description}

\item[funzione:] Una sequenza di istruzioni dotata di un nome che esegue una certa operazione utile. Le funzioni possono o meno ricevere argomenti e possono o meno produrre un risultato.
\index{funzione}

\item[definizione di funzione:]  Istruzione che crea una nuova funzione, specificandone il nome, i parametri, e le istruzioni che esegue.
\index{funzione!definizione di}

\item[oggetto funzione:]  Valore creato da una definizione di funzione. Il nome della funzione è una variabile che fa riferimento a un oggetto funzione.
\index{oggetto!funzione}

\item[intestazione:] La prima riga di una definizione di funzione.
\index{intestazione}

\item[corpo:] La sequenza di istruzioni all'interno di una definizione di funzione.
\index{corpo}

\item[parametro:] Un nome usato all'interno di una funzione che fa riferimento al valore passato come argomento.
\index{parametro}

\item[chiamata di funzione:] Istruzione che esegue una funzione. Consiste nel nome della funzione seguito da un elenco di argomenti.
\index{funzione!chiamata di}

\item[argomento:]  Un valore fornito (passato) a una funzione quando viene chiamata. Questo valore viene assegnato al corrispondente parametro nella funzione.
\index{argomento}

\item[variabile locale:]  Variabile definita all'interno di una funzione e che puo essere usata solo all'interno della funzione.
\index{variabile!locale}

\item[valore di ritorno:]  Il risultato di una funzione. Se una chiamata di funzione viene usata come espressione, il valore di ritorno è il valore dell'espressione.
\index{valore di ritorno}

\item[funzione produttiva:] Una funzione che restituisce un valore.
\index{funzione!produttiva}

\item[funzione vuota:] Una funzione che non restituisce un valore.
\index{funzione!vuota}

\item[modulo:] Un file che contiene una raccolta di funzioni correlate e altre definizioni.
\index{modulo}

\item[istruzione import:] Istruzione che legge un file modulo e crea un oggetto modulo utilizzabile.
\index{import, istruzione}
\index{istruzione!import}

\item[oggetto modulo:] Valore creato da un'istruzione {\tt import} che fornisce l'accesso ai valori definiti in un modulo.
\index{modulo}

\item[dot notation o notazione a punto:]  Sintassi per chiamare una funzione di un modulo diverso, specificando il nome del modulo seguito da un punto e dal nome della funzione.
\index{dot notation}
\index{notazione a punto}

\item[composizione:] Utilizzare un'espressione come parte di un'espressione più grande o un'istruzione come parte di un'istruzione più grande.
\index{composizione}

\item[flusso di esecuzione:]  L'ordine in cui vengono eseguite le istruzioni nel corso di un programma.
\index{flusso di esecuzione}

\item[diagramma di stack:]  Rappresentazione grafica di una serie di funzioni impilate, delle loro variabili e dei valori a cui fanno riferimento.
\index{diagramma!di stack}

\item[frame:]  Un riquadro in un diagramma di stack che rappresenta una chiamata di funzione. Contiene le variabili locali e i parametri della funzione.
\index{funzione!frame di}
\index{frame}

\item[traceback:]  Elenco delle funzioni in corso di esecuzione, stampato quando si verifica un errore.
\index{traceback}


\end{description}


\section{Esercizi}

\begin{exercise}
\index{len, funzione}
\index{funzione!len}

Python contiene una funzione predefinita chiamata {\tt len} che restituisce la lunghezza di una stringa, ad esempio il valore di \verb"len('allen')" è 5.

Scrivete una funzione chiamata \verb"giustif_destra" che richieda una stringa {\tt s} come parametro e stampi la stringa con tanti spazi iniziali da far sì che l'ultima lettera della stringa cada nella colonna 70 del display.

\begin{verbatim}
>>> giustif_destra('allen')
                                                                 allen
\end{verbatim}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{oggetto!funzione}

Un oggetto funzione è un valore che potete assegnare a una variabile o passare come argomento. Ad esempio, \verb"fai2volte" è una funzione che accetta un oggetto funzione come argomento e la chiama per due volte.

\begin{verbatim}
def fai2volte(f):
    f()
    f()
\end{verbatim}

Ecco un esempio che usa \verb"fai2volte" per chiamare una funzione di nome \verb"stampa_spam" due volte.

\begin{verbatim}
def stampa_spam():
    print 'spam'

fai2volte(stampa_spam)
\end{verbatim}

\begin{enumerate}

\item Scrivete questo esempio in uno script e provatelo.

\item Modificate \verb"fai2volte" in modo che accetti due argomenti, un oggetto funzione e un valore, e che chiami la funzione due volte passando il valore come argomento.

\item Scrivete una versione più generale di \verb"stampa_spam", di nome
\verb"stampa_2volte", che richieda una stringa come parametro e la stampi due volte.

\item Usate la versione modificata di \verb"fai2volte" per chiamare
\verb"stampa_2volte" per due volte, passando \verb"'spam'" come argomento.

\item Definite una nuova funzione di nome \verb"fai_quattro" che richieda un oggetto funzione e un valore e chiami la funzione per 4 volte, passando il valore come argomento. Dovrebbero esserci solo due istruzioni nel corpo di questa funzione, non quattro.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/do_four.py}.

\end{exercise}


\vspace{0.2in}
\begin{exercise}

Questo esercizio può essere svolto con le sole istruzioni e caratteristiche del linguaggio imparate finora.

\begin{enumerate}

\item Scrivete una funzione che disegni una griglia come questa:
\index{griglia}

\begin{verbatim}
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
\end{verbatim}
%
Suggerimento: per stampare più di un valore per riga, usate print con una sequenza di valori separati da virgole:

\begin{verbatim}
print '+', '-'
\end{verbatim}
%
Se la sequenza termina con una virgola, Python lascia in sospeso la riga, e il successivo valore stampato compare sulla stessa riga.

\begin{verbatim}
print '+', 
print '-'
\end{verbatim}
%
L'output di questa istruzione è \verb"'+ -'".

Un'istruzione {\tt print} a sé stante, termina la riga e va a capo.

\item Scrivete una funzione che disegni una griglia simile, con quattro righe e quattro colonne.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/grid.py}.
Fonte: Esercizio tratto da Oualline, {\em Practical C Programming, Third Edition}, O'Reilly Media, 1997.

\end{exercise}





\chapter{Esercitazione: Progettazione dell'interfaccia}
\label{turtlechap}

Il codice degli esempi di questo capitolo è scaricabile dal sito
\url{http://thinkpython.com/code/polygon.py}.


\section{TurtleWorld}
\label{turtleworld}
\index{TurtleWorld}
\index{Swampy}

Come ausilio a questo libro, ho preparato un pacchetto chiamato Swampy. Potete scaricarlo dal sito \url{http://thinkpython.com/swampy};
per installarlo nel vostro sistema, seguite le istruzioni pubblicate sul sito.

Un {\bf pacchetto} è una raccolta di moduli; uno dei moduli di Swampy si chiama
{\tt TurtleWorld} (Mondo delle Tartarughe), e fornisce un gruppo di funzioni per disegnare delle linee guidando delle tartarughe per lo schermo.
\index{pacchetto}

Se il pacchetto Swampy è correttamente installato nel vostro sistema, potete importare {\tt TurtleWorld} in questo modo:

\begin{verbatim}
from swampy.TurtleWorld import *
\end{verbatim}

Se avete scaricato i moduli di Swampy ma non li avete installati come pacchetto, potete lavorare nella directory che contiene i file, oppure aggiungere quella directory ai percorsi di ricerca di Python. Poi potete importare
{\tt TurtleWorld} così:

\begin{verbatim}
from TurtleWorld import *
\end{verbatim}

I dettagli del procedimento di installazione e dell'impostazione del percorso di ricerca dipendono dal vostro sistema, e per non aggiungere qui troppi dettagli cercherò di mantenere delle informazioni aggiornate per alcuni sistemi sul sito  \url{http://thinkpython.com/swampy}

Create con un editor di testo un file di nome {\tt mieipoligoni.py} e scriveteci il codice seguente:

\begin{verbatim}
from swampy.TurtleWorld import *

mondo = TurtleWorld()
bob = Turtle()
print bob

wait_for_user()
\end{verbatim}
%
La prima riga importa tutto il modulo {\tt TurtleWorld} contenuto nel pacchetto  
{\tt Swampy}.
\index{import, istruzione}
\index{istruzione!import}

La riga seguente crea un oggetto TurtleWorld assegnato alla variabile {\tt mondo} e una tartaruga assegnata al nome {\tt bob}. Se stampiamo {\tt bob} otteniamo qualcosa del genere:

\begin{verbatim}
<TurtleWorld.Turtle instance at 0xb7bfbf4c>
\end{verbatim}
%
Questo significa che {\tt bob} fa riferimento a un'{\bf istanza} di una tartaruga (Turtle) come definita nel modulo {\tt TurtleWorld}. In questo contesto, ``istanza'' significa un elemento di un insieme; questa tartaruga di nome bob è una dell'insieme di tutte le possibili tartarughe.
\index{istanza}

\verb"wait_for_user" dice a TurtleWorld di attendere che l'utente faccia qualcosa, sebbene in questo caso non ci sia molto che l'utente possa fare, se non chiudere la finestra.

TurtleWorld comprende alcune funzioni per guidare le tartarughe: {\tt fd} e {\tt bk} per avanti e indietro e {\tt lt} e {\tt rt} per girare a sinistra e a destra. Inoltre, ogni tartaruga regge una penna, che può essere appoggiata o sollevata; se la penna è appoggiata, la tartaruga lascia un segno dove passa. Le funzioni {\tt pu} e {\tt pd} stanno per ``penna su (up)'' e ``penna giù (down)''.

Per disegnare un angolo retto, aggiungete queste righe al programma (dopo aver creato {\tt bob} e prima di chiamare \verb"wait_for_user"):

\begin{verbatim}
fd(bob, 100)
lt(bob)
fd(bob, 100)
\end{verbatim}
%
La prima riga dice a {\tt bob} di fare 100 passi avanti. La seconda, di girare a sinistra.

Eseguendo il programma, dovreste vedere {\tt bob} muoversi verso destra e poi su, lasciandosi dietro due segmenti.

Ora provate a modificare il programma per disegnare un quadrato. Non andate avanti finché non ci riuscite!

%\newpage

\section{Ripetizione semplice}
\label{repetition}
\index{ripetizione}

Probabilmente avete scritto qualcosa del genere (tralasciando il codice che crea Turtleworld e mette l'utente in attesa):

\begin{verbatim}
fd(bob, 100)
lt(bob)

fd(bob, 100)
lt(bob)

fd(bob, 100)
lt(bob)

fd(bob, 100)
\end{verbatim}
%
Possiamo ottenere lo stesso risultato in modo più conciso con un'istruzione {\tt for}. Aggiungete questo esempio a {\tt mieipoligoni.py} ed eseguitelo di nuovo:
\index{for, ciclo}
\index{ciclo!for}
\index{istruzione!for}

\begin{verbatim}
for i in range(4):
    print 'Ciao!'
\end{verbatim}
%
Dovreste vedere qualcosa di simile:

\begin{verbatim}
Ciao!
Ciao!
Ciao!
Ciao!
\end{verbatim}
%
Questo è l'utilizzo più semplice dell'istruzione {\tt for}; ne vedremo altri più avanti. Ma questo dovrebbe bastare per permettervi di riscrivere il vostro programma di disegno di quadrati. Proseguite solo dopo averlo fatto.

Ecco l'istruzione {\tt for} che disegna un quadrato:

\begin{verbatim}
for i in range(4):
    fd(bob, 100)
    lt(bob)
\end{verbatim}
%
La sintassi di un'istruzione {\tt for} è simile a quella di una funzione. Ha un'intestazione che termina con i due punti e un corpo indentato che può contenere un numero qualunque di istruzioni.
\index{ciclo}

Un'istruzione {\tt for} è chiamata {\bf ciclo} perché il flusso dell'esecuzione ne attraversa il corpo per poi ritornare indietro e ripeterlo da capo. In questo caso, il corpo viene eseguito per quattro volte.

Questa versione del disegno di quadrati è in realtà un pochino differente dalla precedente, in quanto provoca un'ultima svolta della tartaruga dopo aver disegnato l'ultimo lato. Ciò comporta un istante di tempo in più, ma il codice viene semplificato, inoltre lascia la tartaruga nella stessa posizione di partenza, rivolta nella direzione iniziale.

\section{Esercizi}

Quella che segue è una serie di esercizi che utilizzano TurtleWorld. Sono pensati per essere divertenti, ma hanno anche uno scopo. Mentre ci lavorate su, provate a pensare quale sia.

I paragrafi successivi contengono le soluzioni degli esercizi, per cui non guardatele finché non avete finito (o almeno provato).

\begin{enumerate}

\item Scrivete una funzione di nome {\tt quadrato} che richieda un parametro di nome {\tt t}, che è una tartaruga. La funzione deve usare la tartaruga per disegnare un quadrato.

Scrivete una chiamata alla funzione {\tt quadrato} che passi {\tt bob} come argomento, ed eseguite nuovamente il programma.

\item Aggiungete a {\tt quadrato} un nuovo parametro di nome {\tt lunghezza}.
Modificate il corpo in modo che la lunghezza dei lati sia {\tt lunghezza}, quindi modificate la chiamata alla funzione in modo da fornire un secondo argomento. Eseguite di nuovo il programma e provatelo con vari valori di {\tt
lunghezza}.

\item Le funzioni {\tt lt} e {\tt rt} eseguono in modo predefinito dei cambi di direzione di 90 gradi, ma è possibile passare un secondo argomento che specifichi il numero dei gradi. Per esempio, {\tt lt(bob, 45)} ruota {\tt bob} di 45 gradi a sinistra.

Fate una copia di {\tt quadrato} e cambiate il nome in {\tt poligono}.  Aggiungete un altro parametro di nome {\tt n} e modificate il corpo in modo che sia disegnato un poligono regolare di n lati. Suggerimento: gli angoli esterni di un poligono regolare di n lati misurano $360/n$ gradi.
\index{poligono, funzione}
\index{funzione!poligono}

\item Scrivete una funzione di nome {\tt cerchio} che prenda come parametri una tartaruga, {\tt t}, e un raggio, {\tt r}, e che disegni un cerchio approssimato utilizzando {\tt poligono} con una appropriata lunghezza e numero di lati. Provate la funzione con diversi valori di {\tt r}.
\index{cerchio, funzione}
\index{funzione!cerchio}

Suggerimento: pensate alla circonferenza del cerchio e accertatevi che
{\tt lunghezza * n = circonferenza}.

Altro suggerimento: se {\tt bob} è troppo lento potete accelerarlo cambiando {\tt bob.delay}, che regola il tempo tra due movimenti, in secondi.  {\tt bob.delay = 0.01} dovrebbe dargli una mossa.

% change this to world.delay

\item Create una versione più generica della funzione {\tt cerchio} di nome {\tt arco}, che richieda un parametro aggiuntivo {\tt angolo}, il quale determina la porzione di cerchio da disegnare.  {\tt angolo} è espresso in gradi, quindi se {\tt angolo=360}, {\tt arco} dovrebbe disegnare un cerchio completo.
\index{arco, funzione}
\index{funzione!arco}

\end{enumerate}

\section{Incapsulamento}

Il primo esercizio chiede di inserire il codice per disegnare un quadrato in una definizione di funzione, passando la tartaruga come argomento. Ecco una soluzione:

\begin{verbatim}
def quadrato(t):
    for i in range(4):
        fd(t, 100)
        lt(t)

quadrato(bob)
\end{verbatim}
%
Le istruzioni più interne, {\tt fd} e {\tt lt} sono doppiamente indentate per significare che si trovano all'interno del ciclo {\tt for}, che a sua volta è all'interno della funzione. L'ultima riga, {\tt quadrato(bob)}, è a livello del margine sinistro, pertanto segna la fine sia del ciclo {\tt for} che della definizione di funzione.

Dentro la funzione, {\tt t} si riferisce alla stessa tartaruga a cui si riferisce {\tt bob}, per cui {\tt lt(t)} ha lo stesso effetto di {\tt lt(bob)}.
Ma allora perché non chiamare {\tt bob} il parametro? Il motivo è che {\tt t}
può essere qualunque tartaruga, non solo {\tt bob}, e in questa maniera è possibile anche creare una seconda tartaruga e passarla come parametro a {\tt quadrato}:

\begin{verbatim}
ray = Turtle()
quadrato(ray)
\end{verbatim}
%
L'inglobare un pezzo di codice in una funzione è chiamato {\bf incapsulamento}. Uno dei benefici dell'incapsulamento è che appiccica un nome al codice, il che può servire come una sorta di documentazione. Un altro vantaggio è il riuso del codice: è più conciso chiamare una funzione due volte che copiare e incollare il corpo!
\index{incapsulamento}


\section{Generalizzazione}

Il passo successivo è aggiungere a {\tt quadrato} un parametro {\tt lunghezza}.
Ecco una soluzione:

\begin{verbatim}
def quadrato(t, lunghezza):
    for i in range(4):
        fd(t, lunghezza)
        lt(t)

quadrato(bob, 100)
\end{verbatim}
%
L'aggiunta di un parametro a una funzione è chiamata {\bf generalizzazione}
poiché rende la funzione più generale: nella versione precedente, il quadrato aveva sempre la stessa dimensione, ora può essere grande a piacere.
\index{generalizzazione}

Anche il passo seguente è una generalizzazione. Invece di disegnare solo quadrati, {\tt poligono} disegna poligoni regolari di un qualunque numero di lati. Ecco una soluzione:

\begin{verbatim}
def poligono(t, n, lunghezza):
    angolo = 360.0 / n
    for i in range(n):
        fd(t, lunghezza)
        lt(t, angolo)

poligono(bob, 7, 70)
\end{verbatim}
%
Questo codice disegna un ettagono regolare con lati di lunghezza 70. Quando in una funzione avete più di qualche argomento numerico, è facile dimenticare a cosa si riferiscono o in quale ordine sono disposti. È consentito, e a volte opportuno, includere i nomi dei parametri nell'elenco degli argomenti:

\begin{verbatim}
poligono(bob, n=7, lunghezza=70)
\end{verbatim}
%
Questi sono detti {\bf argomenti con nome} perché includono il nome del parametro a cui vengono passati, quale ``parola chiave'' (da non confondere con le parole chiave riservate come {\tt while} e {\tt def}).
\index{argomento!con nome}

Questa sintassi rende il programma più leggibile. È anche un appunto di come funzionano argomenti e parametri: quando chiamate una funzione, gli argomenti vengono assegnati a quei parametri.


\section{Progettazione dell'interfaccia}

Il prossimo passaggio è scrivere {\tt cerchio}, che richiede come parametro il raggio, {\tt r}. Ecco una semplice soluzione che usa {\tt poligono} per disegnare un poligono di 50 lati:

\begin{verbatim}
def cerchio(t, r):
    circonferenza = 2 * math.pi * r
    n = 50
    lunghezza = circonferenza / n
    poligono(t, n, lunghezza)
\end{verbatim}
%
La prima riga calcola la circonferenza di un cerchio di raggio
{\tt r} usando la nota formula $2 \pi r$. Dato che usiamo {\tt math.pi}, vi ricordo che dovete prima importare il modulo {\tt math}.  Per convenzione, l'istruzione {\tt import} si scrive all'inizio dello script.

{\tt n} è il numero di segmenti del nostro cerchio approssimato, e {\tt lunghezza} è la lunghezza di ciascun segmento. Così facendo, {\tt poligono}
disegna un poligono di 50 lati che approssima un cerchio di raggio {\tt r}.

Un limite di questa soluzione è che {\tt n} è costante, il che comporta che per cerchi molto grandi i segmenti sono troppo lunghi, e per cerchi piccoli perdiamo tempo a disegnare minuscoli segmenti. Una soluzione sarebbe di generalizzare la funzione tramite un parametro {\tt n}, dando all'utente (chiunque chiami la funzione {\tt cerchio}) più controllo, ma rendendo così l'interfaccia meno chiara.
\index{interfaccia}

L'{\bf interfaccia} è un riassunto di come è usata la funzione: quali sono i parametri? Che cosa fa la funzione? Qual è il valore restituito? Un'interfaccia è considerata ``pulita'' se è ``più semplice possibile, ma non necessariamente più semplice. (Einstein)''
\index{Einstein, Albert}

In questo esempio, {\tt r} appartiene all'interfaccia perché specifica il cerchio da disegnare. {\tt n} è meno pertinente perché riguarda i dettagli di {\em come} il cerchio viene reso.

Piuttosto di ingombrare l'interfaccia di parametri, è meglio scegliere un valore appropriato di {\tt n} che dipenda da {\tt circonferenza}:

\begin{verbatim}
def cerchio(t, r):
    circonferenza = 2 * math.pi * r
    n = int(circonferenza / 3) + 1
    lunghezza = circonferenza / n
    poligono(t, n, lunghezza)
\end{verbatim}
%
Ora il numero di segmenti è (circa) {\tt circonferenza/3}, e la lunghezza dei segmenti è (circa) 3, che è abbastanza piccolo da dare un cerchio di bell'aspetto, ma abbastanza grande da essere efficiente e appropriato per qualsiasi dimensione del cerchio.


\section{Refactoring}
\label{refactoring}
\index{refactoring}

Nello scrivere {\tt cerchio}, ho potuto riusare {\tt poligono}
perché un poligono con molti lati è una buona approssimazione di un cerchio. Ma la funzione {\tt arco} non è così collaborativa; non possiamo usare {\tt poligono}
o {\tt cerchio} per disegnare un arco.

Un'alternativa è partire da una copia di {\tt poligono} e trasformarla in {\tt arco}. Il risultato può essere qualcosa del genere:

\begin{verbatim}
def arco(t, r, angolo):
    arco_lunghezza = 2 * math.pi * r * angolo / 360
    n = int(arco_lunghezza / 3) + 1
    passo_lunghezza = arco_lunghezza / n
    passo_angolo = float(angolo) / n
    
    for i in range(n):
        fd(t, passo_lunghezza)
        lt(t, passo_angolo)
\end{verbatim}
%
La seconda metà di questa funzione somiglia a {\tt poligono}, ma non possiamo riusare questa funzione senza cambiarne l'interfaccia. Potremmo generalizzare {\tt poligono} in modo che riceva un angolo come terzo argomento, ma allora {\tt poligono} non sarebbe più un nome appropriato! Invece, creiamo una funzione più generale chiamata {\tt polilinea}:

\begin{verbatim}
def polilinea(t, n, lunghezza, angolo):
    for i in range(n):
        fd(t, lunghezza)
        lt(t, angolo)
\end{verbatim}
%
Ora possiamo riscrivere {\tt poligono} e {\tt arco} in modo che usino {\tt polilinea}:

\begin{verbatim}
def poligono(t, n, lunghezza):
    angolo = 360.0 / n
    polilinea(t, n, lunghezza, angolo)

def arco(t, r, angolo):
    arco_lunghezza = 2 * math.pi * r * angolo / 360
    n = int(arco_lunghezza / 3) + 1
    passo_lunghezza = arco_lunghezza / n
    passo_angolo = float(angolo) / n
    polilinea(t, n, passo_lunghezza, passo_angolo)
\end{verbatim}
%
Infine, riscriviamo {\tt cerchio} in modo che usi {\tt arco}:

\begin{verbatim}
def cerchio(t, r):
    arco(t, r, 360)
\end{verbatim}
%
Questo procedimento di riarrangiare una programma per migliorare le interfacce delle funzioni e facilitare il riuso del codice, è chiamato {\bf refactoring}.
In questo caso, abbiamo notato che in {\tt arco} e in {\tt poligono} c'era del codice simile, allora abbiamo semplificato il tutto in {\tt polilinea}.
\index{refactoring}

Avendoci pensato prima, avremmo potuto scrivere {\tt polilinea} direttamente, evitando il refactoring, ma spesso all'inizio di un lavoro non si hanno le idee abbastanza chiare per progettare al meglio tutte le interfacce. Una volta cominciato a scrivere il codice, si colgono meglio i problemi. A volte il refactoring è segno che avete imparato qualcosa.


\section{Tecnica di sviluppo}
\index{tecnica di sviluppo!incapsulamento e generalizzazione}

Una {\bf tecnica di sviluppo} è una procedura di scrittura dei programmi. Quello che abbiamo usato in questa esercitazione si chiama ``incapsulamento e generalizzazione''. I passi del procedimento sono:

\begin{enumerate}

\item Iniziare scrivendo un piccolo programma senza definire funzioni.

\item Una volta ottenuto un programma funzionante, incapsularlo in una funzione e dargli un nome.

\item Generalizzare la funzione aggiungendo i parametri appropriati.

\item Ripetere i passi da 1 a 3 fino ad avere un insieme di funzioni. Copiate e incollate il codice funzionante per evitare di riscriverlo (e ricorreggerlo).

\item Cercare le occasioni per migliorare il programma con il refactoring. Ad esempio, se avete del codice simile in più punti, valutate di semplificare rielaborandolo in una funzione più generale.

\end{enumerate}

Questa procedura ha alcuni inconvenienti---vedremo più avanti alcune alternative---ma può essere di aiuto se in principio non sapete bene come suddividere il vostro programma in funzioni. È un approccio che vi permette di progettare man mano che andate avanti.


\section{Stringa di documentazione}
\label{docstring}
\index{docstring}
\index{stringa!di documentazione}

Una {\bf stringa di documentazione}, o {\em docstring}, è una stringa posta all'inizio di una funzione che ne illustra l'interfaccia. Ecco un esempio:

\begin{verbatim}
def polilinea(t, n, lunghezza, angolo):
    """Disegna n segmenti di data lunghezza e angolo
       (in gradi) tra di loro. t e' una tartaruga.
    """    
    for i in range(n):
        fd(t, lunghezza)
        lt(t, angolo)
\end{verbatim}
%
Questa stringa ha triple virgolette, che le consentono di essere divisa su più righe (stringa a righe multiple).
\index{virgolette}
\index{stringa!triple virgolette}
\index{stringa!a righe multiple}

È breve, ma contiene le informazioni essenziali di cui qualcuno potrebbe aver bisogno per usare la funzione. Spiega in modo conciso cosa fa la funzione (senza entrare nei dettagli di come lo fa). Spiega che effetti ha ciascun parametro sul comportamento della funzione e di che tipo devono essere i parametri stessi (se non è ovvio).

Scrivere questo tipo di documentazione è una parte importante della progettazione dell'interfaccia. Un'interfaccia ben studiata dovrebbe essere semplice da spiegare; se fate fatica a spiegare una delle vostre funzioni, può essere segno che l'interfaccia dovrebbe essere migliorata.


\section{Debug}
\index{debug}
\index{interfaccia}

Un'interfaccia è simile ad un contratto tra la funzione e il suo chiamante. Il chiamante si impegna a fornire certi parametri e la funzione si impegna a svolgere un dato lavoro.

Ad esempio, a {\tt polilinea} devono essere passati quattro argomenti: {\tt t} deve essere una tartaruga; {\tt n} il numero dei segmenti, quindi un numero intero; {\tt lunghezza} deve essere un numero positivo; e {\tt angolo} un numero che si intende espresso in gradi.

Questi requisiti sono detti {\bf precondizioni} perché si suppone siano verificati prima che la funzione sia eseguita. Per contro, le condizioni che si devono verificare al termine della funzione sono dette {\bf postcondizioni},  e comprendono l'effetto che deve avere la funzione (come il disegnare segmenti) e ogni altro effetto minore (come muovere la tartaruga o fare altri cambiamenti nel suo Mondo).
\index{precondizione}
\index{postcondizione}

Le precondizioni sono responsabilità del chiamante. Se questi viola una precondizione (documentata in modo appropriato!) e la funzione non fa correttamente ciò che deve, l'errore sta nel chiamante e non nella funzione.

% Removing this because we haven't seen conditionals yet!
%However, for purposes of debugging it is often a good idea for
%functions to check their preconditions rather than assume they are
%true.  If every function checks its preconditions before starting,
%then if something goes wrong, you will know which function to blame.


\section{Glossario}

\begin{description}

\item[istanza:] Un elemento di un insieme. Il Mondo delle Tartarughe di questo capitolo è un elemento dei possibili Mondi delle Tartarughe.
\index{istanza}

\item[ciclo:] Una porzione di programma che può essere eseguita ripetutamente.
\index{ciclo}

\item[incapsulamento:] Il procedimento di trasformare una sequenza di istruzioni in una funzione.
\index{incapsulamento}

\item[generalizzazione:] Il procedimento di sostituire qualcosa di inutilmente specifico (come un numero) con qualcosa di più generale ed appropriato (come una variabile o un parametro).
\index{generalizzazione}

\item[argomento con nome:] Un argomento che include il nome del parametro a cui è destinato come ``parola chiave''.
\index{argomento!con nome}

\item[interfaccia:] Una descrizione di come usare una funzione, incluso il nome, la descrizione degli argomenti e il valore di ritorno.
\index{interfaccia}

\item[refactoring:] Il procedimento di modifica di un programma funzionante per miliorare le interfacce delle funzioni e altre qualità del codice.
\index{refactoring}

\item[tecnica di sviluppo:] Procedura di scrittura dei programmi.
\index{tecnica di sviluppo}

\item[stringa di documentazione o docstring:]  Una stringa che compare in una definizione di una funzione per documentarne l'interfaccia.
\index{docstring}
\index{stringa!documentazione}

\item[precondizione:] Un requisito che deve essere soddisfatto dal chiamante prima di eseguire una funzione.
\index{precondizione}

\item[postcondizione:] Un requisito che deve essere soddisfatto dalla funzione prima di terminare.
\index{postcondizione}

\end{description}


\section{Esercizi}

\begin{exercise}

Scaricate il codice in questo capitolo dal sito
\url{http://thinkpython.com/code/polygon.py}.

\begin{enumerate}

\item Scrivete delle appropriate stringhe di documentazione per {\tt poligono}, {\tt arco} e
{\tt cerchio}.
\index{diagramma!di stack}

\item Disegnate un diagramma di stack che illustri lo stato del programma mentre esegue {\tt cerchio(bob, raggio)}. Potete fare i conti a mano o aggiungere istruzioni {\tt print} al codice.

\item La versione di {\tt arco} nel Paragrafo~\ref{refactoring} non è molto accurata, perché l'approssimazione lineare del cerchio è sempre esterna al cerchio vero. Ne deriva che la tartaruga finisce ad alcune unità di distanza dal traguardo corretto. La mia soluzione mostra un modo per ridurre questo errore. Leggete il codice e cercate di capirlo. Disegnare un diagramma può aiutarvi a comprendere il funzionamento.

\end{enumerate}

\end{exercise}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/flowers.pdf}}
\caption{Fiori delle tartarughe.}
\label{fig.flowers}
\end{figure}

\vspace{0.2in}
\begin{exercise}
\index{fiore}

Scrivete un insieme di funzioni, generali in modo appropriato, che disegni dei fiori stilizzati come in Figura~\ref{fig.flowers}.

Soluzione: \url{http://thinkpython.com/code/flower.py},
richiede anche \url{http://thinkpython.com/code/polygon.py}.

\end{exercise}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/pies.pdf}}
\caption{Torte delle tartarughe.}
\label{fig.pies}
\end{figure}

\vspace{0.2in}
\begin{exercise}
\index{torta}

Scrivete un insieme di funzioni, generali in modo appropriato, che disegni delle forme a torta come in Figura~\ref{fig.pies}.

Soluzione: \url{http://thinkpython.com/code/pie.py}.

\end{exercise}

\begin{exercise}
\index{alfabeto}
\index{macchina da scrivere a tartaruga}

Le lettere dell'alfabeto possono essere costruite con un moderato numero di elementi di base, come linee orizzontali e verticali e alcune curve. Progettate un carattere che possa essere disegnato con un numero minimo di elementi di base e poi scrivete delle funzioni che disegnano le lettere dell'alfabeto.

Dovreste scrivere una funzione per ogni lettera, con nomi tipo
\verb"disegna_a", \verb"disegna_b", ecc., e inserirle in un file di nome {\tt lettere.py}.  Potete scaricare una ``macchina da scrivere a tartaruga'' da \url{http://thinkpython.com/code/typewriter.py}
per aiutarvi a provare il vostro codice.

Soluzione: \url{http://thinkpython.com/code/letters.py}, richiede anche
\url{http://thinkpython.com/code/polygon.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Documentatevi sulle spirali sul sito \url{http://it.wikipedia.org/wiki/Spirale}; quindi scrivete un programma che disegni una spirale di Archimede (o di qualche altro tipo).  Soluzione: \url{http://thinkpython.com/code/spiral.py}.
\index{spirale}
\index{spirale di Archimede} 

\end{exercise}


\chapter{Istruzioni condizionali e ricorsione}

\section{L'operatore modulo}
\index{modulo, operatore}
\index{operatore!modulo}

L'{\bf operatore modulo} si applica a due numeri interi e
   fornisce il resto della divisione del primo operando per il
   secondo. In Python, l'operatore modulo è rappresentato dal segno
   percentuale (\verb"%").  La sintassi è la stessa degli altri operatori
   matematici:

\begin{verbatim}
>>> quoziente = 7 / 3
>>> print quoziente
2
>>> resto = 7 % 3
>>> print resto
1
\end{verbatim}
%
Pertanto 7 diviso 3 fa 2, con il resto di 1.

L'operatore modulo può rivelarsi sorprendentemente utile. Per esempio, permette di controllare se un numero è divisibile per un altro---se
{\tt x \% y} è zero, significa che {\tt x} è divisibile per {\tt y}.
\index{divisibilità}

Inoltre può essere usato per estrarre la cifra più a destra di un numero: {\tt x \% 10} restituisce la cifra più a destra del numero {\tt x} (in base 10). Allo stesso modo, {\tt x \% 100} restituisce le ultime due cifre.


\section{Espressioni booleane}
\index{espressione!booleana}
\index{operatore!logico}

Un'{\bf espressione booleana} è un'espressione che può essere o vera o falsa.  Gli esempi che seguono usano l'operatore {\tt ==}, confrontano due valori e restituiscono {\tt True} (vero) se sono uguali, {\tt False} (falso) altrimenti:

\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
%
{\tt True} e {\tt False} sono valori speciali che sono di tipo {\tt bool}; non sono delle stringhe:
\index{True, valore speciale}
\index{False, valore speciale}
\index{valore speciale!True}
\index{valore speciale!False}
\index{bool, tipo}
\index{tipo!bool}

\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
%
L'operatore {\tt ==} è uno degli {\bf operatori di confronto}; gli altri sono:

\begin{verbatim}
      x != y               # x e' diverso da y
      x > y                # x e' maggiore di y
      x < y                # x e' minore di y
      x >= y               # x e' maggiore o uguale a y
      x <= y               # x e' minore o uguale a y
\end{verbatim}
%
Queste operazioni vi saranno familiari, tuttavia i simboli in Python sono diversi da quelli usati comunemente in matematica. Un errore frequente è quello di usare il simbolo di uguale({\tt =}) invece del doppio uguale
({\tt ==}). Ricordate che {\tt =} è un operatore di assegnazione, mentre
{\tt ==} è un operatore di confronto. Inoltre in Python non esistono simboli del
tipo {\tt =<} o {\tt =>}.
\index{confronto, operatore di}
\index{operatore!confronto}


\section {Operatori logici}
\index{logico, operatore}
\index{operatore!logico}

Ci sono tre {\bf operatori logici}: {\tt and}, {\tt
or}, e {\tt not}.  Il significato di questi operatori è simile al loro significato comune (e, o, non): per esempio, l'espressione {\tt x > 0 and x < 10} è vera solo se {\tt x} è più grande di 0 {\em e} più piccolo di 10.
\index{and, operatore}
\index{or, operatore}
\index{not, operatore}
\index{operatore!and}
\index{operatore!or}
\index{operatore!not}

L'espressione {\tt n\%2 == 0 or n\%3 == 0} invece è vera se si verifica {\em almeno una} delle due condizioni e cioè se il numero è divisibile per 2 {\em o} per 3.

Infine, l'operatore {\tt not} nega il valore di un'espressione booleana,
   trasformando in falsa un'espressione vera e viceversa. Così, {\tt not (x > y)} è vera se {\tt x > y} è falsa, cioè se {\tt x} è minore o uguale a {\tt y}.

In senso stretto, gli operandi degli operatori logici dovrebbero essere delle espressioni booleane, ma da questo punto di vista Python non è troppo fiscale: infatti ogni numero diverso da zero viene considerato ``vero'', e lo zero è considerato ``falso''.

\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
%
Questa flessibilità può essere utile, ma ci sono alcune sottigliezze che potrebbero confondere. È preferibile evitarla (a meno che non sappiate quello che state facendo).


\section{Esecuzione condizionale}
\label{conditional.execution}

\index{istruzione!condizionale}
\index{if, istruzione}
\index{istruzione!if}
\index{esecuzione condizionale}
Per poter scrivere programmi utili, abbiamo quasi sempre la necessità  di valutare delle condizioni e di cambiare il comportamento del programma a seconda del risultato della valutazione. Le {\bf istruzioni condizionali} ci offrono questa possibilità. La forma più semplice è l'istruzione {\tt if} (``se'' in inglese):

\begin{verbatim}
if x > 0:
    print "x e' positivo"
\end{verbatim}
%
L'espressione booleana dopo l'istruzione {\tt if} è chiamata {\bf condizione}.  L'istruzione indentata che segue i due punti della riga if, viene eseguita solo se la condizione è vera. Se la condizione è falsa non viene eseguito nulla.
\index{condizione}
\index{istruzione!composta}

Come nel caso della definizione di funzione, la struttura dell'istruzione {\tt if} è costituita da un'intestazione seguita da un corpo indentato. Le istruzioni come questa vengono chiamate {\bf istruzioni composte}.

Non c'è limite al numero di istruzioni che possono comparire nel corpo, ma deve sempre essercene almeno una. In qualche occasione può essere utile avere un corpo vuoto, ad esempio quando il codice corrispondente non è ancora stato scritto ma si desidera ugualmente provare il programma. In questo caso si può   usare l'istruzione {\tt pass}, che serve solo da segnaposto temporaneo ed è innocua:
\index{pass, istruzione}
\index{istruzione!pass}

\begin{verbatim}
if x < 0:
    pass          # scrivere cosa fare con i valori negativi!
\end{verbatim}
%

\section{Esecuzione alternativa}
\label{alternative.execution}
\index{esecuzione alternativa}
\index{else, parola chiave}
\index{parola chiave!else}

Una seconda forma di istruzione {\tt if} è l'{\bf esecuzione alternativa},
nella quale ci sono due azioni possibili, e il valore della condizione
determina quale delle due debba essere eseguita e quale no. La sintassi è:

\begin{verbatim}
if x % 2 == 0:
    print "x e' pari"
else:
    print "x e' dispari"
\end{verbatim}
%
Se il resto della divisione di {\tt x} per 2 è zero significa che {\tt x} è un numero pari, e il programma mostra il messaggio corrispondente. Se invece la condizione è falsa, viene eseguita la serie di istruzioni descritta dopo la riga {\tt else} (che in inglese significa ``altrimenti''). In ogni caso, una delle due alternative sarà sempre eseguita. Le due alternative sono chiamate {\bf ramificazioni}, perché rappresentano dei bivi nel flusso di esecuzione del programma.
\index{ramificazione}



\section{Condizioni in serie}
\index{serie, condizioni in}
\index{condizione!in serie}

Talvolta occorre tenere conto di più di due possibili sviluppi, pertanto possiamo aver bisogno di più di due ramificazioni. Un modo per esprimere questo tipo di calcolo sono le {\bf condizioni in serie}:

\begin{verbatim}
if x < y:
    print "x e' minore di y"
elif x > y:
    print "x e' maggiore di y"
else:
    print "x e y sono uguali"
\end{verbatim}
%
{\tt elif} è l'abbreviazione di {\em else if}, che in inglese significa   ``altrimenti se''. Anche in questo caso, solo uno dei rami verrà eseguito, a seconda dell'esito del confronto tra {\tt x} e {\tt y}. Non c'è alcun limite al numero di istruzioni {\tt elif}. Se esiste una clausola {\tt else}, deve essere scritta per ultima, ma non è obbligatoria.
\index{elif, parola chiave }
\index{parola chiave!elif}


\begin{verbatim}
if scelta == 'a':
    disegna_a()
elif scelta == 'b':
    disegna_b()
elif scelta == 'c':
    disegna_c()
\end{verbatim}
%
Le condizioni sono controllate nell'ordine in cui sono state scritte: se la prima è falsa viene controllata la seconda e così via. Non appena una condizione risulta vera, viene eseguito il ramo corrispondente e l'intera istruzione {\tt if} si conclude. In ogni caso, anche se risultassero vere altre condizioni successive, dopo l'esecuzione della prima queste verranno trascurate.  


\section{Condizioni nidificate}
\index{condizione!nidificata}

Un'espressione condizionale può anche essere inserita nel corpo di un'altra espressione condizionale. Possiamo scrivere il precedente esempio a tre scelte anche in questo modo:

\begin{verbatim}
if x == y:
    print "x e y sono uguali"
else:
    if x < y:
        print "x e' minore di y"
    else:
        print "x e' maggiore di y"
\end{verbatim}
%
La prima condizione esterna ({\tt if x == y}) contiene due rami: il primo contiene un'istruzione semplice, il secondo un'altra istruzione {\tt if} che a sua volta prevede un'ulteriore ramificazione. Entrambi i rami del secondo {\tt if} sono istruzioni di stampa, ma potrebbero anche contenere a loro volta ulteriori istruzioni condizionali.


Sebbene l'indentazione delle istruzioni aiuti a rendere evidente la struttura, le {\bf condizioni nidificate} diventano rapidamente difficili da leggere, quindi è meglio usarle con moderazione.

Qualche volta, gli operatori logici permettono di semplificare le espressioni condizionali nidificate:

\begin{verbatim}
if 0 < x:
    if x < 10:
        print "x e' un numero positivo a una cifra."
\end{verbatim}
%
L'istruzione {\tt print} è eseguita solo se entrambe le condizioni si verificano. Possiamo allora usare l'operatore booleano {\tt and} per combinarle:

\begin{verbatim}
if 0 < x and x < 10:
    print "x e' un numero positivo a una cifra."
\end{verbatim}


\section{Ricorsione}
\label{recursion}
\index{ricorsione}

Abbiamo visto che è del tutto normale che una funzione ne chiami un'altra, ma è anche consentito ad una funzione di chiamare se stessa. L'utilità può non essere immediatamente evidente, ma questa è una delle cose più magiche che un programma possa fare. Per fare un esempio, diamo un'occhiata a questa funzione:

\begin{verbatim}
def contoallarovescia(n):
    if n <= 0:
        print 'Via!'
    else:
        print n
        contoallarovescia(n-1)
\end{verbatim}
%
Se {\tt n} vale 0 o è negativo, scrive la parola ``Via!''.
Altrimenti scrive il numero {\tt n} e poi chiama la funzione {\tt
contoallarovescia} (cioè se stessa) passando un argomento che vale {\tt n-1}.

Cosa succede quando chiamiamo la funzione in questo modo?

\begin{verbatim}
>>> contoallarovescia(3)
\end{verbatim}
%
L'esecuzione di {\tt contoallarovescia} inizia da {\tt n=3}, e dato che
{\tt n} è maggiore di 0, stampa il valore 3, poi chiama se stessa...

\begin{quote}
L'esecuzione di {\tt contoallarovescia} inizia da {\tt n=2}, e dato che
{\tt n} è maggiore di 0, stampa il valore 2, poi chiama se stessa...

\begin{quote}
L'esecuzione di {\tt contoallarovescia} inizia da {\tt n=1}, e dato che
{\tt n} è maggiore di 0, stampa il valore 1, poi chiama se stessa...

\begin{quote}
L'esecuzione di {\tt contoallarovescia} inizia da {\tt n=0}, e dato che {\tt
n} è uguale a 0, stampa la parola ``Via!'' e poi ritorna.
\end{quote}

La funzione {\tt contoallarovescia} che aveva dato {\tt n=1} ritorna.
\end{quote}

La funzione {\tt contoallarovescia} che aveva dato {\tt n=2} ritorna.
\end{quote}

La funzione {\tt contoallarovescia} che aveva dato {\tt n=3} ritorna.

E infine ritorniamo in \verb"__main__". Il risultato finale è questo:

\begin{verbatim}
3
2
1
Via!
\end{verbatim}
%
Una funzione che chiama se stessa si dice {\bf ricorsiva} e la procedura è detta
{\bf ricorsione}.
\index{ricorsione}
\index{funzione!ricorsiva}

Come secondo esempio, scriviamo una funzione che stampi una data stringa per {\tt n} volte.

\begin{verbatim}
def stampa_n(s, n):
    if n <= 0:
        return
    print s
    stampa_n(s, n-1)
\end{verbatim}
%
Se {\tt n <= 0} l'istruzione {\tt return} provoca l'uscita dalla funzione. Il flusso dell'esecuzione torna immediatamente al chiamante, e le righe rimanenti della funzione non vengono eseguite.
\index{return, istruzione}
\index{istruzione!return}

Il resto della funzione è simile a {\tt contoallarovescia}: se {\tt n} è maggiore di zero, visualizza la stringa {\tt s} e chiama se stessa per $n-1$ altre volte. Il numero di righe risultanti sarà {\tt 1 + (n - 1)}, che corrisponde a
{\tt n}.

Per esempi semplici come questi, è forse più facile usare un ciclo {\tt
for}. Vedremo però più avanti degli esempi difficili da scrivere con un ciclo {\tt for} ma facili con la ricorsione; meglio quindi cominciare subito a prendere mano.



\section{Diagrammi di stack delle funzioni ricorsive}
\label{recursive.stack}
\index{diagramma!di stack}
\index{funzione!frame di}
\index{frame}

Nel Paragrafo~\ref{stackdiagram}, abbiamo usato un diagramma di stack per   rappresentare lo stato di un programma durante una chiamata di funzione. Lo stesso tipo di diagramma può servire a capire come lavora una funzione ricorsiva.

Ogni volta che una funzione viene chiamata, Python crea un nuovo frame della funzione, contenente le variabili locali definite all'interno della funzione ed i suoi parametri. Nel caso di una funzione ricorsiva, possono esserci contemporaneamente più frame riguardanti una stessa funzione.

La Figura~\ref{fig.stack2} mostra il diagramma di stack della funzione {\tt contoallarovescia} chiamata con {\tt n = 3}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/stack2.pdf}}
\caption{Diagramma di stack.}
\label{fig.stack2}
\end{figure}


Come al solito, il livello superiore dello stack è il frame di \verb"__main__".
Questo frame è vuoto, perché in questo caso non vi abbiamo creato alcuna variabile né abbiamo passato alcun parametro.
\index{caso base}
\index{ricorsione!caso base}

I quattro frame di {\tt contoallarovescia} hanno valori diversi del parametro {\tt n}. Il livello inferiore dello stack, dove {\tt n=0}, è chiamato {\bf caso base}. Esso non effettua ulteriori chiamate ricorsive, quindi non ci sono ulteriori frame.

\vspace{0.2in}

\begin{exercise}
Disegnate il diagramma di stack della funzione \verb"stampa_n" chiamata con
\verb"s='Ciao'" e {\tt n=2}.
\end{exercise}

\vspace{0.2in}

\begin{exercise}
Scrivete una funzione di nome \verb"fai_n" che accetti come argomenti un oggetto funzione e un numero {\tt n}, e che chiami per {\tt n} volte la funzione data.
\end{exercise}



\section{Ricorsione infinita}
\index{ricorsione!infinita}
\index{errore!in esecuzione}

\index{traceback}

Se una ricorsione non raggiunge mai un caso base, la chiamata alla funzione viene eseguita all'infinito ed in teoria il programma non giunge mai alla fine. Questa situazione è conosciuta come {\bf ricorsione infinita}, e di solito non è considerata una buona cosa.
Questo è un programma minimo che genera una ricorsione infinita:

\begin{verbatim}
def ricorsiva():
    ricorsiva()
\end{verbatim}
%
Nella maggior parte degli ambienti, un programma con una ricorsione infinita non viene eseguito davvero all'infinito. Python stampa un messaggio di errore quando è stato raggiunto il massimo livello di ricorsione possibile:
\index{eccezione!RuntimeError}
\index{RuntimeError}

\begin{verbatim}
  File "<stdin>", line 2, in ricorsiva
  File "<stdin>", line 2, in ricorsiva
  File "<stdin>", line 2, in ricorsiva
                  .   
                  .
                  .
  File "<stdin>", line 2, in ricorsiva
RuntimeError: Maximum recursion depth exceeded
\end{verbatim}
%
Questo traceback è un po' più lungo di quello che abbiamo visto nel capitolo precedente. Quando si verifica l'errore, nello stack ci sono oltre 1000 frame di chiamata di {\tt ricorsiva}!



\section{Input da tastiera}
\index{Input da tastiera}

I programmi che abbiamo scritto finora sono piuttosto grezzi, nel senso che non accettano inserimenti di dati da parte dell'operatore, limitandosi a eseguire sempre le stesse operazioni.

Python 2 comprende una funzione predefinita chiamata \verb"raw_input" che permette di inserire dati da tastiera. In Python 3, la funzione si chiama
  {\tt input}. Quando questa funzione viene chiamata, il programma si ferma ed attende che l'operatore scriva qualcosa e confermi poi l'inserimento premendo il tasto {\sf Invio} o {\sf Enter}. A quel punto il programma riprende e \verb"raw_input" restituisce ciò che l'operatore ha inserito sotto forma di stringa:
\index{Python 3}
\index{raw\_input, funzione}
\index{funzione!raw\_input}

\begin{verbatim}
>>> testo = raw_input()
Cosa stai aspettando?
>>> print testo
Cosa stai aspettando?
\end{verbatim}
%
Prima di chiamare la funzione, è buona norma stampare un messaggio che informa l'utente di ciò che deve inserire. Questo messaggio è chiamato prompt, e può essere passato come argomento a \verb"raw_input" :
\index{prompt}

\begin{verbatim}
>>> nome = raw_input('Come ti chiami?\n')
Come ti chiami?
Artu', Re dei Bretoni!
>>> print nome
Artu', Re dei Bretoni!
\end{verbatim}
%
La sequenza \verb"\n" alla fine del prompt rappresenta un {\bf ritorno a capo},
un carattere speciale che provoca un'interruzione di riga. Ecco perché l'input dell'utente compare sulla riga successiva sotto al prompt.
\index{ritorno a capo}

Se il valore da inserire è un intero possiamo provare a convertire il valore inserito in {\tt int}:


\begin{verbatim}
>>> prompt = "Qual e' la velocita' in volo di una rondine?\n"
>>> velocita = raw_input(prompt)
Qual e' la velocita' in volo di una rondine?
17
>>> int(velocita)
17
\end{verbatim}
%
Ma se la stringa inserita contiene qualcosa di diverso da dei numeri, si verifica un errore:

\begin{verbatim}
>>> velocita = raw_input(prompt)
Qual e' la velocita' in volo di una rondine?
Cosa intendi, una rondine europea o africana?
>>> int(velocita)
ValueError: invalid literal for int() with base 10
\end{verbatim}
%
Vedremo più avanti come trattare questo tipo di errori.
\index{ValueError}
\index{eccezione!ValueError}


\section{Debug}
\label{whitespace}
\index{debug}
\index{traceback}

Il traceback che Python mostra quando si verifica un errore contiene molte informazioni, ma può essere sovrabbondante quando ci sono molti frame nello stack. Di solito le parti più utili sono:

\begin{itemize}

\item Che tipo di errore era, e

\item Dove si è verificato.

\end{itemize}

Gli errori di sintassi di solito sono facili da trovare, tranne qualcuno. Gli spaziatori possono essere insidiosi, perché spazi e tabulazioni non sono visibili e siamo abituati a non tenerne conto.
\index{spaziatore}

\begin{verbatim}
>>> x = 5
>>>  y = 6
  File "<stdin>", line 1
    y = 6
    ^
IndentationError: unexpected indent
\end{verbatim}
%
In questo esempio, il problema è che la seconda riga è indentata di uno spazio. Ma il messaggio di errore punta su {\tt y}, portando fuori strada. In genere, i messaggi di errore indicano dove il problema è venuto a galla, ma l'errore vero potrebbe essere in un punto precedente del codice, a volte anche nella riga precedente.

\index{errore!in esecuzione}

Lo stesso vale per gli errori di runtime. 

Supponiamo di voler calcolare un rapporto segnale/rumore in decibel. La formula è
 $SNR_{db} = 10 \log_{10} (P_{segnale} / P_{rumore})$. In Python si può scrivere:

\begin{verbatim}
import math
potenza_segnale = 9
potenza_rumore = 10
rapporto = potenza_segnale / potenza_rumore
decibel = 10 * math.log10(rapporto)
print decibel
\end{verbatim}
%
Ma se lo eseguite in Python 2, compare un messaggio di errore.
\index{eccezione!OverflowError}
\index{OverflowError}

\begin{verbatim}
Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibel = 10 * math.log10(rapporto)
ValueError: math domain error
\end{verbatim}
%
Il messaggio punta alla riga 5, ma lì non c'è niente di sbagliato. Per trovare il vero errore, può essere utile stampare il valore di {\tt rapporto}, che risulta essere 0. Il problema è nella riga 4, perché la divisione di due interi dà una divisione intera. La soluzione è rappresentare i valori del segnale e del rumore in numeri decimali a virgola mobile (9.0 e 10.0).
\index{divisione!intera}

In genere, i messaggi di errore dicono dove è emerso il problema, ma spesso la causa è altrove.

In Python 3, questo esempio funziona senza causare errori: infatti, nella nuova versione l'operatore di divisione esegue una divisione decimale anche con operandi interi.


\section{Glossario}

\begin{description}

\item[operatore modulo:]  Operatore matematico, denotato con il segno di percentuale ({\tt \%}), che restituisce il resto della divisione tra due operandi
interi.
\index{modulo, operatore}
\index{operatore!modulo}

\item[espressione booleana:]  Espressione il cui valore è o vero 
({\tt True}) o falso ({\tt False}).
\index{espressione!booleana}

\item[operatore di confronto:] Un operatore che confronta due valori detti operandi: {\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, e {\tt <=}.

\item[operatore logico:] Un operatore che combina due espressioni booleane: {\tt and}, {\tt or}, e {\tt not}.

\item[istruzione condizionale:]  Istruzione che controlla il flusso di esecuzione del programma a seconda del verificarsi o meno di certe condizioni.
\index{istruzione!condizionale}

\item[condizione:] Espressione booleana in un'istruzione condizionale che      determina quale ramificazione debba essere seguita dal flusso di esecuzione.
\index{condizione}

\item[istruzione composta:]  Istruzione che consiste di un'intestazione terminante con i due punti (:) e di un corpo composto di una o più istruzioni
indentate rispetto all'intestazione.
\index{istruzione!composta}

\item[ramificazione:] Una delle sequenze di istruzioni alternative scritte in una istruzione condizionale.
\index{ramificazione}

\item[condizioni in serie:]  Istruzione condizionale con una serie di ramificazioni alternative.
\index{condizione!in serie}

\item[condizione nidificata o annidata:]  Un'istruzione condizionale inserita in una ramificazione di un'altra istruzione condizionale.
\index{condizione!nidificata}

\item[ricorsione:]  Chiamata della stessa funzione attualmente in esecuzione.
\index{ricorsione}

\item[caso base:]  Ramificazione di un'istruzione condizionale, posta in una    funzione ricorsiva, che non esegue a sua volta una chiamata ricorsiva.
\index{caso base}

\item[ricorsione infinita:]  Una ricorsione priva di un caso base, oppure che non lo raggiunge mai. Nell'evenienza, causa un errore in esecuzione.
\index{ricorsione!infinita}

\end{description}

\section{Esercizi}

\begin{exercise}
\index{Fermat, ultimo teorema di}

L'ultimo teorema di Fermat afferma che non esistono interi positivi
$a$, $b$, e $c$ tali che

\[ a^n + b^n = c^n \]
%
per qualsiasi valore di $n$ maggiore di 2.

\begin{enumerate}

\item Scrivete una funzione di nome \verb"verifica_fermat" che richieda quattro parametri---{\tt a}, {\tt b}, {\tt c} e {\tt n}---e controlli se il teorema regge. Se $n$ è maggiore di 2 e capitasse che 

\[a^n + b^n = c^n \]
%
il programma deve visualizzare: ``Santi Numi, Fermat si è sbagliato!'',
altrimenti: ``No, questo non è vero.''

\item Scrivete una funzione che chieda all'utente di inserire valori di {\tt a}, {\tt b}, {\tt c} e {\tt n}, li converta in interi e usi \verb"verifica_fermat" per controllare se violano il teorema di Fermat.

\end{enumerate}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{triangolo}

Dati tre bastoncini, può essere possibile o meno riuscire a sistemarli in modo da formare un triangolo. Per esempio, se uno dei bastoncini misura 12 centimetri e gli altri due 1 centimetro, è chiaro che non riuscireste a far toccare le estremità di tutti e tre i bastoncini. Date tre lunghezze, c'è una semplice regola per controllare se è possibile formare un triangolo:

\begin{quotation}
Se una qualsiasi delle tre lunghezze è maggiore della somma delle altre due, non potete formare un triangolo. (Se la somma di due lunghezze è uguale alla terza, si ha un triangolo ``degenere''.)
\end{quotation}

\begin{enumerate}

\item Scrivete una funzione di nome \verb"triangolo" che riceva tre interi come argomenti e che mostri ``Si''' o ``No'', a seconda che si possa o meno formare un triangolo con dei bastoncini delle tre lunghezze date.

\item Scrivete una funzione che chieda all'utente di inserire tre lunghezze, le converta in interi, e le passi a \verb"triangolo" per verificare se si possa o meno formare un triangolo.

\end{enumerate}

\end{exercise}

Gli esercizi seguenti utilizzano TurtleWorld del Capitolo~\ref{turtlechap}:
\index{TurtleWorld}

\vspace{0.2in}
\begin{exercise}

Leggete la seguente funzione e cercate di capire cosa fa. Quindi eseguitela (vedere gli esempi nel Capitolo~\ref{turtlechap}).

\begin{verbatim}
def disegna(t, lunghezza, n):
    if n == 0:
        return
    angolo = 50
    fd(t, lunghezza*n)
    lt(t, angolo)
    disegna(t, lunghezza, n-1)
    rt(t, 2*angolo)
    disegna(t, lunghezza, n-1)
    lt(t, angolo)
    bk(t, lunghezza*n)
\end{verbatim}

\end{exercise}

\vspace{0.2in}
\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/koch.pdf}}
\caption{Una curva di Koch.}
\label{fig.koch}
\end{figure}

\begin{exercise}
\index{curva di Koch}

La curva di Koch è un frattale che somiglia a quello in Figura~\ref{fig.koch}.  Per disegnare una curva di Koch di lunghezza $x$, dovete: 

\begin{enumerate}

\item Disegnare una curva di Koch di lunghezza $x/3$.

\item Girare a sinistra di 60 gradi.

\item Disegnare una curva di Koch di lunghezza $x/3$.

\item Girare a destra di 120 gradi.

\item Disegnare una curva di Koch di lunghezza $x/3$.

\item Girare a sinistra di 60 gradi.

\item Disegnare una curva di Koch di lunghezza $x/3$.

\end{enumerate}

Ad eccezione di quando $x$ è minore di 3: in questo caso si disegna una linea dritta lunga $x$.

\begin{enumerate}

\item Scrivete una funzione di nome {\tt koch} che preveda una tartaruga e una lunghezza come parametri, e che usi la tartaruga per disegnare una curva di Koch della data lunghezza.

\item Scrivete una funzione chiamata {\tt fioccodineve} che disegni tre curve di Koch per ottenere il contorno di un fiocco di neve.

Soluzione: \url{http://thinkpython.com/code/koch.py}.

\item La curva di Koch può essere generalizzata in alcuni modi. Consultate 
\url{http://it.wikipedia.org/wiki/Curva_di_Koch} per degli esempi e implementate quello che preferite.

\end{enumerate}
\end{exercise}


\chapter{Funzioni produttive}
\label{fruitchap}

\section{Valori di ritorno}
\index{valore di ritorno}

Alcune delle funzioni predefinite che abbiamo usato finora, come quelle matematiche, producono dei risultati: la chiamata della funzione genera un nuovo valore, che di solito viene associato ad una variabile o viene usato come parte di un'espressione.

\begin{verbatim}
e = math.exp(1.0)
altezza = raggio * math.sin(radianti)
\end{verbatim}
%
Tutte le funzioni che abbiamo scritto finora sono ``vuote'': visualizzano qualcosa o muovono tartarughe, ma restituiscono come valore {\tt None}.

In questo capitolo scriveremo finalmente delle funzioni che restituiscono un valore e che chiameremo funzioni ``produttive''.
Il primo esempio è {\tt area}, che fornisce l'area di un cerchio di dato raggio:

\begin{verbatim}
def area(raggio):
    temp = math.pi * raggio**2
    return temp
\end{verbatim}
%
Abbiamo già visto l'istruzione {\tt return}, ma nel caso di una funzione    produttiva questa istruzione include un'espressione. Il suo significato è: ``ritorna immediatamente da questa funzione a quella chiamante e usa questa espressione come valore di ritorno''. L'espressione che rappresenta il valore di ritorno può essere anche complessa, e allora l'esempio precedente può essere riscritto in modo più compatto:
\index{return, istruzione}
\index{istruzione!return}

\begin{verbatim}
def area(raggio):
    return math.pi * raggio**2
\end{verbatim}
%
D'altra parte, una {\bf variabile temporanea} come {\tt temp} spesso rende il
programma più leggibile e ne semplifica il debug.
\index{variabile!temporanea}

Talvolta è necessario prevedere delle istruzioni di ritorno multiple, ciascuna all'interno di una ramificazione di un'istruzione condizionale:

\begin{verbatim}
def valore_assoluto(x):
    if x < 0:
        return -x
    else:
        return x
\end{verbatim}
%
Dato che queste istruzioni {\tt return} si trovano in rami diversi di una
condizione alternativa, solo una di esse verrà effettivamente eseguita.

Non appena viene eseguita un'istruzione {\tt return}, la funzione termina senza eseguire ulteriori istruzioni. Il codice che viene a trovarsi dopo l'istruzione {\tt return} o in ogni altro punto che non può essere raggiunto dal flusso di esecuzione, è denominato {\bf codice morto}.
\index{codice morto}

In una funzione produttiva è bene assicurarsi che ogni possibile flusso di esecuzione del programma porti ad un'uscita dalla funzione con un'istruzione
{\tt return}. Per esempio:

\begin{verbatim}
def valore_assoluto(x):
    if x < 0:
        return -x
    if x > 0:
        return x
\end{verbatim}
%
Questa funzione non è corretta, in quanto se {\tt x} è uguale a 0, nessuna delle due condizioni è vera e la funzione termina senza incontrare un'istruzione {\tt return}. Se il flusso di esecuzione arriva alla fine della funzione, il valore di ritorno è {\tt None}, che non è certo il valore assoluto di 0.
\index{None, valore speciale}
\index{valore speciale!None}

\begin{verbatim}
>>> print valore_assoluto(0)
None
\end{verbatim}
%
A proposito: Python comprende già la funzione {\tt abs} che calcola il valore assoluto.
\index{abs, funzione}
\index{funzione!abs}

\vspace{0.2in}
\begin{exercise}
\index{compara, funzione}
\index{funzione!compara}

Scrivete una funzione di nome {\tt compara} che restituisce
 {\tt 1} se {\tt x > y}, {\tt 0} se {\tt x == y}, e {\tt -1} se {\tt x < y}.
\end{exercise}


\section{Sviluppo incrementale}
\label{incremental.development}
\index{tecnica di sviluppo!incrementale}

A mano a mano che scriverete funzioni di complessità maggiore, vi troverete a impiegare più tempo per il debug.

Per fare fronte a programmi via via più complessi, suggerisco una tecnica chiamata {\bf sviluppo incrementale}. Lo scopo dello sviluppo incrementale è evitare lunghe sessioni di debug, aggiungendo e testando continuamente piccole parti di codice alla volta.
\index{test!sviluppo incrementale}
\index{teorema di Pitagora}

Come esempio, supponiamo che vogliate trovare la distanza tra due punti, note le coordinate $(x_1, y_1)$ e $(x_2, y_2)$.
Per il teorema di Pitagora, la distanza è

\begin{displaymath}
\mathrm{distanza} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{displaymath}
%
La prima cosa da considerare è l'aspetto che la funzione {\tt distanza} deve avere in Python, chiarendo subito quali siano i parametri che deve avere la funzione e quale sia il valore di ritorno da ottenere.

Nel nostro caso i dati di partenza (o di {\em input}) sono i due punti, rappresentabili attraverso le loro coordinate (due coppie di numeri); il risultato (o {\em output}) è la distanza, che è un valore decimale.

Possiamo così scrivere un primo abbozzo di funzione:

\begin{verbatim}
def distanza(x1, y1, x2, y2):
    return 0.0
\end{verbatim}
%
Ovviamente questa prima versione non calcola ancora la distanza, ma restituisce sempre 0. Però è già una funzione sintatticamente corretta e può essere eseguita: potete quindi provarla prima di procedere a renderla più complessa.

Proviamo allora la nuova funzione, chiamandola con dei valori di esempio:

\begin{verbatim}
>>> distanza(1, 2, 4, 6)
0.0
\end{verbatim}
%
Ho scelto questi valori in modo che la loro distanza orizzontale sia 3  e quella verticale 4. In tal modo, il risultato è pari a 5 (è l'ipotenusa di un triangolo rettangolo i cui cateti sono lunghi 3 e 4). Quando collaudiamo una funzione è sempre utile sapere prima il risultato.
\index{test!sapere il risultato}

A questo punto, abbiamo verificato che la funzione è sintatticamente corretta e possiamo cominciare ad aggiungere righe di codice nel corpo. Un passo successivo plausibile è quello di calcolare le differenze $x_2 - x_1$ e $y_2 - y_1$.  Memorizzeremo queste differenze in variabili temporanee che chiameremo {\tt dx} e {\tt dy}, e le mostreremo a video.

\begin{verbatim}
def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print "dx e' ", dx
    print "dy e' ", dy
    return 0.0
\end{verbatim}
%
Se la funzione è giusta, usando i valori di prima dovrebbe mostrare \verb"'dx e' 3'" e \verb"'dy e' 4'". Se i risultati coincidono, siamo sicuri che la funzione riceve correttamente i parametri ed elabora altrettanto correttamente i primi calcoli. Altrimenti, dovremo controllare solo poche righe.

Proseguiamo con il calcolo della somma dei quadrati di {\tt dx} e {\tt dy}:

\begin{verbatim}
def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquadr = dx**2 + dy**2
    print "dsquadr e': ", dsquadr
    return 0.0
\end{verbatim}
%
Di nuovo, eseguite il programma in questa fase e controllate il risultato, che nel nostro caso dovrebbe essere 25.
Infine, usate la funzione radice quadrata {\tt math.sqrt} per calcolare e restituire il risultato:
\index{sqrt, funzione}
\index{funzione!sqrt}

\begin{verbatim}
def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquadr = dx**2 + dy**2
    risultato = math.sqrt(dsquadr)
    return risultato
\end{verbatim}
%
Se tutto funziona, avete finito. Altrimenti, potete stampare per verifica il valore di {\tt risultato} prima dell'istruzione {\tt return}.

La versione definitiva della funzione non mostra nulla quando viene eseguita; restituisce solo un valore. Le istruzioni {\tt print} che avevamo inserito erano utili per il debug, ma una volta verificato che tutto funziona vanno rimosse. Pezzi di codice temporanei come questi sono detti {\bf impalcature}, perché sono di aiuto nella fase di costruzione del programma ma non fanno parte del prodotto finale. 
\index{impalcatura}

Soprattutto agli inizi, non dovreste mai aggiungere più di qualche riga
di codice alla volta. Con l'esperienza, potrete scrivere e fare il debug di pezzi di codice sempre più corposi. In ogni caso, nelle prime fasi il processo di sviluppo incrementale potrà farvi risparmiare un bel po' di tempo di debug.

Ecco i punti chiave di questa procedura:

\begin{enumerate}

\item Iniziate con un programma funzionante e fate piccoli cambiamenti:
       questo permetterà di scoprire facilmente dove sono localizzati
       gli eventuali errori.

\item Usate variabili temporanee per memorizzare i valori intermedi, così
       da poterli stampare e controllare.

\item Quando il programma funziona perfettamente, rimuovete le istruzioni        temporanee e consolidate le istruzioni multiple in espressioni composte, sempre che questo non renda il programma troppo difficile da leggere.

\end{enumerate}

\vspace{0.2in}
\begin{exercise}
\index{ipotenusa}

Usate lo sviluppo incrementale per scrivere una funzione
     chiamata {\tt ipotenusa}, che restituisca la lunghezza dell'ipotenusa di un
     triangolo rettangolo, dati i due cateti come parametri.
     Registrate ogni passo del processo di sviluppo man mano che 
     procedete.
\end{exercise}


\section{Composizione}
\index{composizione}
\index{funzione!composizione di}

Come potete ormai immaginare, è possibile chiamare una funzione dall'interno di un'altra funzione. Questa proprietà è chiamata {\bf composizione}.

Scriveremo come esempio una funzione che prende due punti geometrici, il centro di un cerchio ed un punto sulla sua circonferenza, e calcola l'area del cerchio.

Supponiamo che le coordinate del centro del cerchio siano memorizzate nelle variabili {\tt xc} e {\tt yc}, e quelle del punto sulla circonferenza in {\tt xp} e {\tt yp}. Innanzitutto, bisogna trovare il raggio del cerchio, che è pari alla distanza tra i due punti. La funzione {\tt distanza} che abbiamo appena scritto, ci torna utile:

\begin{verbatim}
raggio = distanza(xc, yc, xp, yp)
\end{verbatim}
%
Il secondo passo è trovare l'area del cerchio di quel raggio; anche questa funzione l'abbiamo già scritta:

\begin{verbatim}
risultato = area(raggio)
\end{verbatim}
%
Incapsulando il tutto in una funzione otteniamo:
\index{incapsulamento}

\begin{verbatim}
def area_cerchio(xc, yc, xp, yp):
    raggio = distanza(xc, yc, xp, yp)
    risultato = area(raggio)
    return risultato
\end{verbatim}
%
Le variabili temporanee {\tt raggio} e {\tt risultato} sono utili per lo sviluppo
e il debug ma, una volta constatato che il programma funziona, possiamo riscrivere la funzione in modo più conciso componendo le chiamate alle funzioni:

\begin{verbatim}
def area_cerchio(xc, yc, xp, yp):
    return area(distanza(xc, yc, xp, yp))
\end{verbatim}
%

\section{Funzioni booleane}
\label{boolean}

Le funzioni possono anche restituire valori booleani (vero o falso), cosa che è spesso utile per includere al loro interno dei test anche complessi.  
\index{funzione!booleana}
Per esempio:

\begin{verbatim}
def divisibile(x, y):
    if x % y == 0:
        return True
    else:
        return False
\end{verbatim}
%
È prassi assegnare come nomi alle funzioni booleane dei predicati che, con accezione interrogativa, attendono una risposta sì/no; \verb"divisibile" restituisce {\tt True} o {\tt False} per rispondere alla domanda se è vero o no che {\tt x} è divisibile per {\tt y}.

Facciamo un esempio:

\begin{verbatim}
>>>   divisibile(6, 4)
False
>>>   divisibile(6, 3)
True
\end{verbatim}
%
Possiamo scrivere la funzione in modo ancora più conciso, visto che il risultato dell'operatore di confronto {\tt ==} è anch'esso un booleano, restituendolo direttamente:

\begin{verbatim}
def divisibile(x, y):
    return x % y == 0
\end{verbatim}
%
Le funzioni booleane sono usate spesso nelle istruzioni condizionali:
\index{istruzione!condizionale}

\begin{verbatim}
if divisibile(x, y):
    print "x e' divisibile per y"
\end{verbatim}
%
Potreste pensare di scrivere in questo modo:

\begin{verbatim}
if divisibile(x, y) == True:
    print "x e' divisibile per y"
\end{verbatim}
%
ma il confronto supplementare è superfluo.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione \verb"compreso_tra(x, y, z)" che restituisca {\tt True} se $x \le y \le z$ o {\tt False} altrimenti.

\end{exercise}


\section{Altro sulla ricorsione}
\label{more.recursion}
\index{ricorsione}
\index{linguaggio!completo di Turing}
\index{Turing, Alan}
\index{Tesi di Turing}

Abbiamo trattato solo una piccola parte di Python, ma è interessante sapere che questo sottoinsieme è già di per sé un linguaggio di programmazione {\em completo}: questo significa che con gli elementi che già conoscete potete esprimere qualsiasi tipo di elaborazione. Qualsiasi tipo di programma esistente potrebbe essere scritto usando solo le caratteristiche del linguaggio che avete appreso finora (aggiungendo solo alcuni comandi di controllo per gestire dispositivi come tastiera, mouse, dischi, ecc.)

La prova di questa affermazione è un esercizio tutt'altro che banale affrontato per la prima volta da Alan Turing, uno dei pionieri dell'informatica (qualcuno potrebbe obiettare che in realtà era un matematico, ma molti dei primi informatici erano dei matematici). Di conseguenza la dimostrazione è chiamata Tesi di Turing.
Per una trattazione più completa (ed accurata) della Tesi di Turing, consiglio il libro di Michael Sipser, {\em Introduction to the Theory of Computation}.

Per darvi un'idea di cosa potete fare con gli strumenti imparati finora, proveremo a valutare delle funzioni matematiche definite ricorsivamente. Una funzione ricorsiva è simile ad una definizione circolare, nel senso che la sua definizione contiene un riferimento alla cosa che si sta definendo. Una vera definizione circolare non è propriamente utile:

\begin{description}

\item[vorpale:] aggettivo usato per descrivere qualcosa di vorpale.
\index{vorpale}
\index{definizione!circolare}

\end{description}

Sarebbe fastidioso trovare una definizione del genere in un vocabolario.
D'altra parte, considerate la definizione della funzione matematica    fattoriale (indicata da un numero seguito da un punto esclamativo, $!$), cioè:

%
\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n (n-1)!
\end{eqnarray*}
%
Questa definizione afferma che il fattoriale di 0 è 1 e che il fattoriale di ogni altro valore $n$, è $n$ moltiplicato per il fattoriale di $n-1$.

Pertanto, $3!$ è 3 moltiplicato $2!$, che a sua volta è 2 moltiplicato $1!$, che
   a sua volta è 1 moltiplicato $0!$ che per definizione è 1. Riassumendo il tutto, $3!$ è uguale a 3 per 2 per 1 per 1, che fa 6.
\index{fattoriale, funzione}
\index{funzione!fattoriale}
\index{definizione!ricorsiva}

Se potete scrivere una definizione ricorsiva di qualcosa, di solito potete anche scrivere un programma Python per valutarla. Il primo passo è quello di decidere
quali siano i parametri della funzione. Il {\tt fattoriale} ha evidentemente un solo parametro, un intero:

\begin{verbatim}
def fattoriale(n):
\end{verbatim}
%
Se l'argomento è 0, dobbiamo solo restituire il valore 1:

\begin{verbatim}
def fattoriale(n):
    if n == 0:
        return 1
\end{verbatim}
%
Altrimenti, e questa è la parte interessante, dobbiamo fare una chiamata ricorsiva per trovare il fattoriale di $n-1$ e poi moltiplicare questo valore per $n$:

\begin{verbatim}
def fattoriale(n):
    if n == 0:
        return 1
    else:
        ricors = fattoriale(n-1)
        risultato = n * ricors
        return risultato
\end{verbatim}
%
Il flusso di esecuzione del programma è simile a quello di {\tt
contoallarovescia} del Paragrafo~\ref{recursion}. Se chiamiamo {\tt fattoriale}
con il valore 3:

Dato che 3 non è 0, seguiamo il ramo else e calcoliamo il fattoriale
   di {\tt n-1}...

\begin{quote}
Dato che 2 non è 0, seguiamo il ramo else e calcoliamo il fattoriale di {\tt n-1}...


  \begin{quote}
  Dato che 1 non è 0, seguiamo il ramo else e calcoliamo il fattoriale di {\tt n-1}...


    \begin{quote}
    Dato che 0 {\em è} 0, seguiamo il primo ramo e ritorniamo 1 senza fare altre chiamate ricorsive.
    \end{quote}


  Il valore di ritorno (1) è moltiplicato per $n$, che è 1, e il risultato
     ritorna al chiamante.
  \end{quote}


Il valore di ritorno (1) è moltiplicato per $n$, che è 2, e il risultato
     ritorna al chiamante.
\end{quote}


Il valore di ritorno (2) è moltiplicato per $n$, che è 3, e il risultato, 6, diventa il valore di ritorno della funzione che ha fatto partire l'intera procedura.
\index{diagramma!di stack}

La Figura~\ref{fig.stack3} mostra il diagramma di stack per l'intera sequenza di chiamate di funzione:

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/stack3.pdf}}
\caption{Diagramma di stack .}
\label{fig.stack3}
\end{figure}

I valori di ritorno sono illustrati mentre vengono passati all'indietro verso l'alto della pila. In ciascun frame, il valore di ritorno è quello di {\tt risultato}, che è il prodotto di {\tt n} e {\tt ricors}.
\index{funzione!frame di}
\index{frame}

Notate che nell'ultimo frame le variabili locali {\tt ricors} e {\tt risultato} non esistono, perché il ramo che le crea non viene eseguito.


\section{Salto sulla fiducia}
\index{ricorsione}
\index{salto sulla fiducia}

Seguire il flusso di esecuzione è il modo giusto di leggere i programmi, ma
può diventare rapidamente labirintico se le dimensioni del codice aumentano. Un metodo alternativo è quello che io chiamo ``salto sulla fiducia''.  Quando arrivate ad una chiamata di funzione, invece di seguire il flusso di esecuzione, {\em date per scontato} che la funzione chiamata si comporti correttamente e   che restituisca il valore esatto.

Nei fatti, già praticate questo atto di fede quando utilizzate le funzioni predefinite: se chiamate {\tt math.cos} o {\tt math.exp}, non andate a controllare l'implementazione delle funzioni, ma date per scontato che funzionano a dovere perché le hanno scritte dei validi programmatori.

Lo stesso si può dire per le funzioni che scrivete voi: quando
, nel Paragrafo~\ref{boolean}, abbiamo scritto la funzione
\verb"divisibile" che controlla se un numero è divisibile per un altro, e abbiamo verificato che la funzione è corretta,---controllando e provando il codice---possiamo poi usarla senza doverla ricontrollare di nuovo.
\index{test!salto sulla fiducia}

Idem quando abbiamo chiamate ricorsive: invece di seguire il flusso di esecuzione, potete partire dal presupposto che la chiamata ricorsiva funzioni
(dando il risultato corretto), per poi chiedervi: ``Supponendo che io trovi il fattoriale di $n-1$, posso calcolare il fattoriale di $n$?''.  In questo caso è chiaro che potete farlo, moltiplicando per $n$.

Certo, è strano partire dal presupposto che una funzione sia giusta quando non avete ancora finito di scriverla, ma non per nulla si chiama "salto sulla fiducia"!


\section{Un altro esempio}
\label{one.more.example}

\index{fibonacci, funzione}
\index{funzione!fibonacci}
Dopo il {\tt fattoriale}, l'esempio più noto di funzione matematica definita ricorsivamente è la funzione {\tt fibonacci}, che ha la seguente definizione: (vedere \url{http://it.wikipedia.org/wiki/Successione_di_Fibonacci}):
%
\begin{eqnarray*}
&& \mathrm{fibonacci}(0) = 0 \\
&& \mathrm{fibonacci}(1) = 1 \\
&& \mathrm{fibonacci}(n) = \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2)
\end{eqnarray*}
%
Che tradotta in Python è:

\begin{verbatim}
def fibonacci (n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
\end{verbatim}
%
Con una funzione simile, provare a seguire il flusso di esecuzione vi farebbe scoppiare la testa anche con valori di $n$ piuttosto piccoli. Ma in virtù del ``salto sulla fiducia'', dando per scontato che le due chiamate ricorsive funzionino correttamente, è chiaro che la somma dei loro valori di ritorno sarà corretta.
\index{flusso di esecuzione}


\section{Controllo dei tipi}
\label{guardian}

Cosa succede se chiamiamo {\tt fattoriale} passando 1.5 come argomento?
\index{controllo dei tipi}
\index{controllo errore}
\index{fattoriale, funzione}
\index{RuntimeError}

\begin{verbatim}
>>> fattoriale(1.5)
RuntimeError: Maximum recursion depth exceeded
\end{verbatim}
%
Parrebbe una ricorsione infinita. Ma come mai?
   Esiste un caso base---quando {\tt n == 0}.  Ma se {\tt n} non è intero,
{\em manchiamo} il caso base e la ricorsione non si ferma più.
\index{ricorsione!infinita}

Alla prima chiamata ricorsiva, infatti, il valore di {\tt n} è 0.5.
Alla successiva diventa -0.5. Da lì in poi, il valore passato alla funzione diventa ogni volta più piccolo di una unità (cioè più negativo) e non potrà mai essere 0.

Abbiamo due scelte: possiamo tentare di generalizzare la funzione {\tt fattoriale} per farla funzionare anche nel caso di numeri a virgola mobile, o possiamo far controllare alla funzione se il parametro passato è del tipo corretto. La prima possibilità è chiamata in matematica funzione gamma, ma è un po' oltre gli scopi di questo libro; quindi sceglieremo la seconda alternativa.
\index{funzione!gamma}

Possiamo usare la funzione predefinita {\tt isinstance} per verificare il tipo di argomento. E già che ci siamo, ci accerteremo anche che il numero sia positivo:
\index{isinstance, funzione}
\index{funzione!isinstance}

\begin{verbatim}
def fattoriale (n):
    if not isinstance(n, int):
        print "Il fattoriale e' definito solo per numeri interi."
        return None
    elif n < 0:
        print "Il fattoriale non e' definito per interi negativi."
        return None
    elif n == 0:
        return 1
    else:
        return n * fattoriale(n-1)
\end{verbatim}
%
Il primo caso base gestisce i numeri non interi; il secondo cattura gli interi negativi. In entrambi i casi, il programma mostra un messaggio di errore e restituisce il valore {\tt None} per indicare che qualcosa non ha funzionato:

\begin{verbatim}
>>> fattoriale('alfredo')
Il fattoriale e' definito solo per numeri interi.
None
>>> fattoriale(-2)
Il fattoriale non e' definito per interi negativi.
None
\end{verbatim}
% 
Se superiamo entrambi i controlli, possiamo essere
   certi che $n$ è un intero positivo oppure zero, e che la ricorsione avrà
   termine.
\index{guardia, condizione di}
\index{schema!guardiani}
\index{condizione!di guardia}

Questo programma mostra lo schema di funzionamento di una {\bf condizione di guardia}.
I primi due controlli agiscono da ``guardiani'', difendendo il codice che segue da valori che potrebbero causare errori. Le condizioni di guardia rendono possibile provare la correttezza del codice.

Nel Paragrafo~\ref{raise} vedremo un'alternativa più flessibile alla stampa di messaggi di errore: sollevare un'eccezione.


\section{Debug}
\label{factdebug}

La suddivisione di un programma di grandi dimensioni in funzioni più piccole, crea dei naturali punti di controllo per il debug.  \index{debug}
Se una funzione non va, ci sono tre possibilità da prendere in esame:

\begin{itemize}

\item C'è qualcosa di sbagliato negli argomenti che la funzione sta accettando: è violata una precondizione.

\item C'è qualcosa di sbagliato nella funzione: è violata una postcondizione.

\item C'è qualcosa di sbagliato nel valore di ritorno o nel modo in cui viene usato.

\end{itemize}

Per escludere la prima possibilità, potete aggiungere un'istruzione {\tt print} all'inizio della funzione per visualizzare i valori dei parametri (e magari i loro tipi). O potete scrivere del codice che controlla esplicitamente le precondizioni.
\index{precondizione}
\index{postcondizione}

Se i parametri sembrano corretti, aggiungete un'istruzione {\tt print} prima di ogni istruzione {\tt return} in modo che sia mostrato il valore di ritorno. Se possibile, controllate i risultati calcolandoveli a parte. Valutate di chiamare la funzione con dei valori che permettono un controllo agevole del risultato (come nel Paragrafo~\ref{incremental.development}).

Se la funzione sembra a posto, controllate la chiamata per essere sicuri che il valore di ritorno venga usato correttamente (e soprattutto, venga usato!).
\index{flusso di esecuzione}

Aggiungere istruzioni di stampa all'inizio e alla fine di una funzione può aiutare a rendere più chiaro il flusso di esecuzione. Ecco una versione di {\tt fattoriale} con delle istruzioni di stampa:

\begin{verbatim}
def fattoriale(n):
    spazi = ' ' * (4 * n)
    print spazi, 'fattoriale', n
    if n == 0:
        print spazi, 'ritorno 1'
        return 1
    else:
        ricors = fattoriale(n-1)
        risultato = n * ricors
        print spazi, 'ritorno ', risultato
        return risultato
\end{verbatim}
%
{\tt spazi} è una stringa di caratteri di spaziatura che controlla l'indentazione dell'output. Ecco il risultato di {\tt fattoriale(5)} :

\begin{verbatim}
                     fattoriale 5
                 fattoriale 4
             fattoriale 3
         fattoriale 2
     fattoriale 1
 fattoriale 0
 ritorno 1
     ritorno 1
         ritorno 2
             ritorno 6
                 ritorno 24
                     ritorno 120
\end{verbatim}
%
Se il flusso di esecuzione vi confonde, questo tipo di output può aiutarvi. Ci vuole un po' di tempo per sviluppare delle ``impalcature'' efficaci, ma queste possono far risparmiare molto tempo di debug.


\section{Glossario}

\begin{description}

\item[variabile temporanea:]  Variabile usata per memorizzare un risultato intermedio durante un calcolo complesso.
\index{variabile!temporanea}

\item[codice morto:]  Parte di un programma che non può mai essere eseguita, spesso perché compare dopo un'istruzione {\tt return}.
\index{codice morto}

\item[{\tt None}:]  Valore speciale restituito da una funzione che non ha
          un'istruzione return o ha un'istruzione return priva di argomento.
\index{None, valore speciale}
\index{valore speciale!None}

\item[sviluppo incrementale:]  Tecnica di sviluppo del programma inteso ad evitare lunghe sessioni di debug, aggiungendo e provando piccole porzioni di codice alla volta.
\index{sviluppo incrementale}

\item[impalcatura:]  Codice temporaneo inserito solo nella fase di sviluppo del programma e che non fa parte della versione finale.
\index{impalcatura}

\item[condizione di guardia:]  Schema di programmazione che usa una condizione per controllare e gestire le circostanze che possono causare un errore.
\index{guardia, condizione di}
\index{condizione!di guardia}

\end{description}


\section{Esercizi}

\begin{exercise}

Disegnate un diagramma di stack del seguente programma. Che cosa stampa?
Soluzione: \url{http://thinkpython.com/code/stack_diagram.py}.
\index{diagramma di stack}

\begin{verbatim}
def b(z):
    prod = a(z, z)
    print z, prod
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    total = x + y + z
    square = b(total)**2
    return square

x = 1
y = x + 1
print c(x, y+3, x+y)
\end{verbatim}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{ackermann}

La funzione di Ackermann, $A(m, n)$, è così definita:

\begin{eqnarray*}
A(m, n) = \begin{cases} 
              n+1 & \mbox{se } m = 0 \\ 
        A(m-1, 1) & \mbox{se } m > 0 \mbox{ e } n = 0 \\ 
A(m-1, A(m, n-1)) & \mbox{se } m > 0 \mbox{ e } n > 0.
\end{cases} 
\end{eqnarray*}
%
Vedere anche \url{http://it.wikipedia.org/wiki/Funzione_di_Ackermann}.
Scrivete una funzione di nome {\tt ack} che valuti la funzione di Ackermann.
Usate la vostra funzione per calcolare {\tt ack(3, 4)}, vi dovrebbe risultare 125.
Cosa succede per valori maggiori di {\tt m} e {\tt n}?
Soluzione: \url{http://thinkpython.com/code/ackermann.py}.
\index{Ackermann, funzione di}
\index{funzione!ack}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{palindrome}

Un palindromo è una parola che si legge nello stesso modo sia da sinistra verso destra che viceversa, come ``ottetto'' e ``radar''. In termini ricorsivi, una parola è un palindromo se la prima e l'ultima lettera sono uguali e ciò che resta in mezzo è un palindromo.
\index{palindromo}

Quelle che seguono sono funzioni che hanno una stringa come parametro e restituiscono rispettivamente la prima lettera, l'ultima lettera, e quelle in mezzo:

\begin{verbatim}
def prima(parola):
    return parola[0]

def ultima(parola):
    return parola[-1]

def mezzo(parola):
    return parola[1:-1]
\end{verbatim}
%
Vedremo meglio come funzionano nel Capitolo~\ref{strings}.

\begin{enumerate}

\item Scrivete queste funzioni in un file script {\tt palindromo.py}
e provatele. Cosa succede se chiamate {\tt mezzo} con una stringa di due lettere?  E di una lettera?  E con la stringa vuota, che si scrive \verb"''" e non contiene caratteri?

\item Scrivete una funzione di nome \verb"palindromo" che riceva una stringa come argomento e restituisca {\tt True} se è un palindromo e {\tt False} altrimenti. Ricordate che potete usare la funzione predefinita {\tt len} per controllare la lunghezza di una stringa.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/palindrome_soln.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Un numero, $a$, è una potenza di $b$ se è divisibile per $b$
e $a/b$ è una potenza di $b$.  Scrivete una funzione di nome
\verb"potenza" che prenda come parametri {\tt a} e {\tt b}
e che restituisca {\tt True} se {\tt a} è una potenza di {\tt b}.
Nota: dovete pensare bene al caso base.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{massimo comun divisore (MCD)}
\index{MCD (massimo comun divisore)}

Il massimo comun divisore (MCD) di due interi $a$ e $b$ è il numero intero più grande che divide entrambi senza dare resto.  

Un modo per trovare il MCD di due numeri si basa sull'osservazione che, se $r$ è il resto della divisione tra $a$ e $b$, allora $mcd(a,
b) = mcd(b, r)$.  Come caso base, possiamo usare $mcd(a, 0) = a$.

Scrivete una funzione di nome
\verb"mcd" che abbia come parametri {\tt a} e {\tt b}
e restituisca il loro massimo comun divisore.

Fonte: Questo esercizio è basato su un esempio in {\em Structure and Interpretation of Computer Programs} di Abelson e Sussman.

\end{exercise}


\chapter{Iterazione}

\section{Assegnazioni multiple}
\index{assegnazione}
\index{istruzione!assegnazione}
\index{assegnazione!multipla}

Vi sarete probabilmente già accorti che è possibile effettuare più assegnazioni ad una stessa variabile. Una nuova assegnazione fa sì che la variabile faccia riferimento ad un nuovo valore (cessando di riferirsi a quello vecchio).

\begin{verbatim}
bruce = 5
print bruce,
bruce = 7
print bruce
\end{verbatim}
%
L'output di questo programma è {\tt 5 7}, perché la prima volta che {\tt bruce} è stampato il suo valore è 5, la seconda volta è 7. La virgola dopo la prima istruzione {\tt print} evita il ritorno a capo dopo la stampa, cosicché entrambi i valori appaiono sulla stessa riga.
\index{ritorno a capo}

La Figura~\ref{fig.assign2} illustra il diagramma di stato per questa {\bf assegnazione multipla}. 
\index{diagramma!di stato}

Nel caso di assegnazioni multiple, è particolarmente importante distinguere tra operazioni di assegnazione e controlli di uguaglianza.
Dato che Python usa ({\tt =}) per le assegnazioni, potreste interpretare l'istruzione {\tt a = b} come un'espressione di uguaglianza, ma non lo è!
\index{uguaglianza e assegnazione}

In primo luogo l'equivalenza è simmetrica, cioè vale in entrambi i sensi, mentre l'assegnazione non lo è: in matematica se $a=7$ allora è anche $7=a$. Ma in Python l'istruzione {\tt a = 7} è valida mentre {\tt 7 = a} non lo è.

Inoltre, in matematica un'uguaglianza è o vera o falsa, e rimane tale: se ora $a=b$ allora $a$ sarà sempre uguale a $b$.
In Python, un'assegnazione può rendere due variabili temporaneamente uguali, ma non è affatto detto che l'uguaglianza permanga:

\begin{verbatim}
a = 5
b = a    # a e b ora sono uguali
a = 3    # a e b non sono piu' uguali
\end{verbatim}
%
La terza riga cambia il valore di {\tt a} ma non cambia quello di {\tt b}, quindi {\tt a} e {\tt b} non sono più uguali.

Anche se le assegnazioni multiple sono spesso utili, vanno usate con cautela. Se il valore di una variabile cambia di frequente, può rendere il codice difficile da leggere e correggere.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/assign2.pdf}}
\caption{Diagramma di stato.}
\label{fig.assign2}
\end{figure}



\section{Aggiornare le variabili}
\label{update}

\index{aggiornamento}
\index{variabile!aggiornamento}

Una delle forme più comuni di assegnazione multipla è l'{\bf aggiornamento},
dove il nuovo valore della variabile dipende da quello precedente.

\begin{verbatim}
x = x+1
\end{verbatim}
%
Questo vuol dire: ``prendi il valore attuale di {\tt x}, aggiungi uno, e aggiorna {\tt x} al nuovo valore.''

Se tentate di aggiornare una variabile inesistente, si verifica un errore perché Python valuta il lato destro prima di assegnare un valore a {\tt x}:

\begin{verbatim}
>>> x = x+1
NameError: name 'x' is not defined
\end{verbatim}
%
Prima di aggiornare una variabile occorre quindi {\bf inizializzarla},
di solito con una comune assegnazione:
\index{inizializzazione!prima di aggiornare}

\begin{verbatim}
>>> x = 0
>>> x = x+1
\end{verbatim}
%
L'aggiornamento di una variabile aggiungendo 1 è detto {\bf incremento};
sottrarre 1 è detto invece {\bf decremento}.
\index{incremento}
\index{decremento}




\section{L'istruzione {\tt while}}
\index{istruzione!while}
\index{ciclo!while}
\index{iterazione}

Spesso i computer sono usati per automatizzare dei compiti ripetitivi: ripetere operazioni identiche o simili un gran numero di volte senza fare errori, è qualcosa che i computer fanno molto bene e le persone piuttosto male.

Abbiamo visto due programmi, {\tt contoallarovescia} e \verb"stampa_n", che   usano la ricorsione per eseguire una ripetizione, che è anche chiamata {\bf
iterazione}. Dato che l'iterazione è un'operazione molto frequente, Python fornisce varie caratteristiche del linguaggio per renderla più semplice da implementare. Una è l'istruzione {\tt for}, che abbiamo già visto nel Paragrafo~\ref{repetition} e sulla quale torneremo.

Un'altra istruzione è {\tt while}. Ecco una variante di {\tt
contoallarovescia} che usa l'istruzione {\tt while}:

\begin{verbatim}
def contoallarovescia(n):
    while n > 0:
        print n
        n = n-1
    print 'Via!'
\end{verbatim}
%
Si può quasi leggere il programma con l'istruzione {\tt while} come fosse scritto in inglese: significa ``Finché (while) {\tt n} è maggiore di 0, stampa il valore di {\tt n} e poi decrementa {\tt n} di 1.  Quando arrivi a 0, stampa la stringa {\tt Via!}''
\index{flusso di esecuzione}

In modo più formale, ecco il flusso di esecuzione di un'istruzione {\tt while}:

\begin{enumerate}

\item Valuta la condizione, controllando se è vera ({\tt True}) o falsa ({\tt False}).

\item Se la condizione è falsa, esce dal ciclo {\tt while} e continua       l'esecuzione dalla prima istruzione che lo segue.

\item Se la condizione è vera, esegue tutte le istruzioni nel corpo del ciclo while e vi rimane, ritornando al punto 1.

\end{enumerate}

Questo tipo di flusso è chiamato {\bf ciclo } (in inglese {\em loop}), perché il terzo punto ritorna ciclicamente da capo. 
\index{condizione}
\index{ciclo}
\index{corpo}

Il corpo del ciclo deve cambiare il valore di una o più variabili in modo che la condizione possa prima o poi diventare falsa e fare in modo che il ciclo abbia termine. In caso contrario il ciclo si ripeterebbe continuamente, determinando un {\bf ciclo infinito}. Una fonte inesauribile di divertimento per gli informatici, è osservare che le istruzioni dello shampoo:
``lava, risciacqua, ripeti'' sono un ciclo infinito.

\index{ciclo!infinito}

Nel caso di {\tt contoallarovescia}, possiamo essere certi che il ciclo terminerà, visto che il valore di {\tt n} diventa via via più piccolo ad ogni ripetizione del ciclo stesso, fino a diventare, prima o poi, zero. In altri casi può non essere così facile stabilirlo:

\begin{verbatim}
def sequenza(n):
    while n != 1:
        print n,
        if n%2 == 0:        # n e' pari
            n = n/2
        else:               # n e' dispari
            n = n*3+1
\end{verbatim}
%
La condizione di questo ciclo è {\tt n != 1}, per cui il ciclo si ripeterà
fino a quando {\tt n} non sarà uguale a {\tt 1}, cosa che rende falsa la condizione.

Ad ogni ripetizione del ciclo, il programma stampa il valore di {\tt n} e poi controlla se è pari o dispari. Se è pari, {\tt n} viene diviso per 2. Se è dispari, {\tt n} è moltiplicato per 3 e al risultato viene aggiunto 1. Se per esempio il valore passato a {\tt sequenza} è 3, la sequenza risultante sarà 3, 10, 5, 16, 8, 4, 2, 1.

Dato che {\tt n} a volte sale e a volte scende, non c'è prova evidente che {\tt n} raggiungerà 1 in modo da terminare il ciclo. Per qualche particolare valore di {\tt n}, possiamo dimostrarlo: ad esempio, se il valore di partenza è una potenza di 2, il valore di {\tt n} sarà per forza un numero pari per ogni ciclo, fino a raggiungere 1. L'esempio precedente finisce proprio con una sequenza simile, a partire dal numero 16.
\index{congettura di Collatz}

La domanda difficile è se il programma giunga a termine per {\em qualsiasi valore positivo} di {\tt n}. Sinora, nessuno è riuscito a dimostrarlo {\em né} a smentirlo!  (Vedere \url{http://it.wikipedia.org/wiki/Congettura_di_Collatz}.)

\vspace{0.2in}
\begin{exercise}

Riscrivete la funzione \verb"stampa_n" del Paragrafo~\ref{recursion} usando l'iterazione al posto della ricorsione.

\end{exercise}


\section{{\tt break}}
\index{break, istruzione}
\index{istruzione!break}

Vi può capitare di poter stabilire il momento in cui è necessario terminare un ciclo solo mentre il flusso di esecuzione si trova nel bel mezzo del corpo. In questi casi potete usare l'istruzione {\tt break} per saltare fuori dal ciclo.

Per esempio, supponiamo che vogliate ricevere delle risposte dall'utente, fino a quando non viene digitata la parola {\tt fatto}.  Potete scrivere:

\begin{verbatim}
while True:
    riga = raw_input('> ')
    if riga == 'fatto':
        break
    print riga

print 'Fatto!'
\end{verbatim}
%
La condizione del ciclo è {\tt True}, che è sempre vera per definizione, quindi il ciclo è destinato a continuare, a meno che non incontri l'istruzione {\tt break}.

Ad ogni ripetizione, il programma mostra come prompt il simbolo {\tt >}.
Se l'utente scrive {\tt fatto}, l'istruzione {\tt break} interrompe il ciclo, altrimenti ripete quello che l'utente ha scritto e ritorna da capo. Ecco un esempio di esecuzione:

\begin{verbatim}
> non fatto
non fatto
> fatto
Fatto!
\end{verbatim}
%
Questo modo di scrivere i cicli {\tt while} è frequente, perché vi permette di controllare la condizione ovunque all'interno del ciclo (e non solo all'inizio) e di esprimere la condizione di stop in modo affermativo (``fermati quando succede questo'') piuttosto che negativo (``continua fino a quando non succede questo'').


\section{Radici quadrate}
\label{squareroot}
\index{radice quadrata}

Spesso si usano i cicli per calcolare risultati numerici, partendo da un valore approssimativo che viene migliorato iterativamente con approssimazioni successive.
\index{metodo di Newton}

Per esempio, un modo di calcolare le radici quadrate è il metodo di Newton. Supponiamo di voler calcolare la radice quadrata di $a$. A partire da una qualunque stima, $x$, possiamo calcolare una stima migliore con la formula seguente:

\[ y = \frac{x + a/x}{2} \]
%
Supponiamo per esempio che $a$ sia 4 e $x$ sia 3:

\begin{verbatim}
>>> a = 4.0
>>> x = 3.0
>>> y = (x + a/x) / 2
>>> print y
2.16666666667
\end{verbatim}
%
Che è più vicino al valore vero ($\sqrt{4} = 2$).  Se ripetiamo il procedimento usando la nuova stima, ci avviciniamo ulteriormente:

\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00641025641
\end{verbatim}
%
Dopo qualche ulteriore passaggio, la stima diventa quasi esatta:
\index{aggiornamento}

\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00001024003
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.00000000003
\end{verbatim}
%
In generale, non possiamo sapere {\em a priori} quanti passaggi ci vorranno per ottenere la risposta esatta, ma sapremo che ci saremo arrivati quando la stima non cambierà più:

\begin{verbatim}
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.0
>>> x = y
>>> y = (x + a/x) / 2
>>> print y
2.0
\end{verbatim}
%
Possiamo fermarci quando {\tt y == x}.  Ecco quindi un ciclo che parte da una stima iniziale, {\tt x}, e la migliora fino a quando non cambia più:

\begin{verbatim}
while True:
    print x
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
\end{verbatim}
%
Per la maggior parte dei valori di {\tt a}, questo codice funziona bene, ma in genere è pericoloso testare l'uguaglianza su valori decimali di tipo {\tt float},
perché sono solo approssimativamente esatti: la maggior parte dei numeri razionali come $1/3$, e irrazionali, come $\sqrt{2}$, non possono essere rappresentati in modo preciso con un {\tt float}.
\index{virgola mobile}
\index{epsilon}

Piuttosto di controllare se {\tt x} e {\tt y} sono identici, è meglio usare la funzione predefinita {\tt abs} per calcolare il valore assoluto della loro differenza:

\begin{verbatim}
    if abs(y-x) < epsilon:
        break
\end{verbatim}
%
Dove \verb"epsilon" è un valore molto piccolo, come {\tt 0.0000001}, che determina quando i due numeri confrontati sono abbastanza vicini da poter essere considerati praticamente uguali.

\vspace{0.2in}
\begin{exercise}

Incapsulate questo ciclo in una funzione di nome \verb"radice_quad"
che richieda {\tt a} come parametro, scelga un valore ragionevole di {\tt x}, e restituisca una stima della radice quadrata di {\tt a}.
\index{incapsulamento}

\end{exercise}


\section{Algoritmi}
\index{algoritmo}

Il metodo di Newton è un esempio di {\bf algoritmo}: è un'operazione meccanica per risolvere un tipo di problema (in questo caso, calcolare la radice quadrata).

Non è facile definire un algoritmo. Può essere utile iniziare a vedere cosa non è un algoritmo. Quando avete imparato a fare le moltiplicazioni dei numeri a una cifra, probabilmente avete imparato a memoria le tabelline, che significa ricordare 100 specifiche soluzioni. Una conoscenza di questo tipo non è algoritmica.

Ma se eravate dei bambini un po' pigri, probabilmente avete cercato di imparare qualche trucchetto. Per esempio, per trovare il prodotto tra $n$ e 9, si scrive $n-1$ come prima cifra e $10-n$ come seconda cifra. Questo trucco è una soluzione generica per moltiplicare per nove qualunque numero a una cifra. Questo è un algoritmo!
\index{addizione!con riporto}
\index{sottrazione!con prestito}

Similmente, le tecniche che avete imparato per l'addizione con riporto, la sottrazione con prestito e le divisioni lunghe sono tutte algoritmi. Una caratteristica degli algoritmi è che non richiedono intelligenza per essere eseguiti. Sono procedimenti meccanici in cui ad ogni passo ne segue un altro, secondo delle semplici regole.

A mio parere, è piuttosto imbarazzante che le persone impieghino tanto tempo a scuola per imparare ad eseguire degli algoritmi che, letteralmente, non richiedono alcuna intelligenza.

D'altra parte, la procedura di realizzazione di un algoritmo è interessante, intellettualmente stimolante, e una parte cruciale di quella che chiamiamo programmazione.

Alcune delle cose che le persone fanno in modo naturale senza difficoltà o senza nemmeno pensarci, sono le più difficili da esprimere con algoritmi. Capire il linguaggio naturale è un esempio calzante. Lo facciamo tutti, ma finora nessuno è stato in grado di spiegare {\em come} lo facciamo, almeno non sotto forma di un algoritmo.


\section{Debug}

Quando inizierete a scrivere programmi di grande dimensioni, aumenterà il tempo da dedicare al debug. Più codice significa più probabilità di commettere un errore e più posti in cui gli errori possono annidarsi.
\index{debug!binario}

Un metodo per ridurre il tempo di debug è il ``debug binario''.
Se nel vostro programma ci sono 100 righe e le controllate una ad una, ci vorranno 100 passaggi.

Provate invece a dividere il problema in due. Cercate verso la metà del programma un valore intermedio che potete controllare. Aggiungete un'istruzione {\tt print} (o qualcos'altro di controllabile) ed eseguite il programma.

Se il controllo nel punto mediano non è corretto, deve esserci un problema nella prima metà del programma. Se invece è corretto, l'errore sarà nella seconda metà.

Per ogni controllo eseguito in questa maniera, dimezzate le righe da controllare. Dopo 6 passaggi (che sono meno di 100), dovreste teoricamente arrivare a una o due righe di codice.

In pratica, non è sempre chiaro quale sia la ``metà del programma'' e non è sempre possibile controllare. Non ha neanche molto senso contare le righe e trovare la metà esatta. Meglio considerare i punti del programma dove è più probabile che vi siano errori e quelli dove è facile posizionare dei controlli. Quindi, scegliere un punto dove stimate che le probabilità che l'errore sia prima o dopo quel punto siano circa le stesse.




\section{Glossario}

\begin{description}

\item[assegnazione multipla:] Assegnazione alla stessa variabile di valori diversi nel corso del programma.
\index{assegnazione!multipla}

\item[aggiornamento:] Assegnazione in cui il nuovo valore della variabile dipende da quello precedente.
\index{aggiornamento}

\item[inizializzazione:] Assegnazione che fornisce un valore iniziale ad una variabile da aggiornare successivamente.
\index{inizializzazione!variabile}

\item[incremento:] Aggiornamento che aumenta il valore di una variabile (spesso di una unità).
\index{incremento}

\item[decremento:] Aggiornamento che riduce il valore di una variabile.
\index{decremento}

\item[iterazione:] Ripetizione di una serie di istruzioni utilizzando una funzione ricorsiva oppure un ciclo.
\index{iterazione}

\item[ciclo infinito:] Ciclo nel quale la condizione che ne determina la fine non è mai soddisfatta.
\index{ciclo!infinito}

\end{description}


\section{Esercizi}

\begin{exercise}
\index{algoritmo!radice quadrata}

Per verificare l'algoritmo di calcolo della radice quadrata illustrato in questo capitolo, potete confrontarlo con la funzione {\tt math.sqrt} . Scrivete una funzione di nome \verb"test_radice_quad" che stampi una tabella come questa:

\begin{verbatim}
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0

\end{verbatim}
%
La prima colonna è un numero, $a$; la seconda è la radice quadrata di $a$ calcolata con la funzione del Paragrafo~\ref{squareroot}; la terza è quella calcolata con {\tt math.sqrt}; la quarta è il valore assoluto della differenza tra le due stime.
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{eval, funzione}
\index{funzione!eval}

La funzione predefinita {\tt eval} valuta un'espressione sotto forma di stringa, usando l'interprete Python. Ad esempio:

\begin{verbatim}
>>> eval('1 + 2 * 3')
7
>>> import math
>>> eval('math.sqrt(5)')
2.2360679774997898
>>> eval('type(math.pi)')
<type 'float'>
\end{verbatim}
%
Scrivete una funzione di nome \verb"eval_ciclo" che chieda iterativamente all'utente di inserire un dato, prenda il dato inserito e lo valuti con {\tt eval}, infine visualizzi il risultato.

Deve continuare fino a quando l'utente non scrive \verb"'fatto'", e poi restituire il valore dell'ultima espressione che ha valutato.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{Ramanujan, Srinivasa}

Il matematico Srinivasa Ramanujan scoprì una serie infinita che può essere usata per generare un'approssimazione di $1 / \pi$:
\index{pi}

\[ \frac{1}{\pi} = \frac{2\sqrt{2}}{9801} 
\sum^\infty_{k=0} \frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}} \]

Scrivete una funzione di nome \verb"stima_pi" che utilizzi questa formula per calcolare e restituire una stima di $\pi$.  Deve usare un ciclo {\tt while}
per calcolare gli elementi della sommatoria, fino a quando l'ultimo termine è più piccolo di {\tt 1e-15} (che è la notazione di Python per $10^{-15}$).
Controllate il risultato confrontandolo con {\tt math.pi}.

Soluzione: \url{http://thinkpython.com/code/pi.py}.

\end{exercise}


\chapter{Stringhe}
\label{strings}


\section{Una stringa è una sequenza}

\index{sequenza}
\index{carattere}
\index{parentesi quadre, operatore}
\index{operatore!parentesi quadre}
Una stringa è una {\bf sequenza} di caratteri. Potete accedere ai singoli caratteri usando gli operatori parentesi quadre:

\begin{verbatim}
>>> frutto = 'banana'
>>> lettera = frutto[1]
\end{verbatim}
%
La seconda istruzione seleziona il carattere numero 1 della variabile {\tt
frutto} e lo assegna a {\tt lettera}.  
\index{indice}

L'espressione all'interno delle parentesi quadre è chiamato {\bf indice}.  
L'indice indica (di qui il nome) quale carattere della sequenza desiderate estrarre.

Ma il risultato potrebbe lasciarvi perplessi:

\begin{verbatim}
>>> print lettera
a
\end{verbatim}
%
Per la maggior parte delle persone, la prima lettera di \verb"'banana'" è {\tt b}, non
{\tt a}.  Ma per gli informatici, premesso che l'indice è la posizione a partire dall'inizio della stringa, la posizione della prima lettera è considerata la numero zero, non uno.

\begin{verbatim}
>>> lettera = frutto[0]
>>> print lettera
b
\end{verbatim}
%
Quindi {\tt b} è la ``zero-esima'' lettera di \verb"'banana'", {\tt a}
è la prima lettera (``1-esima''), e {\tt n} è la seconda (``2-esima'')
lettera.
\index{indice!inizio da zero}
\index{zero, indice iniziale}

Potete usare come indice qualsiasi espressione, compresi variabili e operatori, ma il valore risultante deve essere un intero. Altrimenti succede questo:
\index{indice}
\index{eccezione!TypeError}
\index{TypeError}

\begin{verbatim}
>>> lettera = frutto[1.5]
TypeError: string indices must be integers, not float
\end{verbatim}
%

\section{{\tt len}}
\index{len, funzione}
\index{funzione!len}

{\tt len} è una funzione predefinita che restituisce il numero di caratteri di una stringa:

\begin{verbatim}
>>> frutto = 'banana'
>>> len(frutto)
6
\end{verbatim}
%
Per estrarre l'ultimo carattere di una stringa, potreste pensare di scrivere qualcosa del genere:
\index{eccezione!IndexError}
\index{IndexError}

\begin{verbatim}
>>> lunghezza = len(frutto)
>>> ultimo = frutto[lunghezza]
IndexError: string index out of range
\end{verbatim}
%
La ragione dell'{\tt IndexError} è che non c'è nessuna lettera in {\tt
'banana'} con indice 6. Siccome partiamo a contare da zero, le sei lettere sono numerate da 0 a 5. Per estrarre l'ultimo carattere, dobbiamo perciò sottrarre 1 da {\tt lunghezza}:

\begin{verbatim}
>>> ultimo = frutto[lunghezza-1]
>>> print ultimo
a
\end{verbatim}
%
In alternativa, possiamo usare utilmente gli indici negativi, che contano a ritroso dalla fine della stringa: l'espressione {\tt frutto[-1]} ricava l'ultimo carattere della stringa, {\tt frutto[-2]} il penultimo carattere, e così via.
\index{indice!negativo}


\section{Attraversamento con un ciclo {\tt for}}
\label{for}
\index{attraversamento}
\index{ciclo!attraversamento}
\index{for, ciclo}
\index{ciclo!for}
\index{istruzione!for}

Molti tipi di calcolo comportano l'elaborazione di una stringa, un carattere per volta. Spesso iniziano dal primo carattere, selezionano un carattere per volta, eseguono una certa operazione e continuano fino al completamento della stringa. Questo tipo di elaborazione è definita {\bf attraversamento}. Un modo per scrivere un attraversamento è quello di usare un ciclo {\tt while}:

\begin{verbatim}
indice = 0
while indice < len(frutto):
    lettera = frutto[indice]
    print lettera
    indice = indice + 1
\end{verbatim}
%
Questo ciclo attraversa tutta la stringa e ne mostra una lettera alla volta,    una per riga. La condizione del ciclo è {\tt indice < len(frutto)}, pertanto   quando {\tt indice} è uguale alla lunghezza della stringa la condizione diventa falsa, il corpo del ciclo non viene più eseguito ed il ciclo termina. L'ultimo carattere cui si accede è quello con indice {\tt len(frutto)-1}, che è l'ultimo carattere della stringa.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione che riceva una stringa come argomento e ne stampi i singoli caratteri, uno per riga, partendo dall'ultimo a ritroso.

\end{exercise}

Un altro modo di scrivere un attraversamento è usare un ciclo {\tt for}:

\begin{verbatim}
for lettera in frutto:
    print lettera
\end{verbatim}
%
Ad ogni ciclo, il successivo carattere della stringa viene assegnato alla variabile {\tt lettera}. Il ciclo continua finché non rimangono più caratteri da analizzare.
\index{concatenamento}
\index{alfabetico}
\index{McCloskey, Robert}

L'esempio seguente mostra come usare il concatenamento (addizione di stringhe) e un ciclo {\tt for} per generare una serie alfabetica, cioè una lista di valori in cui gli elementi appaiono in ordine alfabetico. Per esempio, nel libro {\em Make Way for Ducklings} di Robert McCloskey, ci sono degli anatroccoli che si chiamano Jack, Kack, Lack, Mack, Nack, Ouack, Pack, e Quack.  Questo ciclo restituisce i nomi in ordine:

\begin{verbatim}
prefissi = 'JKLMNOPQ'
suffisso = 'ack'

for lettera in prefissi:
    print lettera + suffisso
\end{verbatim}
%
Il risultato del programma è:

\begin{verbatim}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{verbatim}
%
È evidente che non è del tutto giusto, dato che ``Ouack'' e ``Quack'' sono scritti in modo errato.

\vspace{0.2in}
\begin{exercise}

Modificate il programma per correggere questo errore.

\end{exercise}



\section{Slicing}
\label{slice}
\index{slice, operatore}
\index{operatore!slice}
\index{indice!slicing}
\index{stringa!slicing}
\index{slicing!stringa}

Un segmento o porzione di stringa è chiamato {\bf slice}. L'operazione di selezione di una porzione di stringa è simile alla selezione di un carattere, ed è detta {\bf slicing}:

\begin{verbatim}
>>> s = 'Monty Python'
>>> print s[0:5]
Monty
>>> print s[6:12]
Python
\end{verbatim}
%
L'operatore {\tt [n:m]} restituisce la porzione di stringa nell'intervallo compreso tra l'``n-esimo'' carattere incluso fino all'``m-esimo'' escluso. Questo comportamento è poco intuitivo, e per tenerlo a mente può essere d'aiuto immaginare gli indici puntare {\em tra} i caratteri, come spiegato nella Figura~\ref{fig.banana}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/banana.pdf}}
\caption{Indici di slicing.}
\label{fig.banana}
\end{figure}


Se non è specificato il primo indice (quello prima dei due punti :), la porzione parte dall'inizio della stringa. Se manca il secondo indice, la porzione arriva fino in fondo alla stringa:

\begin{verbatim}
>>> frutto = 'banana'
>>> frutto[:3]
'ban'
>>> frutto[3:]
'ana'
\end{verbatim}
%
Se il primo indice è maggiore o uguale al secondo, il risultato è una {\bf stringa vuota}, rappresentata da due apici consecutivi.
\index{apici}

\begin{verbatim}
>>> frutto = 'banana'
>>> frutto[3:3]
''
\end{verbatim}
%
Una stringa vuota non contiene caratteri e ha lunghezza 0, ma a parte questo è a tutti gli effetti una stringa come le altre.

\vspace{0.2in}
\begin{exercise}

Data una stringa di nome {\tt frutto}, che cosa significa {\tt frutto[:]}?
\index{copia!slicing}
\index{slicing!copia}

\end{exercise}


\section{Le stringhe sono immutabili}
\index{mutabilità}
\index{immutabilità}
\index{stringa!immutabile}

Potreste pensare di utilizzare l'operatore {\tt []} sul lato sinistro di un'assegnazione per cambiare un carattere all'interno di una stringa. Per esempio così:
\index{TypeError}
\index{eccezione!TypeError}

\begin{verbatim}
>>> saluto = 'Ciao, mondo!'
>>> saluto[0] = 'M'
TypeError: 'str' object does not support item assignment
\end{verbatim}
%
L'``oggetto'' ({\em object}) in questo caso è la stringa, e l'``elemento'' ({\em item}) è il carattere che avete tentato di assegnare. Per ora, consideriamo un {\bf oggetto} come la stessa cosa di un valore, ma più avanti puntualizzeremo meglio questa definizione. Un {\bf elemento} è uno dei valori in una sequenza.
\index{oggetto}
\index{elemento!assegnazione}
\index{assegnazione!elemento}
\index{immutabilità}

La ragione dell'errore è che le stringhe sono {\bf immutabili}, in altre parole, non potete cambiare una stringa esistente. La miglior cosa da fare è creare una nuova stringa, variante dell'originale:

\begin{verbatim}
>>> saluto = 'Ciao, mondo!'
>>> nuovo_saluto = 'M' + saluto[1:]
>>> print nuovo_saluto
Miao, mondo!
\end{verbatim}
%
Questo esempio concatena una nuova prima lettera con la restante porzione di {\tt saluto}. Non ha alcun effetto sulla stringa di origine, che resta invariata.
\index{concatenamento}


\section{Ricerca}
\label{find}

Cosa fa la funzione seguente?
\index{trova, funzione}
\index{funzione!trova}

\begin{verbatim}
def trova(parola, lettera):
    indice = 0
    while indice < len(parola):
        if parola[indice] == lettera:
            return indice
        indice = indice + 1
    return -1
\end{verbatim}
%
In un certo senso, questa funzione {\tt trova} è l'opposto dell'operatore {\tt []}.
Invece di prendere un indice ed estrarre il carattere corrispondente, prende un carattere e trova l'indice in corrispondenza del quale appare il carattere. Se non trova il carattere indicato nella parola, la funzione restituisce {\tt
-1}.

Per la prima volta incontriamo l'istruzione {\tt return} all'interno di un ciclo. Se {\tt parola[indice] == lettera}, la funzione interrompe il ciclo e ritorna immediatamente, restituendo {\tt indice}. 

Se il carattere non compare nella stringa data, il programma termina il ciclo  normalmente e restituisce {\tt -1}.

Questo schema di calcolo---attraversare una sequenza e ritornare quando trova quello che sta cercando---è chiamato {\bf ricerca}.
\index{attraversamento}
\index{ricerca!schema di}
\index{schema!di ricerca}

\vspace{0.2in}
\begin{exercise}

Modificate la funzione {\tt trova} in modo che richieda un terzo parametro, che rappresenta la posizione da cui si deve cominciare la ricerca all'interno della stringa {\tt parola}.

\end{exercise}


\section{Cicli e contatori}
\label{counter}
\index{contatore}
\index{contatori e cicli}
\index{cicli e contatori}
\index{ciclo!con stringhe}

Il programma seguente conta il numero di volte in cui la lettera {\tt a}
compare in una stringa:

\begin{verbatim}
parola = 'banana'
conta = 0
for lettera in parola:
    if lettera == 'a':
        conta = conta + 1
print conta
\end{verbatim}
%
Si tratta di un altro schema di calcolo chiamato  {\bf contatore}.  La variabile {\tt conta} è inizializzata a 0, quindi incrementata di uno per ogni volta che viene trovata una {\tt a}.
Al termine del ciclo, {\tt conta} contiene il risultato: il numero totale di lettere {\tt a} nella stringa.

\vspace{0.2in}
\begin{exercise}
\index{incapsulamento}

Incapsulate questo codice in una funzione di nome {\tt conta}, e generalizzatela in modo che accetti come argomenti sia la stringa che la lettera da cercare.
\end{exercise}

\vspace{0.2in}
\begin{exercise}

Riscrivete questa funzione in modo che, invece di attraversare completamente la stringa, faccia uso della versione a tre parametri di {\tt trova}, vista nel precedente paragrafo.

\end{exercise}


\section{Metodi delle stringhe}

Un {\bf metodo} è simile a una funzione---riceve argomenti e restituisce un valore---ma la sintassi è diversa. Ad esempio, il metodo {\tt upper} prende una stringa e crea una nuova stringa di tutte lettere maiuscole.
\index{metodo}
\index{stringa!metodi}

Al posto della sintassi della funzione, {\tt upper(parola)}, usa la sintassi del metodo, {\tt parola.upper()}.
\index{notazione a punto}

\begin{verbatim}
>>> parola = 'banana'
>>> nuova_parola = parola.upper()
>>> print nuova_parola
BANANA
\end{verbatim}
%
Questa forma di notazione a punto, in inglese {\em dot notation}, specifica il nome del metodo, {\tt upper}, e il nome della stringa a cui va applicato il metodo, {\tt
parola}. Le parentesi vuote indicano che il metodo non ha argomenti.
\index{parentesi!vuote}

La chiamata di un metodo è detta {\bf invocazione}; nel nostro caso, diciamo che stiamo invocando {\tt upper} su {\tt parola}.
\index{invocazione}

Visto che ci siamo, esiste un metodo delle stringhe chiamato {\tt find} che è molto simile alla funzione che abbiamo scritto prima:

\begin{verbatim}
>>> parola = 'banana'
>>> indice = parola.find('a')
>>> print indice
1
\end{verbatim}
%
In questo esempio, abbiamo invocato {\tt find} su {\tt parola} e abbiamo passato come parametro la lettera che stiamo cercando.

In realtà, il metodo {\tt find} è più generale della nostra funzione: può ricercare anche sottostringhe e non solo singoli caratteri:

\begin{verbatim}
>>> parola.find('na')
2
\end{verbatim}
%
Può inoltre ricevere come secondo argomento l'indice da cui partire:
\index{argomento!opzionale}

\begin{verbatim}
>>> parola.find('na', 3)
4
\end{verbatim}
%
E come terzo argomento l'indice in corrispondenza del quale fermarsi:

\begin{verbatim}
>>> nome = 'bob'
>>> nome.find('b', 1, 2)
-1
\end{verbatim}
%
In quest'ultimo caso la ricerca fallisce, perché {\tt b} non è compreso nell'intervallo da {\tt 1} a {\tt 2} ({\tt
2} si considera escluso).

\vspace{0.2in}
\begin{exercise}
\index{count, metodo}
\index{metodo!count}

Esiste un metodo delle stringhe di nome {\tt count} che è simile alla funzione dell'esercizio precedente. Leggete la documentazione del metodo e scrivete un'invocazione che conti il numero di {\tt a} in \verb"'banana'".
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{stringa!metodi}
\index{metodi delle stringhe}

Leggete la documentazione dei metodi delle stringhe sul sito
\url{http://docs.python.org/2/library/stdtypes.html#string-methods}.
Fate degli esperimenti con alcuni metodi per assicurarvi di avere capito come funzionano. {\tt strip} e {\tt replace} sono particolarmente utili.

La documentazione utilizza una sintassi che può risultare poco chiara. Per esempio, in \verb"find(sub[, start[, end]])", le parentesi quadre indicano dei parametri opzionali (non vanno digitate). Quindi {\tt sub} è obbligatorio, ma
{\tt start} è opzionale, e se indicate {\tt start}, allora {\tt end} è a sua volta opzionale.
\end{exercise}


\section{L'operatore {\tt in}}
\label{inboth}
\index{in, operatore}
\index{operatore!in}
\index{booleano, operatore}
\index{operatore!booleano}

La parola {\tt in} è un operatore booleano che confronta due stringhe e restituisce {\tt True} se la prima è una sottostringa della seconda:

\begin{verbatim}
>>> 'a' in 'banana'
True
>>> 'seme' in 'banana'
False
\end{verbatim}
%
Ad esempio, la funzione che segue stampa tutte le lettere di {\tt parola1} che compaiono anche in {\tt parola2}:

\begin{verbatim}
def in_entrambe(parola1, parola2):
    for lettera in parola1:
        if lettera in parola2:
            print lettera
\end{verbatim}
%
Con qualche nome di variabile scelto bene, Python a volte si legge quasi come fosse un misto di inglese e italiano: ``per (ogni) lettera in parola1, se (la) lettera (è) in parola2, stampa (la) lettera.''

Ecco cosa succede se paragonate carote e patate:

\begin{verbatim}
>>> in_entrambe('carote', 'patate')
a
t
e
\end{verbatim}
%

\section{Confronto di stringhe}
\index{stringa!confronto}
\index{confronto!stringa}

Gli operatori di confronto funzionano anche sulle stringhe. Per vedere se
due stringhe sono uguali:

\begin{verbatim}
if parola == 'banana':
    print 'Tutto ok, banane.'
\end{verbatim}
%
Altri operatori di confronto sono utili per mettere le parole in ordine alfabetico:

\begin{verbatim}
if parola < 'banana':
    print 'La tua parola,' + parola + ', viene prima di banana.'
elif parola > 'banana':
    print 'La tua parola,' + parola + ', viene dopo banana.'
else:
    print 'Tutto ok, banane.'
\end{verbatim}
%
Attenzione che Python non gestisce le parole maiuscole e minuscole come siamo abituati: in un confronto, le lettere maiuscole vengono sempre prima di tutte le minuscole, così che:

\begin{verbatim}
La tua parola, Papaya, viene prima di banana.
\end{verbatim}
%
Un modo pratico per aggirare il problema è quello di convertire le stringhe ad un formato standard (tutte maiuscole o tutte minuscole) prima di effettuare il confronto.


\section{Debug}
\index{debug}
\index{attraversamento}

Quando usate gli indici per l'attraversamento dei valori di una sequenza, non è facile determinare bene l'inizio e la fine. Ecco una funzione che vorrebbe confrontare due parole e restituire {\tt True} quando una parola è scritta al contrario dell'altra, ma contiene due errori:

\begin{verbatim}
def al_contrario(parola1, parola2):
    if len(parola1) != len(parola2):
        return False
    
    i = 0
    j = len(parola2)

    while j > 0:
        if parola1[i] != parola2[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{verbatim}
%
La prima istruzione {\tt if} controlla se le parole sono della stessa lunghezza. Se non è così, possiamo restituire immediatamente {\tt False}, altrimenti, per il resto della funzione, possiamo presupporre che le parole hanno pari lunghezza. È un altro esempio di condizione di guardia, vista nel Paragrafo~\ref{guardian}.
\index{guardia, condizione di}
\index{schema!guardiani}
\index{indice}

{\tt i} e {\tt j} sono indici: {\tt i} attraversa {\tt parola1}
in avanti, mentre {\tt j} attraversa {\tt parola2} a ritroso. Se troviamo due lettere che non coincidono, possiamo restituire subito {\tt False} Se continuiamo per tutto il ciclo e tutte le lettere coincidono, il valore di ritorno è {\tt True}.

Se proviamo la funzione con i valori ``pots'' e ``stop'', ci aspetteremmo di ricevere di ritorno {\tt True}, invece risulta un IndexError:
\index{IndexError}
\index{eccezione!IndexError}

\begin{verbatim}
>>> al_contrario('pots', 'stop')
...
  File "reverse.py", line 15, in al_contrario
    if parola1[i] != parola2[j]:
IndexError: string index out of range
\end{verbatim}
%
Per fare il debug, la mia prima mossa è di stampare il valore degli indici appena prima della riga dove è comparso l'errore.

\begin{verbatim}
    while j > 0:
        print i, j        # stampare qui
        
        if parola1[i] != parola2[j]:
            return False
        i = i+1
        j = j-1
\end{verbatim}
%
Ora, eseguendo di nuovo il programma, ho qualche informazione in più:

\begin{verbatim}
>>> al_contrario('pots', 'stop')
0 4
...
IndexError: string index out of range
\end{verbatim}
%
Alla prima esecuzione del ciclo, il valore di {\tt j} è 4,
che è fuori intervallo della stringa \verb"'pots'".
Infatti l'indice dell'ultimo carattere è 3, e il valore iniziale di {\tt j} va corretto in {\tt len(parola2)-1}.
\index{semantica, errore di}
\index{errore!di semantica}

Se correggo l'errore e rieseguo ancora il programma:

\begin{verbatim}
>>> al_contrario('pots', 'stop')
0 3
1 2
2 1
True
\end{verbatim}
%
Stavolta il risultato è giusto, ma pare che il ciclo sia stato eseguito solo per tre volte, il che è sospetto. Per avere un'idea di cosa stia succedendo, è utile disegnare un diagramma di stato. Durante la prima iterazione, il frame di \verb"al_contrario" è illustrato in Figura~\ref{fig.state4}.
\index{diagramma!di stato}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/state4.pdf}}
\caption{Diagramma di Stato.}
\label{fig.state4}
\end{figure}


Ho fatto una piccola eccezione, disponendo le variabili nel frame e aggiungendo delle linee tratteggiate per evidenziare che i valori di {\tt i} e
{\tt j} indicano i caratteri in {\tt parola1} e {\tt parola2}.

\vspace{0.2in}
\begin{exercise}
\label{isreverse}

Partendo da questo diagramma, sviluppate il programma su carta cambiando i valori di {\tt i} e {\tt j} ad ogni iterazione. Trovate e correggete il secondo errore in questa funzione.

\end{exercise}



\section{Glossario}

\begin{description}

\item[oggetto:] Qualcosa a cui una variabile può fare riferimento. Per ora, potete utilizzare ``oggetto'' e ``valore'' indifferentemente.
\index{oggetto}

\item[sequenza:] Un insieme ordinato di valori, ovvero un gruppo di valori in cui ciascuno è identificato da un numero intero.
\index{sequenza}

\item[elemento:] Uno dei valori di una sequenza.
\index{elemento}

\item[indice:] Un valore intero usato per selezionare un elemento di una sequenza, come un carattere in una stringa.
\index{indice}

\item[slice:] Porzione di una stringa identificata tramite un intervallo di indici.
\index{slice}

\item[stringa vuota:] Una stringa priva di caratteri e di lunghezza 0, rappresentata da due apici o virgolette successivi.
\index{stringa!vuota}

\item[immutabile:] Detto di una sequenza i cui elementi non possono essere assegnati.
\index{immutabilità}

\item[attraversare:] Iterare attraverso gli elementi di una sequenza, effettuando su ciascuno un'operazione simile.
\index{attraversamento}

\item[ricerca:] Schema di attraversamento che si ferma quando trova ciò che si sta cercando.
\index{ricerca!schema di}
\index{schema!di ricerca}

\item[contatore:] Variabile utilizzata per contare qualcosa, solitamente inizializzata a zero e poi incrementata.
\index{contatore}

\item[metodo:] Funzione associata ad un oggetto e invocata utilizzando la notazione a punto.
\index{metodo}

\item[invocazione:] Istruzione che chiama un metodo.
\index{invocazione}

\end{description}


\section{Esercizi}

\begin{exercise}
\index{step, ampiezza}
\index{slice, operatore}
\index{operatore!slice}

Nello slicing, si può specificare un terzo indice che stabilisce lo {\em step} o ``passo'', cioè il numero di elementi da saltare tra un carattere estratto e il successivo. Uno step di 2 significa estrarre un carattere ogni 2 (uno sì, uno no), 3 significa uno ogni 3 (uno sì, due no), ecc.

\begin{verbatim}
>>> frutto = 'banana'
>>> frutto[0:5:2]
'bnn'
\end{verbatim}

Uno step di -1 fa scorrere all'indietro nella parola, per cui lo slice \verb"[::-1]" genera una stringa scritta al contrario.
\index{palindromo}

Usate questo costrutto per scrivere una variante di una sola riga della funzione \verb"palindromo" dell'Esercizio~\ref{palindrome}.
\end{exercise}

\vspace{0.2in}
\begin{exercise}

Tutte le funzioni che seguono {\em dovrebbero} controllare se una stringa contiene almeno una lettera minuscola, ma qualcuna di esse è sbagliata. Per ogni funzione, descrivete cosa fa in realtà (supponendo che il parametro sia una stringa).

\begin{verbatim}
def una_minuscola1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def una_minuscola2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def una_minuscola3(s):
    for c in s:
        flag = c.islower()
    return flag

def una_minuscola4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def una_minuscola5(s):
    for c in s:
        if not c.islower():
            return False
    return True
\end{verbatim}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{rotazione di lettere}


\label{exrotate}
ROT13 è un metodo di criptazione debole che consiste nel ``ruotare'' ogni lettera di una parola di 13 posti seguendo la sequenza alfabetica, ricominciando da capo quando necessario. Ad esempio 'A' ruotata di 3 posti diventa 'D', 'Z' ruotata di 1 posto diventa 'A'.
Scrivete una funzione di nome \verb"ruota_parola" che richieda una stringa e un intero come parametri, e che restituisca una nuova stringa che contiene le lettere della stringa di partenza ruotate della quantità indicata.
Per esempio, ``cheer'' ruotata di 7 dà ``jolly'' e ``melon'' ruotata di -10
dà ``cubed''.  

%For example ``sleep''
%rotated by 9 is ``bunny'' and ``latex'' rotated by 7 is ``shale''.

Potete usare le funzioni predefinite {\tt ord}, che converte un carattere in un codice numerico, e {\tt chr}, che converte i codici numerici in caratteri.

Su Internet, talvolta, vengono codificate in ROT13 delle barzellette potenzialmente offensive. Se non siete suscettibili, cercatene qualcuna e decodificatela. Soluzione: \url{http://thinkpython.com/code/rotate.py}.

\end{exercise}


\chapter{Esercitazione: Giochi con le parole}

\section{Leggere elenchi di parole}
\label{wordlist}

Per gli esercizi di questo capitolo ci serve un elenco di parole in inglese. Ci sono parecchi elenchi di parole disponibili sul Web, ma uno dei più adatti ai nostri scopi è quello raccolto da Grady Ward, di pubblico dominio, parte del progetto lessicale Moby (vedere \url{http://wikipedia.org/wiki/Moby_Project}). È un elenco di 113.809 parole ufficiali per cruciverba, cioè parole che sono considerate valide in un gioco di parole crociate o altri giochi con le parole. Nella raccolta Moby il nome del file è {\tt 113809of.fic}; potete anche scaricare una copia chiamata più semplicemente {\tt words.txt}, dal sito
\url{http://thinkpython.com/code/words.txt}.
\index{Moby Project}
\index{cruciverba}

Il file è in testo semplice, e potete aprirlo con qualsiasi editor di testo, ma anche leggerlo con Python: la funzione predefinita {\tt open} richiede come parametro il nome di un file e restituisce un {\bf oggetto file} che potete utilizzare per questo scopo.
\index{open, funzione}
\index{funzione!open}
\index{testo!semplice}
\index{oggetto!file}

\begin{verbatim}
>>> fin = open('words.txt')
>>> print fin
<open file 'words.txt', mode 'r' at 0xb7f4b380>
\end{verbatim}
%
{\tt fin} è un nome comunemente usato per un oggetto file usato per operazioni di input. La modalità \verb"'r'" indica che il file è aperto in lettura (per contro, \verb"'w'" sta per scrittura).
\index{readline, metodo}
\index{metodo!readline}

L'oggetto file comprende alcuni metodi di lettura, come {\tt readline}, che legge i caratteri da un file finché non giunge ad un ritorno a capo, e restituisce il risultato sotto forma di stringa:

\begin{verbatim}
>>> fin.readline()
'aa\r\n'
\end{verbatim}
%
La prima parola di questa speciale lista è ``aa'', che è un tipo di lava vulcanica. La sequenza \verb"\r\n" rappresenta due caratteri spaziatori, un ritorno di carrello e un a capo, che separano questa parola dalla successiva.

L'oggetto file tiene traccia del punto in cui si trova all'interno del file, così quando chiamate nuovamente {\tt readline}, ottenete la parola successiva:

\begin{verbatim}
>>> fin.readline()
'aah\r\n'
\end{verbatim}
%
La parola successiva è ``aah'', che è perfettamente valida per cui non fate quella faccia! Oppure, se gli spaziatori vi danno fastidio, potete sbarazzarvene con il metodo delle stringhe {\tt strip}:
\index{strip, metodo}
\index{metodo!strip}

\begin{verbatim}
>>> riga = fin.readline()
>>> parola = riga.strip()
>>> print parola
aahed
\end{verbatim}
%
Potete anche usare un oggetto file all'interno di un ciclo {\tt for}.
Questo programma legge {\tt words.txt} e stampa ogni parola, una per riga:
\index{open, funzione}
\index{funzione!open}

\begin{verbatim}
fin = open('words.txt')
for riga in fin:
    parola = riga.strip()
    print parola
\end{verbatim}
%

\vspace{0.2in}
\begin{exercise}

Scrivete un programma che legga {\tt words.txt} e stampi solo le parole con più di 20 caratteri (caratteri spaziatori esclusi)
\index{spaziatore}

\end{exercise}


\section{Esercizi}

Le soluzioni a questi esercizi sono discusse nel prossimo paragrafo. Tentate almeno di risolverli prima di leggerle.

\vspace{0.2in}
\begin{exercise}

Nel 1939, Ernest Vincent Wright pubblicò una novella di 50.000 parole dal titolo
{\em Gadsby} che non conteneva alcuna lettera ``e''.  Dato che la ``e'' è la lettera più comune nella lingua inglese, non è una cosa facile.

Infatti, in italiano ho mai composto un piccolo brano siffatto: sono pochi i vocaboli privi tali da riuscirci; finora non ho trovato alcun modo, ma conto di arrivarci in alcuni giorni, pur con un po' di difficoltà! Ma ora, basta così.

Scrivete una funzione di nome \verb"niente_e" che restituisca {\tt True} se una data parola non contiene la lettera ``e''.

Modificate il programma del paragrafo precedente in modo che stampi solo le parole dell'elenco prive della lettera ``e'', e ne calcoli la percentuale sul totale delle parole.
\index{lipogramma}

\end{exercise}

\vspace{0.2in}
\begin{exercise} 

Scrivete una funzione di nome {\tt evita} che richieda una parola e una stringa di lettere vietate, e restituisca {\tt True} se la parola non contiene alcuna lettera vietata.

Modificate poi il programma in modo che chieda all'utente di inserire una stringa di lettere vietate, e poi stampi il numero di parole che non ne contengono alcuna. Riuscite a trovare una combinazione di 5 lettere vietate che escluda il più piccolo numero di parole?

\end{exercise}


\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"usa_solo" che richieda una parola e una stringa di lettere, e che restituisca {\tt True} se la parola contiene solo le lettere indicate. Riuscite a comporre una frase in inglese usando solo le lettere
{\tt acefhlo}?  Diversa da ``Hoe alfalfa''?

\end{exercise}

\vspace{0.2in}
\begin{exercise} 

Scrivete una funzione di nome \verb"usa_tutte" che richieda una parola e una stringa di lettere richieste e che restituisca {\tt True} se la parola utilizza tutte le lettere richieste almeno una volta. Quante parole ci sono che usano tutte le vocali {\tt aeiou}?  E {\tt aeiouy}?

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"alfabetica" che restituisca 
{\tt True} se le lettere di una parola compaiono in ordine alfabetico (le doppie valgono). Quante parole ``alfabetiche'' ci sono?
\index{alfabetico}

\end{exercise}


%\begin{exercise}
%\label{palindrome}
%A palindrome is a word that reads the same
%forward and backward, like ``rotator'' and ``noon.''
%Write a boolean function named \verb"is_palindrome" that
%takes a string as a parameter and returns {\tt True} if it is
%a palindrome.

%Modify your program from the previous section to print all
%of the palindromes in the word list and then print the total
%number of palindromes.
%\end{exercise}



\section{Ricerca}
\index{ricerca!schema di}
\index{schema!di ricerca}

Tutti gli esercizi del paragrafo precedente hanno qualcosa in comune; possono essere risolti con lo schema di ricerca che abbiamo visto nel Paragrafo~\ref{find}.  L'esempio più semplice è:

\begin{verbatim}
def niente_e(parola):
    for lettera in parola:
        if lettera == 'e':
            return False
    return True
\end{verbatim}
%
Il ciclo {\tt for} attraversa i caratteri in {\tt parola}.  Se trova la lettera  ``e'', può immediatamente restituire {\tt False}; altrimenti deve esaminare la lettera seguente. Se il ciclo termina normalmente, vuol dire che non è stata trovata alcuna ``e'', per cui il risultato è {\tt True}.
\index{attraversamento}

% Removing this because we haven't seen the in operator yet.
%\index{in operator}
%\index{operator!in}

%You could write this function more concisely using the {\tt in}
%operator, but I started with this version because it 
%demonstrates the logic of the search pattern.
\index{generalizzazione}

{\tt evita} è una versione più generale di \verb"niente_e", ma la struttura è la stessa:

\begin{verbatim}
def evita(parola, vietate):
    for lettera in parola:
        if lettera in vietate:
            return False
    return True
\end{verbatim}
%
Possiamo restituire {\tt False} appena troviamo una delle lettere vietate; se arriviamo alla fine del ciclo, viene restituito {\tt True}.

\verb"usa_solo" è simile, solo che il senso della condizione è invertito:

\begin{verbatim}
def usa_solo(parola, valide):
    for lettera in parola: 
        if lettera not in valide:
            return False
    return True
\end{verbatim}
%
Invece di un elenco di lettere vietate, ne abbiamo uno di lettere disponibili. Se in {\tt parola} troviamo una lettera che non è una di quelle {\tt valide}, possiamo restituire {\tt False}.

\verb"usa_tutte" è ancora simile, solo che rovesciamo il ruolo della parola e della stringa di lettere:

\begin{verbatim}
def usa_tutte(parola, richieste):
    for lettera in richieste: 
        if lettera not in parola:
            return False
    return True
\end{verbatim}
%
Invece di attraversare le lettere in {\tt parola}, il ciclo attraversa le lettere richieste. Se una qualsiasi delle lettere richieste non compare nella parola, restituiamo {\tt False}.
\index{attraversamento}

Ma se avete pensato davvero da informatici, avrete riconosciuto che \verb"usa_tutte" era un'istanza di un problema già risolto in precedenza, e avrete scritto:

\begin{verbatim}
def usa_tutte(parola, richieste):
    return usa_solo(richieste, parola)
\end{verbatim}
%
Ecco un esempio di metodo di sviluppo di un programma chiamato {\bf riconoscimento del problema}, che significa che avete riconosciuto che il problema su cui state lavorando è un'istanza di un problema già risolto in precedenza, e quindi potete applicare una soluzione che avevate già sviluppato.
\index{riconoscimento del problema}
\index{tecnica di sviluppo!riconoscimento del problema}


\section{Cicli con gli indici}
\index{ciclo!con indici}
\index{indice!nei cicli}

Ho scritto le funzioni del paragrafo precedente utilizzando dei cicli {\tt for}
perché avevo bisogno solo dei caratteri nelle stringhe e non dovevo fare nulla con gli indici.


Per \verb"alfabetica" dobbiamo comparare delle lettere adiacenti, che è un po' laborioso con un ciclo {\tt for}:

\begin{verbatim}
def alfabetica(parola):
    precedente = parola[0]
    for c in parola:
        if c < precedente:
            return False
        precedente = c
    return True
\end{verbatim}


Un'alternativa è usare la ricorsione:

\begin{verbatim}
def alfabetica(parola):
    if len(parola) <= 1:
        return True
    if parola[0] > parola[1]:
        return False
    return alfabetica(parola[1:])
\end{verbatim}

E un'altra opzione è usare un ciclo {\tt while}:

\begin{verbatim}
def alfabetica(parola):
    i = 0
    while i < len(parola)-1:
        if parola[i+1] < parola[i]:
            return False
        i = i+1
    return True
\end{verbatim}
%
Il ciclo comincia da {\tt i=0} e finisce a {\tt i=len(parola)-1}.  Ogni volta che viene eseguito, il ciclo confronta l' $i$-esimo carattere (consideratelo come il carattere attuale) con l' $i+1$-esimo carattere (consideratelo come quello successivo).

Se il carattere successivo è minore di quello attuale (cioè viene alfabeticamente prima), allora abbiamo scoperto un'interruzione nella serie alfabetica e la funzione restituisce {\tt False}.

Se arriviamo a fine ciclo senza trovare difetti, la parola ha superato il test. Per convincervi che il ciclo è terminato correttamente, prendete un esempio come \verb"'flossy'".  La lunghezza della parola è 6, quindi l'ultima ripetizione del ciclo si ha quando {\tt i} è 4, che è l'indice del penultimo carattere. Nell'ultima iterazione, il penultimo carattere è comparato all'ultimo, che è quello che vogliamo.
\index{palindromo}

Ecco una variante di \verb"palindromo" (vedere l'Esercizio~\ref{palindrome}) che usa due indici; uno parte dall'inizio e aumenta, uno parte dalla fine e diminuisce.

\begin{verbatim}
def palindromo(parola):
    i = 0
    j = len(parola)-1

    while i<j:
        if parola[i] != parola[j]:
            return False
        i = i+1
        j = j-1

    return True
\end{verbatim}

Oppure, se vi siete accorti che questa è un'istanza di un problema risolto precedentemente, potreste avere scritto:

\begin{verbatim}
def palindromo(parola):
    return al_contrario(parola, parola)
\end{verbatim}
\index{riconoscimento del problema}
\index{tecnica di sviluppo!riconoscimento del problema}

Si suppone che abbiate svolto l'Esercizio~\ref{isreverse}.


\section{Debug}
\index{debug}
\index{test!difficoltà}
\index{programma!test}

Collaudare i programmi non è facile. Le funzioni di questo capitolo sono relativamente agevoli da provare, perché potete facilmente controllare il risultato da voi. Nonostante ciò, scegliere un insieme di parole che riescano a escludere ogni possibile errore è un qualcosa tra il difficile e l'impossibile.

Prendiamo ad esempio \verb"niente_e". Ci sono due evidenti casi da controllare: le parole che hanno una o più 'e' devono dare come risultato {\tt False};
quelle che invece non hanno 'e', {\tt True}. E fin qui, in un caso o nell'altro, non c'è niente di particolarmente difficile.

Per ciascun caso ci sono alcuni sottocasi meno ovvi. Tra le parole che contengono ``e'', dovreste provare parole che iniziano con ``e'', finiscono con ``e'', hanno ``e'' da qualche parte nel mezzo della parola. Dovreste poi provare parole lunghe, parole corte e parole cortissime. Nello specifico, la stringa vuota è un esempio di {\bf caso particolare}, che è uno dei casi meno ovvi dove si nascondono spesso gli errori.
\index{caso!particolare}

Oltre che con i casi da voi ideati, sarebbe anche bene fare un test del vostro programma con un elenco di parole come {\tt words.txt}.  Scansionando l'output potreste intercettare qualche errore, ma attenzione: può trattarsi di un certo tipo di errore (parole che non dovrebbero essere incluse ma invece ci sono) e non di un altro (parole che dovrebbero essere incluse ma non ci sono).

In linea generale, fare dei test può aiutarvi a trovare i bug, ma non è facile generare un buon insieme di casi di prova, e anche se ci riuscite non potete essere certi che il vostro programma sia corretto al 100 per cento.
\index{test!e assenza di bug}

Secondo un leggendario informatico:

\begin{quote}
Il collaudo di un programma può essere usato per dimostrare la presenza di bug, ma mai per dimostrarne l'assenza!

--- Edsger W. Dijkstra
\end{quote}
\index{Dijkstra, Edsger}


\section{Glossario}

\begin{description}

\item[oggetto file:] Un valore che rappresenta un file aperto.
\index{oggetto!file}

\item[riconoscimento del problema:] Modo di risolvere un problema esprimendolo come un'istanza di un problema precedentemente risolto.
\index{riconoscimento del problema}

\item[caso particolare:] un caso atipico o non ovvio (e con meno probabilità di essere gestito correttamente) che viene testato.
\index{caso!particolare}

\end{description}


\section{Esercizi}

\begin{exercise}
\index{Car Talk}
\index{quesito}
\index{lettere!doppie}

Questa domanda deriva da un quesito trasmesso nel programma radiofonico {\em Car Talk} 
(\url{http://www.cartalk.com/content/puzzlers}):

\begin{quote}
``Ditemi una parola inglese con tre lettere doppie consecutive. Vi dò un paio di parole che andrebbero quasi bene, ma non del tutto. Per esempio la parola ``committee'', c-o-m-m-i-t-t-e-e. Sarebbe buona se non fosse per la ``i'' che si insinua in mezzo. O ``Mississippi'': M-i-s-s-i-s-s-i-p-p-i. Togliendo le ``i'' andrebbe bene. Ma esiste una parola che ha tre coppie di lettere uguali consecutive, e per quanto ne so dovrebbe essere l'unica. Magari ce ne sono altre 500, ma me ne viene in mente solo una. Qual è?''
\end{quote}

Scrivete un programma per trovare la parola.  Soluzione: \url{http://thinkpython.com/code/cartalk1.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
Ecco un altro quesito di {\em Car Talk}
(\url{http://www.cartalk.com/content/puzzlers}):
\index{Car Talk}
\index{Puzzler}
\index{contachilometri}
\index{palindromo}

\begin{quote}
``L'altro giorno stavo guidando in autostrada e guardai il mio contachilometri. È a sei cifre, come la maggior parte dei contachilometri, e mostra solo chilometri interi. Se la mia macchina, per esempio, avesse 300.000 km, vedrei 3-0-0-0-0-0.''

``Quello che vidi quel giorno era interessante. Notai che le ultime 4 cifre erano palindrome, cioè si potevano leggere in modo identico sia da sinistra a destra che viceversa. Per esempio 5-4-4-5 è palindromo, per cui il contachilometri avrebbe potuto essere 3-1-5-4-4-5''

``Un chilometro dopo, gli ultimi 5 numeri erano palindromi. Per esempio potrei aver letto 3-6-5-4-5-6. Un altro chilometro dopo, le 4 cifre di mezzo erano palindrome. E tenetevi forte: un altro chilometro dopo tutte e 6 erano palindrome!''

``La domanda è: quanto segnava il contachilometri la prima volta che guardai?''
\end{quote}

Scrivete un programma in Python che controlli tutti i numeri a sei cifre e visualizzi i numeri che soddisfano le condizioni sopra indicate. Soluzione: \url{http://thinkpython.com/code/cartalk2.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
Ecco un altro quesito di {\em Car Talk} (\url{http://www.cartalk.com/content/puzzlers}) che potete risolvere con una ricerca :
\index{Car Talk}
\index{Puzzler}
\index{palindromo}

\begin{quote}
``Di recente ho fatto visita a mia madre, e ci siamo accorti che le due cifre che compongono la mia età, invertite, formano la sua. Per esempio, se lei avesse 73 anni, io ne avrei 37. Ci siamo domandati quanto spesso succedesse questo negli anni, ma poi abbiamo divagato su altri discorsi senza darci una risposta.''

``Tornato a casa, ho calcolato che le cifre delle nostre età sono state sinora invertibili per sei volte. Ho calcolato anche che se fossimo fortunati succederebbe ancora tra pochi anni, e se fossimo veramente fortunati succederebbe un'altra volta ancora. In altre parole, potrebbe succedere per 8 volte in tutto. La domanda è: quanti anni ho io in questo momento?''

\end{quote}

Scrivete un programma in Python che ricerchi la soluzione a questo quesito. Suggerimento: potrebbe esservi utile il metodo delle stringhe {\tt zfill}.

Soluzione: \url{http://thinkpython.com/code/cartalk3.py}.

\end{exercise}



\chapter{Liste}

\section{Una lista è una sequenza}
\label{sequence}

Come una stringa, una {\bf lista} è una sequenza di valori. Mentre in una stringa i valori sono dei caratteri, in una lista possono essere di qualsiasi tipo. I valori che fanno parte della lista sono chiamati {\bf elementi}.
\index{lista}
\index{tipo!list}
\index{elemento}
\index{sequenza}

Ci sono parecchi modi di creare una nuova lista, e quello più semplice
   è racchiudere i suoi elementi tra parentesi quadrate (\verb"[" e \verb"]"):

\begin{verbatim}
[10, 20, 30, 40]
['Primi piatti', 'Secondi piatti', 'Dessert']
\end{verbatim}
%
Il primo esempio è una lista di quattro interi, il secondo una lista
   di tre stringhe. Gli elementi di una stessa lista non devono
   necessariamente essere tutti dello stesso tipo. La lista che segue
   contiene una stringa, un numero in virgola mobile, un intero e (meraviglia!) un'altra lista:

\begin{verbatim}
['spam', 2.0, 5, [10, 20]]
\end{verbatim}
%
Una lista all'interno di un'altra lista è detta lista {\bf nidificata}.
\index{lista!nidificata}

Una lista che non contiene elementi è detta lista vuota; potete crearne una scrivendo le due parentesi quadre vuote, \verb"[]".
\index{lista!vuota}

Avrete già intuito che potete assegnare i valori della lista a variabili:

\begin{verbatim}
>>> formaggi = ['Cheddar', 'Edam', 'Gouda']
>>> numeri = [17, 123]
>>> vuota = []
>>> print formaggi, numeri, vuota
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
\end{verbatim}
%
\index{assegnazione}


\section{Le liste sono mutabili}
\label{mutable}
\index{lista!elemento}
\index{accesso}
\index{indice}
\index{parentesi quadre, operatore}
\index{operatore!parentesi quadre}

La sintassi per l'accesso agli elementi di una lista è la stessa che abbiamo già visto per i caratteri di una stringa: le parentesi quadre, con un'espressione tra parentesi che specifica l'indice dell'elemento (non dimenticate che gli indici partono da 0!):

\begin{verbatim}
>>> print formaggi[0]
Cheddar
\end{verbatim}
%
A differenza delle stringhe, le liste sono mutabili. Quando l'operatore parentesi quadre compare sul lato sinistro di un'assegnazione, identifica l'elemento della lista che sarà riassegnato:
\index{mutabilità}

\begin{verbatim}
>>> numeri = [17, 123]
>>> numeri[1] = 5
>>> print numeri
[17, 5]
\end{verbatim}
%
L'elemento di indice 1 di {\tt numeri}, che era 123, ora è 5
\index{indice!inizio da zero}
\index{zero, indice iniziale}

Potete pensare a una lista come una relazione di corrispondenza tra indici ed elementi. Questa relazione è chiamata {\bf mappatura}; ogni indice corrisponde a uno degli elementi. La Figura~\ref{fig.liststate} mostra il diagramma di {\tt
formaggi}, {\tt numeri} e {\tt vuota}:
\index{diagramma!di stato}
\index{mappatura}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/liststate.pdf}}
\caption{Diagramma di stato}
\label{fig.liststate}
\end{figure}

Le liste sono rappresentate da riquadri con la parola ``list'' all'esterno e i suoi elementi all'interno.  {\tt formaggi} si riferisce a una lista con tre elementi di indice 0, 1 e 2.
{\tt numeri} contiene due elementi; il diagramma mostra che il valore del secondo elemento è stato riassegnato da 123 a 5. {\tt vuota} si riferisce a una lista senza elementi.
\index{elemento, assegnazione}
\index{assegnazione!elemento}

Gli indici di una lista funzionano nello stesso modo già visto per le stringhe:

\begin{itemize}

\item Come indice possiamo usare qualsiasi espressione che produca un intero.

\item Se tentate di leggere o modificare un elemento che non esiste, ottenete
   un messaggio d'errore {\tt IndexError}.
\index{eccezione!IndexError}
\index{IndexError}

\item Se un indice ha valore negativo, il conteggio parte dalla fine della
   lista.

\end{itemize}
\index{lista!indice}
\index{lista!appartenenza}
\index{appartenenza!lista}
\index{in, operatore}
\index{operatore!in}

Anche l'operatore {\tt in} funziona con le liste:

\begin{verbatim}
>>> formaggi = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in formaggi
True
>>> 'Brie' in formaggi
False
\end{verbatim}


\section{Attraversamento di una lista}
\index{lista!attraversamento}
\index{attraversamento!lista}
\index{for, ciclo}
\index{ciclo!for}
\index{istruzione!for}

Il modo più frequente di attraversare gli elementi di una lista è un ciclo {\tt for}. La sintassi è la stessa delle stringhe:

\begin{verbatim}
for formaggio in formaggi:
    print formaggio
\end{verbatim}
%
Questo metodo funziona bene per leggere gli elementi di una lista, ma se volete scrivere o aggiornare degli elementi vi servono gli indici. Un modo per farlo è usare una combinazione delle funzioni {\tt range} e {\tt len}:
\index{ciclo!con indici}
\index{indice!nei cicli}

\begin{verbatim}
for i in range(len(numeri)):
    numeri[i] = numeri[i] * 2
\end{verbatim}
%
Questo ciclo attraversa la lista e aggiorna tutti gli elementi. {\tt len}
restituisce il numero di elementi della lista.  {\tt range} restituisce una lista di indici da 0 a $n-1$, dove $n$ è la lunghezza della lista. Ad ogni ripetizione del ciclo, {\tt i} prende l'indice dell'elemento successivo. L'istruzione di assegnazione nel corpo usa {\tt i} per leggere il vecchio valore dell'elemento e assegnare quello nuovo.
\index{elemento!aggiornamento}
\index{aggiornamento!elemento}

Un ciclo {\tt for} su una lista vuota non esegue mai il corpo:

\begin{verbatim}
for x in []:
    print 'Questo non succede mai.'
\end{verbatim}
%
Sebbene una lista possa contenerne un'altra, quella nidificata conta sempre come un singolo elemento. La lunghezza di questa lista è quattro:
\index{nidificata, lista}
\index{lista!nidificata}

\begin{verbatim}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
\end{verbatim}



\section{Operazioni sulle liste}
\index{lista!operazione}

L'operatore {\tt +} concatena delle liste:
\index{concatenamento!lista}
\index{lista!concatenamento}

\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
\end{verbatim}
%
Similmente, l'operatore {\tt *} ripete una lista per un dato numero di volte:
\index{ripetizione!lista}
\index{lista!ripetizione}

\begin{verbatim}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{verbatim}
%
Il primo esempio ripete {\tt [0]} per quattro volte. Il secondo ripete la lista {\tt [1, 2, 3]} per tre volte.


\section{Slicing delle liste}
\index{slice, operatore}
\index{operatore!slice}
\index{indice!slicing}
\index{lista!slicing}
\index{slicing!lista}

Anche l'operazione di slicing funziona sulle liste:

\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
\end{verbatim}
%
Se omettete il primo indice, lo slicing comincia dall'inizio, mentre se manca il secondo, termina alla fine. Se vengono omessi entrambi, lo slicing è una copia dell'intera lista.
\index{lista!copia}
\index{slicing!copia}
\index{copia!slicing}

\begin{verbatim}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{verbatim}
%
Dato che le liste sono mutabili, spesso è utile farne una copia prima di eseguire operazioni che le pieghino, le stirino o le mutilino.
\index{mutabilità}

Un'operatore di slice sul lato sinistro di un'assegnazione, permette di aggiornare più elementi.
\index{slicing!aggiornamento}
\index{aggiornamento!slicing}

\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print t
['a', 'x', 'y', 'd', 'e', 'f']
\end{verbatim}
%

% You can add elements to a list by squeezing them into an empty
% slice:

% % \begin{verbatim}
% >>> t = ['a', 'd', 'e', 'f']
% >>> t[1:1] = ['b', 'c']
% >>> print t
% ['a', 'b', 'c', 'd', 'e', 'f']
% \end{verbatim}
% \afterverb
%
% And you can remove elements from a list by assigning the empty list to
% them:

% % \begin{verbatim}
% >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
% >>> t[1:3] = []
% >>> print t
% ['a', 'd', 'e', 'f']
% \end{verbatim}
% \afterverb
%
% But both of those operations can be expressed more clearly
% with list methods.


\section{Metodi delle liste}
\index{lista!metodi}
\index{metodi delle liste}

Python fornisce dei metodi che operano sulle liste. Ad esempio,
{\tt append} aggiunge un nuovo elemento in coda alla lista:
\index{append, metodo}
\index{metodo!append}

\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print t
['a', 'b', 'c', 'd']
\end{verbatim}
%
{\tt extend} prende una lista come argomento e accoda tutti i suoi elementi:
\index{extend, metodo}
\index{metodo!extend}

\begin{verbatim}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print t1
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
%
Questo esempio lascia immutata la lista {\tt t2}.

{\tt sort} dispone gli elementi della lista in ordine crescente:
\index{sort, metodo}
\index{metodo!sort}

\begin{verbatim}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print t
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
%
I metodi delle liste sono tutti vuoti: modificano la lista e restituiscono {\tt None}. Se scrivete accidentalmente  {\tt t = t.sort()}, il risultato vi deluderà.
\index{metodo!vuoto}
\index{None, valore speciale}
\index{valore speciale!None}


\section{Mappare, filtrare e ridurre}

Per sommare tutti i numeri in una lista, potete usare un ciclo come questo:

% see add.py

\begin{verbatim}
def somma_tutti(t):
    totale = 0
    for x in t:
        totale += x
    return totale
\end{verbatim}
%
{\tt totale} è inizializzato a 0. Ad ogni ripetizione del ciclo,
{\tt x} prende un elemento dalla lista. L'operatore {\tt +=} è una forma abbreviata per aggiornare una variabile. Questa
{\bf istruzione di assegnazione potenziata}:
\index{aggiornamento!operatore di}
\index{operatore!di aggiornamento}
\index{assegnazione!potenziata}
\index{potenziata, assegnazione}

\begin{verbatim}
    totale += x
\end{verbatim}
%
è equivalente a:

\begin{verbatim}
    totale = totale + x
\end{verbatim}
%
Man mano che il ciclo lavora, {\tt totale} accumula la somma degli elementi; una variabile usata in questo modo è detta anche {\bf accumulatore}.
\index{accumulatore!somma}

Sommare gli elementi di una lista è un'operazione talmente comune che Python contiene una apposita funzione predefinita, {\tt sum}:

\begin{verbatim}
>>> t = [1, 2, 3]
>>> sum(t)
6
\end{verbatim}
%
Una simile operazione che compatta una sequenza di elementi in un singolo valore, è chiamata {\bf riduzione}.
\index{riduzione, schema}
\index{schema!riduzione}
\index{attraversamento}

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione chiamata \verb"somma_nidificata" che richieda come parametro una lista nidificata di numeri interi e sommi gli elementi di tutte le liste nidificate.

\end{exercise}

Talvolta è necessario attraversare una lista per costruirne contemporaneamente un'altra. Per esempio, la funzione seguente prende una lista di stringhe e restituisce una nuova lista che contiene le stesse stringhe in lettere maiuscole:

\begin{verbatim}
def tutte_maiuscole(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
\end{verbatim}
%
{\tt res} è inizializzata come una lista vuota; ad ogni ripetizione del ciclo viene accodato un elemento. Pertanto {\tt res} è una sorta di accumulatore.
\index{accumulatore!lista}

Un'operazione come quella di \verb"tutte_maiuscole" è chiamata anche {\bf
mappa}: applica una funzione (in questo caso il metodo {\tt
capitalize}) su ciascun elemento di una sequenza.
\index{mappa, schema}
\index{schema!mappa}
\index{filtro, schema}
\index{schema!filtro}

\vspace{0.2in}
\begin{exercise}

Usate \verb"tutte_maiuscole" per scrivere una funzione di nome \verb"maiuscole_nidif" che prenda una lista nidificata di stringhe e restituisca una nuova lista nidificata di stringhe, in lettere maiuscole.

\end{exercise}

Un'altra operazione frequente è la selezione di alcuni elementi di una lista per formare una sottolista. Per esempio, la seguente funzione prende una lista di stringhe e restituisce una lista che contiene solo le stringhe scritte in lettere maiuscole:

\begin{verbatim}
def solo_maiuscole(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
\end{verbatim}
%
{\tt isupper} è un metodo delle stringhe che restituisce {\tt True} se la stringa contiene solo lettere maiuscole.

Un'operazione come quella di \verb"solo_maiuscole" è chiamata {\bf filtro} perché seleziona solo alcuni elementi, filtrando gli altri.

La maggior parte delle operazioni sulle liste possono essere espresse come combinazioni di mappa, filtro e riduzione. Poiché queste operazioni sono frequenti, Python contiene alcune caratteristiche del linguaggio per supportarle, come la funzione predefinita {\tt map} e un costrutto chiamato {\em list comprehension}.
\index{list comprehension}

\vspace{0.2in}
\begin{exercise}
\label{cumulative}
\index{cumulativa, somma}

Scrivete una funzione che prenda una lista di numeri e restituisca le somme cumulative. Ovvero, una nuova lista dove l'$i$-esimo elemento è la somma dei primi $i+1$ elementi della lista di origine. Per esempio, la somma cumulativa di {\tt [1, 2, 3]} è {\tt [1, 3, 6]}. 
\end{exercise}


\section{Cancellare elementi}
\index{elemento!cancellazione}
\index{cancellare, elementi di lista}

Ci sono alcuni modi per cancellare elementi da una lista. Se conoscete l'indice dell'elemento desiderato, potete usare
{\tt pop}:
\index{pop, metodo}
\index{metodo!pop}

\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print t
['a', 'c']
>>> print x
b
\end{verbatim}
%
{\tt pop} modifica la lista e restituisce l'elemento che è stato rimosso. Se omettete l'indice, il metodo cancella e restituisce l'ultimo elemento della lista.

Se non vi serve il valore rimosso, potete usare l'operatore {\tt del}:
\index{del, operatore}
\index{operatore!del}

\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print t
['a', 'c']
\end{verbatim}
%

Se conoscete l'elemento da rimuovere ma non il suo indice, potete usare {\tt remove}:
\index{remove, metodo}
\index{metodo!remove}

\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print t
['a', 'c']
\end{verbatim}
%
Il valore di ritorno di {\tt remove} è {\tt None}.
\index{None, valore speciale}
\index{valore speciale!None}

Per cancellare più di un elemento potete usare {\tt del} con uno slice:

\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print t
['a', 'f']
\end{verbatim}
%
Come di consueto, lo slicing seleziona gli elementi fino al secondo indice escluso.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"mediani" che prenda una lista e restituisca una nuova lista che contenga tutti gli elementi esclusi il primo e l'ultimo.  Quindi \verb"mediani([1,2,3,4])" deve restituire \verb"[2,3]".

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"tronca" che prenda una lista, la modifichi togliendo il primo e l'ultimo elemento, e restituisca {\tt None}.

\end{exercise}


\section{Liste e stringhe}
\index{lista}
\index{stringa}
\index{sequenza}

Una stringa è una sequenza di caratteri e una lista è una sequenza di valori, ma una lista di caratteri non è la stessa cosa di una stringa. Per convertire una stringa in una lista di caratteri, potete usare {\tt list}:
\index{list, funzione}
\index{funzione!list}

\begin{verbatim}
>>> s = 'spam'
>>> t = list(s)
>>> print t
['s', 'p', 'a', 'm']
\end{verbatim}
%
Poiché {\tt list} è una funzione predefinita, va evitato di chiamare una variabile con questo nome. Personalmente evito anche {\tt l} perché somiglia troppo a {\tt 1}.  Ecco perché di solito uso {\tt t}.

La funzione {\tt list} separa una stringa in singole lettere. Se invece volete spezzare una stringa nelle singole parole, usate il metodo {\tt split}:
\index{split, metodo}
\index{metodo!split}

\begin{verbatim}
>>> s = 'profonda nostalgia dei fiordi'
>>> t = s.split()
>>> print t
['profonda', 'nostalgia', 'dei', 'fiordi']
\end{verbatim}
%
Un argomento opzionale chiamato {\bf delimitatore} specifica quale carattere va considerato come separatore delle parole. L'esempio che segue usa il trattino come separatore:
\index{argomento!opzionale}
\index{delimitatore}

\begin{verbatim}
>>> s = 'spam-spam-spam'
>>> delimita = '-'
>>> s.split(delimita)
['spam', 'spam', 'spam']
\end{verbatim}
%
{\tt join} è l'inverso di {\tt split}: prende una lista di stringhe e concatena gli elementi.  {\tt join} è un metodo delle stringhe, quindi lo dovete invocare per mezzo del delimitatore e passare la lista come parametro:
\index{join, metodo}
\index{metodo!join}
\index{concatenamento}

\begin{verbatim}
>>> t = ['profonda', 'nostalgia', 'dei', 'fiordi']
>>> delimita = ' '
>>> delimita.join(t)
'profonda nostalgia dei fiordi'
\end{verbatim}
%
In questo caso il delimitatore è uno spazio, quindi
{\tt join} aggiunge uno spazio tra le parole. Per concatenare delle stringhe senza spazi, basta usare come delimitatore la stringa vuota \verb"''".
\index{stringa!vuota}


\section{Oggetti e valori}
\index{oggetto}
\index{valore}

Se eseguiamo queste istruzioni di assegnazione:

\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
%
Sappiamo che {\tt a} e {\tt b} si riferiscono a una stringa, ma non sappiamo se si riferiscono alla {\em stessa} stringa.
Ci sono due possibili stati, illustrati in Figura~\ref{fig.list1}.
\index{alias}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/list1.pdf}}
\caption{Diagramma di stato.}
\label{fig.list1}
\end{figure}


In un caso, {\tt a} e {\tt b} si riferiscono a due oggetti diversi che hanno lo stesso valore. Nel secondo, si riferiscono allo stesso oggetto.
\index{is, operatore}
\index{operatore!is}

Per controllare se due variabili si riferiscono allo stesso oggetto, potete usare l'operatore {\tt is}.

\begin{verbatim}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
\end{verbatim}
%
In questo esempio, Python ha creato un unico oggetto stringa, e sia {\tt a} che {\tt b} fanno riferimento ad esso.

Ma se create due liste, ottenete due oggetti distinti:

\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
\end{verbatim}
%
Quindi il diagramma di stato somiglia a quello di Figura~\ref{fig.list2}.
\index{diagramma!di stato}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/list2.pdf}}
\caption{Diagramma di stato.}
\label{fig.list2}
\end{figure}


In quest'ultimo caso si dice che le due liste sono {\bf equivalenti},
perché contengono gli stessi elementi, ma non {\bf identiche}, perché non sono lo stesso oggetto.
Se due oggetti sono identici, sono anche equivalenti, ma se sono equivalenti non sono necessariamente identici.
\index{equivalente}
\index{identità}

Fino ad ora abbiamo usato ``oggetto'' e ``valore'' indifferentemente, ma è più preciso dire che un oggetto ha un valore.  Se eseguite {\tt [1,2,3]}, ottenete un oggetto lista il cui valore è una sequenza di interi. Se un'altra lista contiene gli stessi elementi, diciamo che ha lo stesso valore, ma non che è lo stesso oggetto.
\index{oggetto}
\index{valore}


\section{Alias}
\index{alias}
\index{riferimento!alias}

Se {\tt a} si riferisce a un oggetto e assegnate {\tt b = a},
allora entrambe le variabili si riferiscono allo stesso oggetto.

\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
\end{verbatim}
%
Il diagramma di stato è quello in Figura~\ref{fig.list3}.
\index{diagramma!di stato}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/list3.pdf}}
\caption{Diagramma di stato.}
\label{fig.list3}
\end{figure}

L'associazione tra una variabile e un oggetto è chiamato {\bf
riferimento}. In questo esempio ci sono due riferimenti allo stesso oggetto.
\index{riferimento}

Un oggetto che ha più di un riferimento ha anche più di un nome, e diciamo quindi che l'oggetto ha degli {\bf alias}.
\index{mutabilità}

Se l'oggetto munito di alias è mutabile, i cambiamenti provocati da un alias si riflettono anche sull'altro:

\begin{verbatim}
>>> b[0] = 17
>>> print a
[17, 2, 3]
\end{verbatim}
%
Sebbene questo comportamento possa essere utile, è anche fonte di errori. In genere è più sicuro evitare gli alias quando si sta lavorando con oggetti mutabili.
\index{immutabilità}

Per gli oggetti immutabili come le stringhe, gli alias non sono un problema. In questo esempio:

\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
%
Non fa quasi mai differenza se {\tt a} e {\tt b} facciano riferimento alla stressa stringa o meno.


\section{Liste come argomenti}
\label{list.arguments}
\index{lista!come argomento}
\index{argomento}
\index{argomento!lista}
\index{riferimento}
\index{parametro}

Quando passate una lista a una funzione, questa riceve un riferimento alla lista. Se la funzione modifica una lista, suo parametro, il chiamante vede la modifica. Per esempio, \verb"decapita" rimuove il primo elemento di una lista:

\begin{verbatim}
def decapita(t):
    del t[0]
\end{verbatim}
%
Vediamo come si usa:

\begin{verbatim}
>>> lettere = ['a', 'b', 'c']
>>> decapita(lettere)
>>> print lettere
['b', 'c']
\end{verbatim}
%
Il parametro {\tt t} e la variabile {\tt lettere} sono due alias dello stesso oggetto. Il diagramma di stack è riportato in Figura~\ref{fig.stack5}.
\index{diagramma!di stack}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/stack5.pdf}}
\caption{Diagramma di stack.}
\label{fig.stack5}
\end{figure}


Dato che la lista è condivisa da due frame, la disegno in mezzo.

È importante distinguere tra operazioni che modificano le liste e operazioni che creano nuove liste. Per esempio il metodo {\tt append} modifica una lista, ma l'operatore {\tt +} ne crea una nuova:
\index{append, metodo}
\index{metodo!append}
\index{lista!concatenamento}
\index{concatenamento!lista}

\begin{verbatim}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print t1
[1, 2, 3]
>>> print t2
None

>>> t3 = t1 + [4]
>>> print t3
[1, 2, 3, 4]
\end{verbatim}

Questa differenza è importante quando scrivete delle funzioni che devono modificare delle liste. Per esempio, questa funzione
{\em non} cancella il primo elemento della lista:

\begin{verbatim}
def non_decapita(t):
    t = t[1:]              # SBAGLIATO!
\end{verbatim}

L'operatore di slicing crea una nuova lista e l'assegnazione fa in modo che {\tt t} si riferisca ad essa, ma nulla di tutto ciò ha effetti sulla lista passata come argomento.
\index{slice, operatore}
\index{operatore!slice}

Un'alternativa valida è scrivere una funzione che crea e restituisce una nuova lista. Per esempio, {\tt ritaglia} restituisce tutti gli elementi di una lista tranne il primo:

\begin{verbatim}
def ritaglia(t):
    return t[1:]
\end{verbatim}
%
Questa funzione lascia intatta la lista di origine. Ecco come si usa:

\begin{verbatim}
>>> lettere = ['a', 'b', 'c']
>>> resto = ritaglia(lettere)
>>> print resto
['b', 'c']
\end{verbatim}



\section{Debug}
\index{debug}

Un uso poco accurato delle liste (e degli altri oggetti mutabili) può portare a lunghe ore di debug. Ecco alcune delle trappole più comuni e i modi per evitarle:

\begin{enumerate}

\item Non dimenticate che la maggior parte dei metodi delle liste modificano l'argomento e restituiscono {\tt None}.  È il comportamento opposto dei metodi delle stringhe, che restituiscono una nuova stringa e lasciano immutato l'originale.

Se siete abituati a scrivere il codice per le stringhe così:

\begin{verbatim}
parola = parola.strip()
\end{verbatim}

Può venire spontaneo di scrivere il codice per le liste così:

\begin{verbatim}
t = t.sort()           # SBAGLIATO!
\end{verbatim}
\index{sort, metodo}
\index{metodo!sort}

Ma poiché {\tt sort} restituisce {\tt None}, l'operazione successiva che eseguite su {\tt t} con tutta probabilità fallirà.

Prima di usare i metodi delle liste e gli operatori, leggete attentamente la documentazione e fate una prova in modalità interattiva. Metodi e operatori condivisi tra liste e altre sequenze (come le stringhe) sono descritti sul sito
\url{http://docs.python.org/2/library/stdtypes.html#typesseq}.  Quelli applicabili solo alle sequenze mutabili si trovano invece all'indirizzo \url{http://docs.python.org/2/library/stdtypes.html#typesseq-mutable}.


\item Scegliete un costrutto e usate sempre quello.

Una parte dei problemi delle liste deriva dal fatto che ci sono molti modi per fare le cose. Per esempio, per rimuovere un elemento da una lista potete usare {\tt pop}, {\tt remove}, {\tt del}, oppure lo slicing.

Per aggiungere un elemento potete usare il metodo {\tt append} o l'operatore {\tt +}. Supponendo che {\tt t} sia una lista e {\tt x} un elemento, le espressioni seguenti vanno entrambe bene:

\begin{verbatim}
t.append(x)
t = t + [x]
\end{verbatim}

Mentre queste sono sbagliate:

\begin{verbatim}
t.append([x])          # SBAGLIATO!
t = t.append(x)        # SBAGLIATO!
t + [x]                # SBAGLIATO!
t = t + x              # SBAGLIATO!
\end{verbatim}

Provate ognuno di questi esempi in modalità interattiva per verificare quello che fanno. Noterete che solo l'ultima causa un errore di esecuzione; le altre sono espressioni consentite, ma che fanno la cosa sbagliata.


\item Fate copie per evitare gli alias.
\index{alias!copiare per evitare}
\index{copia!per evitare alias}

Se volete usare un metodo come {\tt sort} che modifica l'argomento, ma anche mantenere inalterata la lista di origine, potete farne una copia.

\begin{verbatim}
orig = t[:]
t.sort()
\end{verbatim}

In questo esempio potete anche usare la funzione predefinita {\tt sorted},
che restituisce una nuova lista ordinata e lascia intatta quella di origine. Ma in questo caso evitate di usare {\tt sorted} come nome di variabile!

\end{enumerate}



\section{Glossario}

\begin{description}

\item[lista:] Una sequenza di valori.
\index{lista}

\item[elemento:] Uno dei valori in una lista (o in altri tipi di sequenza).
\index{elemento}

\item[indice:] Valore intero che indica un elemento all'interno di una lista.
\index{indice}

\item[lista nidificata:] Lista che è contenuta come elemento in un'altra lista.
\index{lista!nidificata}

\item[attraversamento di una lista:] Accesso in sequenza di tutti gli elementi di una lista.
\index{lista!attraversamento}

\item[mappatura:] Una relazione in cui ogni elemento di un insieme corrisponde ad un elemento di un altro insieme. Ad esempio, una lista è una mappatura da indici a elementi.
\index{mappatura}

\item[accumulatore:] Variabile usata in un ciclo per sommare cumulativamente un risultato.
\index{accumulatore}

\item[assegnazione potenziata:] Istruzione che aggiorna un valore di una variabile usando un operatore come \verb"+=".
\index{assegnazione!potenziata}
\index{attraversamento}

\item[riduzione:] Schema di elaborazione che attraversa una sequenza e ne accumula gli elementi in un singolo risultato.
\index{riduzione, schema}
\index{schema!riduzione}

\item[mappa:] Schema di elaborazione che attraversa una sequenza ed esegue una stessa operazione su ciascun elemento della sequenza.
\index{mappa, schema}
\index{schema!mappa}

\item[filtro:] Schema di elaborazione che attraversa una lista e seleziona solo gli elementi che soddisfano un dato criterio.
\index{filtro, schema}
\index{schema!filtro}

\item[oggetto:] Qualcosa a cui una variabile può fare riferimento. Un oggetto ha un tipo e un valore.
\index{oggetto}

\item[equivalente:] Avente lo stesso valore.
\index{equivalente}

\item[identico:] Essere lo stesso oggetto (implica anche l'equivalenza).
\index{identico}

\item[riferimento:] L'associazione tra una variabile e il suo valore.
\index{riferimento}

\item[alias:] Due o più variabili che si riferiscono allo stesso oggetto, con nomi diversi.
\index{alias}

\item[delimitatore:] Carattere o stringa usato per indicare i punti dove una stringa deve essere spezzata.
\index{delimitatore}

\end{description}


\section{Esercizi}

\begin{exercise}
Scrivete una funzione di nome \verb"ordinata" che prenda una lista come parametro e restituisca {\tt True} se la lista è ordinata in senso crescente, {\tt False} altrimenti. Supponete (come precondizione) che gli elementi della lista siano confrontabili con gli operatori relazionali {\tt <}, {\tt >}, ecc.
\index{precondizione}

Per esempio, \verb"ordinata([1,2,2])" deve restituire {\tt True}
e \verb"ordinata(['b','a'])" invece {\tt False}.
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{anagram}
\index{anagramma}

Due parole sono anagrammi se potete ottenerle riordinando le lettere di cui sono composte. Scrivete una funzione di nome \verb"anagramma"
che riceva due stringhe e restituisca {\tt True} se sono anagrammi.
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{duplicate}

Il cosiddetto ``Paradosso del compleanno'':

\begin{enumerate}

\item Scrivete una funzione di nome \verb"ha_duplicati" che richieda una lista e restituisca {\tt True} se contiene elementi che compaiono più di una volta. Non deve modificare la lista di origine.
\index{compleanno, paradosso del}
\index{duplicato}

\item Se in una classe ci sono 23 studenti, quante probabilità ci sono che due di loro compiano gli anni lo stesso giorno? Potete stimare questa probabilità generando alcuni campioni a caso di 23 date e controllando le corrispondenze. Suggerimento: per generare date in modo casuale usate la funzione {\tt randint} nel modulo {\tt random}.
\index{random, modulo}
\index{modulo!random}
\index{randint, funzione}
\index{funzione!randint}

\end{enumerate}

Potete saperne di più su questo problema sul sito
\url{http://it.wikipedia.org/wiki/Paradosso_del_compleanno}, e scaricare la mia soluzione da  \url{http://thinkpython.com/code/birthday.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{duplicato}
\index{unicità}

Scrivete una funzione di nome \verb"rimuovi_duplicati" che richieda una lista come parametro e restituisca una nuova lista che contiene solo valori non ripetuti. Suggerimento: non è necessario che siano nello stesso ordine.
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{append, metodo}
\index{metodo!append}
\index{lista!concatenamento}
\index{concatenamento!lista}

Scrivete una funzione che legga il file {\tt words.txt} e crei una lista in cui ogni parola è un elemento. Scrivete due versioni della funzione, una che usi il metodo {\tt append} e una il costrutto {\tt t = t + [x]}. Quale richiede più tempo di esecuzione? Perché?

Suggerimento: Usate il modulo {\tt time} per misurare il tempo impiegato.
Soluzione: \url{http://thinkpython.com/code/wordlist.py}.
\index{time, modulo}
\index{modulo!time}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{wordlist1}
\label{bisection}
\index{appartenenza!ricerca binaria}
\index{ricerca!binaria}
\index{appartenenza!ricerca binaria}
\index{ricerca!binaria}

Per controllare se una parola è contenuta in un elenco, è possibile usare l'operatore {\tt in}, ma è un metodo lento, perché ricerca le parole seguendo il loro ordine.

Dato che le parole sono in ordine alfabetico, possiamo accelerare l'operazione con una ricerca binaria (o per bisezione), che è un po' come cercare una parola nel dizionario.
Partite nel mezzo e controllate se la parola che cercate viene prima o dopo la parola di metà elenco. Se prima, cercherete nella prima metà nello stesso modo, se dopo, cercherete nella seconda metà.

Ad ogni passaggio, dimezzate lo spazio di ricerca. Se l'elenco ha 113.809 parole, ci vorranno circa 17 passaggi per trovare la parola o concludere che non c'è.

Scrivete una funzione di nome {\tt bisezione} che richieda una lista ordinata e un valore da ricercare, e restituisca l'indice di quel valore, se fa parte della lista, oppure {\tt None} se non esiste.
\index{bisect, modulo}
\index{modulo!bisect}

Oppure, potete leggere la documentazione del modulo {\tt bisect} e usare quello!  Soluzione: \url{http://thinkpython.com/code/inlist.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{bifronte, parola}

Una coppia di parole è ``bifronte'' se l'una si legge nel verso opposto dell'altra. Scrivete un programma che trovi tutte le parole bifronti nella lista di parole.  Soluzione: \url{http://thinkpython.com/code/reverse_pair.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{incastro, parola}

Due parole si ``incastrano'' se, prendendo le loro lettere alternativamente  dall'una e dall'altra, si forma una nuova parola. Per esempio, le parole inglesi ``shoe'' and ``cold'' incastrandosi formano ``schooled''.


\begin{enumerate}

\item Scrivete un programma che trovi tutte le coppie di parole che possono incastrarsi. Suggerimento: non elaborate tutte le coppie!

\item Riuscite a trovare dei gruppi di tre parole che possono incastrarsi tra loro? Cioè, tre parole da cui, prendendo le lettere una ad una alternativamente, nell'ordine, si formi una nuova parola? (Es. ``ace'', ``bus'' e ``as'' danno ``abacuses'')

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/interlock.py}.
Fonte: Questo esercizio è tratto da un esempio di  \url{http://puzzlers.org}.
\end{exercise}


\chapter{Dizionari}

\index{dizionario}
\index{tipo!dict}
\index{chiave}
\index{chiave-valore, coppia}
\index{indice}
Un {\bf dizionario} è simile ad una lista, ma è più generico. Infatti, mentre in una lista gli indici devono essere numeri interi, in un dizionario possono essere (quasi) di ogni tipo.

Si può pensare ad un dizionario come ad una relazione di corrispondenza (mappatura) da un insieme di indici, chiamati {\bf chiavi}, a un insieme di valori. Ad ogni chiave corrisponde un valore. L'associazione tra una chiave e un valore è detta {\bf coppia chiave-valore} o anche {\bf elemento}.

Come esempio, costruiamo un dizionario che trasforma le parole dall'inglese all'italiano, quindi chiavi e valori saranno tutte delle stringhe.

La funzione {\tt dict} crea un nuovo dizionario privo di elementi. Siccome {\tt dict} è il nome di una funzione predefinita, è meglio evitare di usarlo come nome di variabile.
\index{dict, funzione}
\index{funzione!dict}

\begin{verbatim}
>>> eng2it = dict()
>>> print eng2it
{}
\end{verbatim}

Le parentesi graffe, \verb"{}", rappresentano un dizionario vuoto. Per aggiungere elementi al dizionario, usate le parentesi quadre:
\index{graffe, parentesi}
\index{parentesi!graffe}

\begin{verbatim}
>>> eng2it['one'] = 'uno'
\end{verbatim}
%
Questa riga crea un elemento che contiene una corrispondenza dalla chiave
{\tt 'one'} al valore \verb"'uno'".  Se stampiamo di nuovo il dizionario, vedremo ora una coppia chiave-valore separati da due punti:

\begin{verbatim}
>>> print eng2it
{'one': 'uno'}
\end{verbatim}
%
Questo formato di output può essere anche usato per gli inserimenti. Ad esempio potete creare un nuovo dizionario con tre elementi:

\begin{verbatim}
>>> eng2it = {'one': 'uno', 'two': 'due', 'three': 'tre'}
\end{verbatim}
%
Se stampate ancora una volta {\tt eng2it}, avrete una sorpresa:

\begin{verbatim}
>>> print eng2it
{'one': 'uno', 'three': 'tre', 'two': 'due'}
\end{verbatim}
%
L'ordine delle coppie chiave-valore non è lo stesso. In effetti, se scrivete lo stesso esempio nel vostro computer, potreste ottenere un altro risultato ancora. In genere, l'ordine degli elementi di un dizionario è imprevedibile.

Ma questo non è un problema, perché gli elementi di un dizionario non sono indicizzati con degli indici numerici. Infatti, per cercare un valore si usano invece le chiavi:

\begin{verbatim}
>>> print eng2it['two']
'due'
\end{verbatim}
%
La chiave {\tt 'two'} corrisponde correttamente al valore \verb"'due'" e l'ordine degli elementi nel dizionario è ininfluente.

Se la chiave non è contenuta nel dizionario, viene generato un errore::
\index{eccezione!KeyError}
\index{KeyError}

\begin{verbatim}
>>> print eng2it['four']
KeyError: 'four'
\end{verbatim}
%
La funzione {\tt len} è applicabile ai dizionari, e restituisce il numero di coppie chiave-valore:
\index{len, funzione}
\index{funzione!len}

\begin{verbatim}
>>> len(eng2it)
3
\end{verbatim}
%
Anche l'operatore {\tt in} funziona con i dizionari: informa se qualcosa compare come {\em chiave} nel dizionario (non è condizione sufficiente che sia contenuto come valore).
\index{appartenenza!dizionario}
\index{in, operatore}
\index{operatore!in}

\begin{verbatim}
>>> 'one' in eng2it
True
>>> 'uno' in eng2it
False
\end{verbatim}
%
Per controllare invece se qualcosa compare come valore, potete usare il metodo {\tt values}, che restituisce i valori sotto forma di lista, e quindi usare l'operatore {\tt in}:
\index{values, metodo}
\index{metodo!values}

\begin{verbatim}
>>> vals = eng2it.values()
>>> 'uno' in vals
True
\end{verbatim}
%
L'operatore {\tt in} utilizza algoritmi diversi per liste e dizionari. Per le prime, usa un algoritmo di ricerca, come nel Paragrafo~\ref{find}.  Se la lista si allunga, anche il tempo di ricerca si allunga in proporzione. Per i secondi, Python usa un algoritmo chiamato {\bf tabella hash} che ha notevoli proprietà: l'operatore {\tt in} impiega sempre circa lo stesso tempo, indipendentemente da quanti elementi contiene il dizionario. Non mi dilungo a spiegare come ciò sia possibile, ma chi lo desidera può saperne di più sul sito
\url{http://it.wikipedia.org/wiki/Hash_table}.
\index{tabella hash}

\vspace{0.2in}
\begin{exercise}
\label{wordlist2}
\index{insieme di appartenenza}
\index{appartenenza!insieme di}

Scrivete una funzione che legga le parole in {\tt words.txt} e le inserisca come chiavi in un dizionario. I valori non hanno importanza. Usate poi l'operatore {\tt in} come modo rapido per controllare se una stringa è contenuta nel dizionario.

Se avete svolto l'Esercizio~\ref{wordlist1}, potete confrontare la velocità di questa implementazione con l'operatore {\tt in} applicato alla lista e la ricerca binaria.

\end{exercise}


\section{Il dizionario come gruppo di contatori}
\label{histogram}
\index{contatore}

Supponiamo che vi venga data una stringa e che vogliate contare quante volte vi compare ciascuna lettera. Ci sono alcuni modi per farlo:

\begin{enumerate}

\item Potete creare 26 variabili, una per lettera dell'alfabeto. Quindi, fare un attraversamento della stringa e per ciascun carattere incrementate il contatore corrispondente, magari usando delle condizioni in serie.

\item Potete creare una lista di 26 elementi, quindi convertire ogni carattere in un numero (usando la funzione predefinita {\tt ord}), utilizzare il numero come indice e incrementare il contatore corrispondente.

\item Potete creare un dizionario con i caratteri come chiavi e i contatori come valore corrispondente. La prima volta che incontrate un carattere, lo aggiungete come elemento al dizionario. Successivamente, incrementerete il valore dell'elemento esistente.

\end{enumerate}

Ciascuna di queste opzioni esegue lo stesso calcolo, ma lo implementa in modo diverso.
\index{implementazione}

Un'{\bf implementazione} è un modo per effettuare un'elaborazione. Le implementazioni non sono tutte uguali, alcune sono migliori di altre: per esempio, un vantaggio dell'implementazione con il dizionario è che non serve sapere in anticipo quali lettere ci siano nella stringa e quali no, dobbiamo solo fare spazio per le lettere che compariranno effettivamente.

Ecco come potrebbe essere scritto il codice:

\begin{verbatim}
def istogramma(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
\end{verbatim}
%
Il nome di questa funzione è {\bf istogramma}, che è un termine statistico per indicare un insieme di contatori (o frequenze).
\index{istogramma}
\index{frequenza}
\index{attraversamento}

La prima riga della funzione crea un dizionario vuoto. Il ciclo {\tt for}  attraversa la stringa. Ad ogni ripetizione, se il carattere {\tt c} non compare nel dizionario crea un nuovo elemento di chiave {\tt c} e valore iniziale 1 (dato che incontra questa lettera per la prima volta). Se invece {\tt c} è già presente, incrementa {\tt d[c]} di una unità.
\index{istogramma}

Vediamo come funziona:

\begin{verbatim}
>>> h = istogramma('brontosauro')
>>> print h
{'a': 1, 'b': 1, 'o': 3, 'n': 1, 's': 1, 'r': 2, 'u': 1, 't': 1}
\end{verbatim}
%
L'istogramma indica che le lettere {\tt 'a'} e \verb"'b'"
compaiono una volta, la \verb"'o'" tre volte e così via.

\vspace{0.2in}
\begin{exercise}
\index{get, metodo}
\index{metodo!get}

I dizionari hanno un metodo {\tt get} che richiede una chiave e un valore predefinito. Se la chiave è presente nel dizionario, {\tt get} restituisce il suo valore corrispondente, altrimenti restituisce il valore predefinito. Per esempio:

\begin{verbatim}
>>> h = istogramma('a')
>>> print h
{'a': 1}
>>> h.get('a', 0)
1
>>> h.get('b', 0)
0
\end{verbatim}
%
Usate {\tt get} per scrivere {\tt istogramma} in modo più compatto. Dovreste riuscire a fare a meno dell'istruzione {\tt if}.
\end{exercise}


\section{Cicli e dizionari}
\index{dizionario!ciclo con}
\index{ciclo!con dizionario}
\index{attraversamento}

Se usate un dizionario in un ciclo {\tt for}, quest'ultimo attraversa le chiavi del dizionario. Per esempio, \verb"stampa_isto" visualizza ciascuna chiave e il valore corrispondente:

\begin{verbatim}
def stampa_isto(h):
    for c in h:
        print c, h[c]
\end{verbatim}
%
Ecco come risulta l'output:

\begin{verbatim}
>>> h = istogramma('parrot')
>>> stampa_isto(h)
a 1
p 1
r 2
t 1
o 1
\end{verbatim}
%
Di nuovo, le chiavi sono alla rinfusa.

\vspace{0.2in}
\begin{exercise}
\index{keys, metodo}
\index{metodo!keys}

I dizionari hanno un metodo {\tt keys} che restituisce le chiavi, senza seguire un ordine particolare, sotto forma di lista.

Modificate \verb"stampa_isto" in modo da stampare le chiavi, con i corrispondenti valori, in ordine alfabetico.
\end{exercise}



\section{Lookup inverso}
\label{raise}
\index{dizionario!lookup}
\index{dizionario!lookup inverso}
\index{lookup!dizionario}
\index{lookup inverso, dizionario}

Dato un dizionario {\tt d} e una chiave {\tt k}, è facile trovare il valore corrispondente alla chiave: {\tt v = d[k]}.  Questa operazione è chiamata {\bf lookup}.

Ma se volete trovare la chiave {\tt k} conoscendo il valore {\tt v}?
Avete due problemi: primo, ci possono essere più chiavi che corrispondono al valore {\tt v}.  A seconda dell'applicazione, potete riuscire a trovarne uno, oppure può essere necessario ricavare una lista che li contenga tutti. Secondo, non c'è una sintassi semplice per fare un {\bf lookup inverso}; dovete impostare una ricerca.

Ecco una funzione che richiede un valore e restituisce la prima chiave a cui corrisponde quel valore:

\begin{verbatim}
def inverso_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise ValueError
\end{verbatim}
%
Questa funzione è un altro esempio di schema di ricerca, ma usa un'istruzione che non abbiamo mai visto prima, {\tt raise}.  L'istruzione {\tt raise}
solleva un'eccezione; in questo caso genera un errore {\tt ValueError}, che di solito indica che c'è qualcosa di sbagliato nel valore di un parametro.
\index{ricerca}
\index{schema!di ricerca}
\index{raise, istruzione}
\index{istruzione!raise}
\index{eccezione!ValueError}
\index{ValueError}

Se arriviamo a fine ciclo, significa che {\tt v}
non compare nel dizionario come valore, per cui solleviamo un'eccezione.

Ecco un esempio di lookup inverso riuscito:

\begin{verbatim}
>>> h = istogramma('parrot')
>>> k = inverso_lookup(h, 2)
>>> print k
r
\end{verbatim}
%
E di uno fallito:

\begin{verbatim}
>>> k = inverso_lookup(h, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 5, in inverso_lookup
ValueError
\end{verbatim}
%
Quando generate un errore, il risultato è lo stesso di quando lo genera Python: viene stampato un traceback con un messaggio di errore.
\index{traceback}
\index{argomento!opzionale}

L'istruzione {\tt raise} riceve come parametro opzionale un messaggio di errore dettagliato. Per esempio:

\begin{verbatim}
>>> raise ValueError, 'il valore non compare nel dizionario'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: il valore non compare nel dizionario
\end{verbatim}
%
In Python 3, la sintassi è cambiata:

\begin{verbatim}
>>> raise ValueError('il valore non compare nel dizionario')
\end{verbatim}
%

Un lookup inverso è molto più lento di un lookup; se dovete farlo spesso, o se il dizionario diventa molto grande, le prestazioni del vostro programma potrebbero risentirne.

\vspace{0.2in}
\begin{exercise}

Modificate \verb"inverso_lookup" in modo che crei e restituisca una lista di {\em tutte} le chiavi che corrispondono a {\tt v}, oppure una lista vuota se non ce ne sono.

\end{exercise}


\section{Dizionari e liste}
\label{invert}

Le liste possono comparire come valori in un dizionario. Per esempio, se avete un dizionario che fa corrispondere le lettere alle loro frequenze, potreste volere l'inverso; cioè creare un dizionario che a partire dalle frequenze fa corrispondere le lettere. Poiché ci possono essere più lettere con la stessa frequenza, ogni valore del dizionario inverso dovrebbe essere una lista di lettere.
\index{dizionario!inverso}

Ecco una funzione che inverte un dizionario:

\begin{verbatim}
def inverti_diz(d):
    inverso = dict()
    for chiave in d:
        valore = d[chiave]
        if valore not in inverso:
            inverso[valore] = [chiave]
        else:
            inverso[valore].append(chiave)
    return inverso
\end{verbatim}
%
Per ogni ripetizione del ciclo, {\tt chiave} prende una chiave da {\tt d} e 
{\tt valore} assume il corrispondente valore.  Se {\tt valore} non appartiene a  {\tt inverso}, vuol dire che non è ancora comparso, per cui creiamo un nuovo elemento e lo inizializziamo con un {\bf singleton} (lista che contiene un solo elemento).  Altrimenti, se il valore era già apparso, accodiamo la chiave corrispondente alla lista esistente.
\index{singleton}

Ecco un esempio:

\begin{verbatim}
>>> isto = istogramma('parrot')
>>> print isto
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
>>> inverso = inverti_diz(isto)
>>> print inverso
{1: ['a', 'p', 't', 'o'], 2: ['r']}
\end{verbatim}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/dict1.pdf}}
\caption{Diagramma di stato.}
\label{fig.dict1}
\end{figure}

La Figura~\ref{fig.dict1} è un diagramma di stato che mostra {\tt isto} e {\tt inverso}.
Un dizionario viene rappresentato come un riquadro con la scritta {\tt dict} sopra e le coppie chiave-valore all'interno. Di solito, se i valori sono interi, float o stringhe, li raffiguro dentro il riquadro, lascio invece all'esterno le liste per mantenere semplice il diagramma.
\index{diagramma!di stato}

Le liste possono essere valori nel dizionario, come mostra questo esempio, ma non possono essere chiavi. Ecco cosa succede se ci provate:
\index{TypeError}
\index{eccezione!TypeError}


\begin{verbatim}
>>> t = [1, 2, 3]
>>> d = dict()
>>> d[t] = 'oops'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: list objects are unhashable
\end{verbatim}
%
Ho accennato che i dizionari sono implementati usando una tabella hash, e questo implica che sulle chiavi deve poter essere calcolato un {\bf hash}.
\index{hash, funzione}
\index{hash-abile}

Un {\bf hash} è una funzione che prende un valore (di qualsiasi tipo) e restituisce un intero. I dizionari usano questi interi, chiamati valori hash, per conservare e consultare le coppie chiave-valore.
\index{immutabilità}

Questo sistema funziona se le chiavi sono immutabili; ma se sono mutabili, come le liste, succedono disastri. Per esempio, nel creare una coppia chiave-valore, Python fa l'hash della chiave e la immagazzina nello spazio corrispondente. Se modificate la chiave e quindi viene nuovamente calcolato l'hash, si collocherebbe in un altro spazio. In quel caso potreste avere due voci della stessa chiave, oppure non riuscire a trovare una chiave. In ogni caso il dizionario non funzionerà correttamente.

Ecco perché le chiavi devono essere idonee all'hashing, e quelle mutabili come le liste non lo sono. Il modo più semplice per aggirare questo limite è usare le tuple, che vedremo nel prossimo capitolo.

Dato che i dizionari sono mutabili, non possono essere usati come chiavi ma {\em possono} essere usati come valori.

\vspace{0.2in}
\begin{exercise}
Leggete la documentazione del metodo dei dizionari {\tt setdefault}
e usatelo per scrivere una versione più concisa di \verb"inverti_diz".
Soluzione: \url{http://thinkpython.com/code/invert_dict.py}.
\index{setdefault, metodo}
\index{metodo!setdefault}

\end{exercise}


\section{Memoizzazione}

Se vi siete sbizzarriti con la funzione {\tt fibonacci} del Paragrafo~\ref{one.more.example}, avrete notato che più grande è l'argomento che passate, maggiore è il tempo necessario per l'esecuzione della funzione. Inoltre, il tempo di elaborazione cresce molto rapidamente.
\index{fibonacci, funzione}
\index{funzione!fibonacci}

Per capire il motivo, confrontate la Figura~\ref{fig.fibonacci}, che mostra il {\bf grafico di chiamata} di {\tt fibonacci} con {\tt n=4}:

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/fibonacci.pdf}}
\caption{Grafico di chiamata.}
\label{fig.fibonacci}
\end{figure}

Un grafico di chiamata mostra l'insieme dei frame della funzione, con linee che collegano ciascun frame ai frame delle funzioni che chiama a sua volta. In cima al grafico, {\tt fibonacci} con {\tt n=4} chiama {\tt fibonacci} con {\tt
n=3} e {\tt n=2}.  A sua volta, {\tt fibonacci} con {\tt n=3} chiama
{\tt fibonacci} con {\tt n=2} e {\tt n=1}.  E così via.
\index{funzione!frame di}
\index{frame}
\index{grafico di chiamata}

Provate a contare quante volte vengono chiamate {\tt fibonacci(0)} e {\tt fibonacci(1)}. Questa è una soluzione inefficiente del problema, che peggiora ulteriormente al crescere dell'argomento.
\index{memoizzazione}

Una soluzione migliore è tenere da parte i valori che sono già stati calcolati, conservandoli in un dizionario. La tecnica di conservare per un uso successivo un valore già calcolato, così da non doverlo ricalcolare ogni volta, viene detta {\bf memoizzazione}.  Ecco una versione di {\tt fibonacci} che usa la memoizzazione:

\begin{verbatim}
memo = {0:0, 1:1}

def fibonacci(n):
    if n in memo:
        return memo[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    memo[n] = res
    return res
\end{verbatim}
%
{\tt memo} è un dizionario che conserva i numeri di Fibonacci già conosciuti. Parte con due elementi: 0 che corrisponde a 0, e 1 che corrisponde a 1.

Ogni volta che {\tt fibonacci} viene chiamata, controlla innanzitutto {\tt memo}.
Se quest'ultimo contiene già il risultato, ritorna immediatamente. Altrimenti deve calcolare il nuovo valore, lo aggiunge al dizionario e lo restituisce.

\vspace{0.2in}
\begin{exercise}

Eseguite questa versione di {\tt fibonacci} e l'originale con un ventaglio di parametri, e confrontate i loro tempi di esecuzione.

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Applicate la memoizzazione alla funzione di Ackermann dell'Esercizio~\ref{ackermann} e provate a vedere se questa tecnica rende possibile il calcolo della funzione con argomenti più grandi. Suggerimento: no.
Soluzione: \url{http://thinkpython.com/code/ackermann_memo.py}.
\index{Ackermann, funzione di}
\index{funzione!ack}

\end{exercise}


\section{Variabili globali}
\index{variabile!globale}

Nell'esempio precedente, {\tt memo} viene creato esternamente alla funzione, pertanto appartiene al frame speciale chiamato \verb"__main__".
Le variabili di \verb"__main__" sono dette anche {\bf globali}
perché ad esse possono accedere tutte le funzioni. A differenza delle variabili locali, che sono distrutte al termine della esecuzione della loro funzione, quelle globali persistono tra una chiamata di funzione e l'altra.
\index{flag}

Di frequente le variabili globali vengono usate come controlli o {\bf flag}; vale a dire, variabili booleane che indicano quando una certa condizione è soddisfatta (True). Per esempio, alcuni programmi usano un flag di nome {\tt verbose} per controllare il livello di dettaglio da dare ad un output:

\begin{verbatim}
verbose = True

def esempio1():
    if verbose:
        print 'esempio1 in esecuzione'
\end{verbatim}
%
Se cercate di riassegnare una variabile globale, potreste avere una sorpresa. L'esempio seguente vorrebbe controllare se una funzione è stata chiamata:
\index{assegnazione!multipla}

\begin{verbatim}
stata_chiamata = False

def esempio2():
    stata_chiamata = True         # SBAGLIATO
\end{verbatim}
%
Ma se la eseguite vedrete che il valore di \verb"stata_chiamata"
non cambia. Il motivo è che la funzione {\tt esempio2} crea una nuova variabile di nome \verb"stata_chiamata", che è locale, viene distrutta al termine della funzione e non ha effetti sulla variabile globale.
\index{global, istruzione}
\index{istruzione!global}
\index{dichiarazione}

Per riassegnare una variabile globale dall'interno di una funzione, dovete
{\bf dichiarare} la variabile globale prima di usarla:

\begin{verbatim}
stata_chiamata = False

def esempio2():
    global stata_chiamata 
    stata_chiamata = True
\end{verbatim}
%
L'istruzione {\tt global} dice all'interprete una cosa del genere: ``In questa funzione, quando dico \verb"stata_chiamata", intendo la variabile globale: non crearne una locale''.
\index{aggiornamento!variabile globale}
\index{variabile!globale!aggiornamento}

Ecco un altro esempio che cerca di aggiornare una variabile globale:

\begin{verbatim}
conta = 0

def example3():
    conta = conta + 1          # SBAGLIATO
\end{verbatim}
%
Se lo eseguite, ottenete:
\index{UnboundLocalError}
\index{eccezione!UnboundLocalError}

\begin{verbatim}
UnboundLocalError: local variable 'conta' referenced before assignment
\end{verbatim}
%
Python presume che {\tt conta} nella funzione sia locale, il che comporta che state usando la variabile prima di averla inizializzata. La soluzione è ancora quella di dichiarare {\tt count} globale.
\index{contatore}

\begin{verbatim}
def esempio():
    global conta
    conta += 1
\end{verbatim}
%
Se il valore globale è mutabile, potete modificarlo anche senza dichiararlo:
\index{mutabilità}

\begin{verbatim}
noto = {0:0, 1:1}

def esempio():
    noto[2] = 1
\end{verbatim}
%
Pertanto, potete aggiungere, rimuovere e sostituire elementi di una lista o dizionario globali, ma se dovete riassegnare la variabile, occorre dichiararla:

\begin{verbatim}
def esempio():
    global noto
    noto = dict()
\end{verbatim}
%

\section{Interi lunghi}
\index{long, intero}
\index{intero!long}
\index{tipo!long}

Se calcolate {\tt fibonacci(50)}, ottenete:

\begin{verbatim}
>>> fibonacci(50)
12586269025L
\end{verbatim}
%
La {\tt L} finale indica che il risultato è un intero lungo, o di tipo {\tt long}.  In Python 3, {\tt long} non esiste più; tutti gli interi sono di tipo {\tt int}, anche quelli molto grandi.
\index{Python 3}

I valori di tipo {\tt int} hanno un intervallo limitato; gli interi long possono essere grandi a piacere, ma più grandi sono più richiedono spazio in memoria e  tempo.

Gli operatori matematici funzionano con gli interi lunghi, come pure le funzioni del modulo {\tt math} e in genere tutto il codice che funziona con gli {\tt int} funzionerà anche con i {\tt long}.

Tutte le volte che il risultato di un calcolo è troppo grande per essere rappresentato da un intero, Python lo converte in un intero lungo:

\begin{verbatim}
>>> 1000 * 1000
1000000
>>> 100000 * 100000
10000000000L
\end{verbatim}
%
Nel primo caso il risultato è di tipo {\tt int}; nel secondo è {\tt long}.

\vspace{0.2in}
\begin{exercise}
\index{crittografia}
\index{RSA, algoritmo}
\index{algoritmo!RSA}

L'elevamento a potenza di grandi interi è alla base dei noti algoritmi di crittografia a chiave pubblica. Leggete la pagina di Wikipedia sull'algoritmo RSA (\url{http://it.wikipedia.org/wiki/RSA}) e scrivete una funzione per codificare e decodificare i messaggi.

% TODO: solution for this one!

\end{exercise}


\section{Debug}
\index{debug}

Se lavorate con banche dati di grosse dimensioni, può diventare oneroso fare il debug stampando e controllando i dati manualmente. Ecco allora alcuni suggerimenti per fare il debug in queste situazioni:

\begin{description}

\item[Ridurre l'input:] Se possibile, riducete le dimensioni della banca dati. Per esempio, se il programma legge un file di testo, cominciate con le sole prime 10 righe o con il più piccolo campione che riuscite a trovare. Potete anche adattare i file stessi, o (meglio) modificare il programma, in modo che legga solo le prime {\tt n} righe.

Se c'è un errore, potete ridurre {\tt n} al più piccolo valore per il quale si manifesta l'errore, poi aumentarlo gradualmente finché non trovate e correggete l'errore.

\item[Controllare riassunti e tipi:] Invece di stampare e controllare l'intera banca dati, prendete in considerazione di stampare riassunti dei dati: ad esempio il numero di elementi in un dizionario o la sommatoria di una lista di numeri.

Una causa frequente di errori in esecuzione è un valore che non è del tipo giusto. Per fare il debug di questo tipo di errori basta spesso stampare il tipo di un valore.

\item[Scrivere controlli automatici:]  Talvolta è utile scrivere del codice per controllare automaticamente gli errori. Per esempio, se dovete calcolare la media di una lista di numeri, potete controllare che il risultato non sia maggiore dell'elemento più grande della lista e non sia minore del più piccolo. Questo è detto ``controllo di congruenza'' perché mira a trovare i risultati ``incongruenti''.
\index{congruenza, controllo di}
\index{coerenza, controllo di}

Un altro tipo di controllo confronta i risultati di due calcoli per vedere se collimano. Questo è chiamato ``controllo di coerenza''.

\item[Stampare gli output in bella copia:] Una buona presentazione dei risultati di debug rende più facile trovare un errore. Abbiamo visto un esempio nel Paragrafo~\ref{factdebug}.  Il modulo {\tt pprint} contiene la funzione {\tt pprint} che mostra i tipi predefiniti in un formato più leggibile.
\index{bella copia}
\index{pprint, modulo}
\index{modulo!pprint}

\end{description}

Ancora, il tempo che impiegate a scrivere del codice temporaneo può essere ripagato dalla riduzione del tempo di debug.
\index{impalcatura}

\section{Glossario}

\begin{description}

\item[dizionario:] Una mappatura da un insieme di chiavi ai loro valori corrispondenti.
\index{dizionario}

\item[coppia chiave-valore:] Rappresentazione della mappatura da una chiave a un valore.
\index{chiave-valore, coppia}

\item[elemento:] Altro nome della coppia chiave-valore.
\index{elemento!dizionario}

\item[chiave:] Oggetto che compare in un dizionario come prima voce di una coppia chiave-valore.
\index{chiave}

\item[valore:] Oggetto che compare in un dizionario come seconda voce di una coppia chiave-valore. È più specifico dell'utilizzo del termine ``valore'' fatto sinora.
\index{valore}

\item[implementazione:] Un modo per effettuare un'elaborazione.
\index{implementazione}

\item[tabella hash:] Algoritmo usato per implementare i dizionari in Python.
\index{tabella hash}

\item[funzione hash:] Funzione usata da una tabella hash per calcolare la collocazione di una chiave.
\index{hash, funzione}

\item[hash-abile:] Un tipo a cui si può applicare la funzione hash. I tipi immutabili come interi, float e stringhe lo sono; i tipi mutabili come liste e dizionari no.
\index{hash-abile}

\item[lookup:] Operazione su un dizionario che trova il valore corrispondente a una data chiave.
\index{lookup}

\item[lookup inverso:] Operazione su un dizionario che trova una o più chiavi alle quali è associato una dato valore.
\index{lookup inverso, dizionario}

\item[singleton:] Lista (o altra sequenza) con un singolo elemento.
\index{singleton}

\item[grafico di chiamata:] Diagramma che mostra tutti i frame creati durante l'esecuzione di un programma, con frecce che collegano ciascun chiamante ad ogni chiamata.
\index{chiamata, grafico di}
\index{diagramma!grafico di chiamata}

\item[istogramma:] Gruppo di contatori.
\index{istogramma}

\item[memoizzazione:] Conservare una valore calcolato per evitarne il successivo ricalcolo.
\index{memoizzazione}

\item[variabile globale:]  Variabile definita al di fuori di una funzione, alla quale ogni funzione può accedere.
\index{globale, variabile}

\item[controllo o flag:] Variabile booleana usata per indicare se una condizione è soddisfatta.
\index{flag}

\item[dichiarazione:] Istruzione come {\tt global} che comunica all'interprete un'informazione su una variabile.
\index{dichiarazione}

\end{description}

\section{Esercizi}

\begin{exercise}
\index{duplicato}

Se avete svolto l'Esercizio~\ref{duplicate}, avete già una funzione di nome \verb"ha_duplicati" che richiede come parametro una lista e restituisce {\tt True} se ci sono oggetti ripetuti all'interno della lista.

Usate un dizionario per scrivere una versione più rapida e semplice di
\verb"ha_duplicati". 
Soluzione: \url{http://thinkpython.com/code/has_duplicates.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{exrotatepairs}
\index{lettere!rotazione}
\index{rotazione!lettere}

Due parole sono ``ruotabili'' se potete far ruotare le lettere dell'una per ottenere l'altra (vedere \verb"ruota_parola" nell'Esercizio~\ref{exrotate}).

Scrivete un programma che legga un elenco di parole e trovi tutte le coppie di parole ruotabili. Soluzione: \url{http://thinkpython.com/code/rotate_pairs.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{Car Talk}
\index{Puzzler}

Ecco un altro quesito tratto da {\em Car Talk} (\url{http://www.cartalk.com/content/puzzlers}):

\begin{quote}
``Questo ci è stato mandato da un amico di nome Dan O'Leary. Si è recentemente imbattuto in una parola inglese di una sillaba e cinque lettere che ha questa singolare proprietà: se togliete la prima lettera, le lettere restanti formano un omofono della prima parola, cioè un'altra parola che pronunciata suona allo stesso modo. Se poi rimettete la prima lettera e togliete la seconda, ottenete ancora un altro omofono della parola di origine. Qual è questa parola?''

``Facciamo un esempio che non funziona del tutto. Prendiamo la parola 'wrack'; togliendo la prima lettera resta 'rack', che è un'altra parola ma è un perfetto omofono. Se però rimettete la prima lettera e togliete la seconda, ottenete 'wack' che pure esiste ma non è un omofono delle altre due parole.''

``Esiste comunque almeno una parola, che Dan e noi conosciamo, che dà due parole omofone di quattro lettere, sia che togliate la prima oppure la seconda lettera.''
\end{quote}
\index{omofono}
\index{riducibile, parola}
\index{parola, riducibile}

Potete usare il dizionario dell'Esercizio~\ref{wordlist2} per controllare se esiste una tale stringa nell'elenco di parole.

Per controllare se due parole sono omofone, potete usare il CMU Pronouncing Dictionary, scaricabile da
\url{http://www.speech.cs.cmu.edu/cgi-bin/cmudict} oppure da
\url{http://thinkpython.com/code/c06d} e potete anche procurarvi
\url{http://thinkpython.com/code/pronounce.py}, che fornisce una funzione di nome \verb"read_dictionary" che legge il dizionario delle pronunce e restituisce un dizionario Python in cui a ciascuna parola corrisponde la stringa che ne descrive la pronuncia.

Scrivete un programma che elenchi tutte le parole che risolvono il quesito. Soluzione: \url{http://thinkpython.com/code/homophone.py}.

\end{exercise}



\chapter{Tuple}
\label{tuplechap}

\section{Le tuple sono immutabili}
\index{tupla}
\index{tipo!tuple}
\index{sequenza}

Una tupla è una sequenza di valori. I valori possono essere di qualsiasi tipo, sono indicizzati tramite numeri interi, e in questo somigliano moltissimo alle liste. La differenza fondamentale è che le tuple sono immutabili.
\index{mutabilità}
\index{immutabilità}

Sintatticamente, la tupla è un elenco di valori separati da virgole:

\begin{verbatim}
>>> t = 'a', 'b', 'c', 'd', 'e'
\end{verbatim}
%
Sebbene non sia necessario, è convenzione racchiudere le tuple tra
   parentesi tonde:
\index{parentesi!tuple in}

\begin{verbatim}
>>> t = ('a', 'b', 'c', 'd', 'e')
\end{verbatim}
%
Per creare una tupla con un singolo elemento dobbiamo aggiungere la
   virgola finale dopo l'elemento:
\index{singleton}
\index{tupla!singleton}

\begin{verbatim}
>>> t1 = 'a',
>>> type(t1)
<type 'tuple'>
\end{verbatim}
%
Senza la virgola, infatti, un unico valore tra parentesi non è una tupla ma una stringa:

\begin{verbatim}
>>> t2 = ('a')
>>> type(t2)
<type 'str'>
\end{verbatim}
%
Un altro modo di creare una tupla è usare la funzione predefinita {\tt tuple}.
Se priva di argomento, crea una tupla vuota:
\index{tuple, funzione}
\index{funzione!tuple}

\begin{verbatim}
>>> t = tuple()
>>> print t
()
\end{verbatim}
%
Se l'argomento è una sequenza (stringa, lista o tupla), il risultato è una tupla con gli elementi della sequenza:

\begin{verbatim}
>>> t = tuple('lupini')
>>> print t
('l', 'u', 'p', 'i', 'n', 'i')
\end{verbatim}
%
Siccome {\tt tuple} è il nome di una funzione predefinita, bisogna evitare di usarlo come nome di variabile.

La maggior parte degli operatori delle liste funzionano anche con le tuple. L'operatore parentesi quadre indicizza un elemento della tupla:
\index{parentesi quadre, operatore}
\index{operatore!parentesi quadre}

\begin{verbatim}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print t[0]
'a'
\end{verbatim}
%
E l'operatore slice seleziona una serie di elementi consecutivi:
\index{slice, operatore}
\index{operatore!slice}
\index{tupla!slicing}
\index{slicing!tupla}

\begin{verbatim}
>>> print t[1:3]
('b', 'c')
\end{verbatim}
%
Ma a differenza delle liste, se cercate di modificare gli elementi di una tupla ottenete un messaggio d'errore:
\index{eccezione!TypeError}
\index{TypeError}
\index{elemento!assegnazione}
\index{assegnazione!elemento}

\begin{verbatim}
>>> t[0] = 'A'
TypeError: object doesn't support item assignment
\end{verbatim}
%
Anche se non potete modificare direttamente gli elementi di una tupla, potete sempre sostituirla con una sua copia modificata:

\begin{verbatim}
>>> t = ('A',) + t[1:]
>>> print t
('A', 'b', 'c', 'd', 'e')
\end{verbatim}
%

\section{Assegnazione di tupla}
\label{tuple.assignment}
\index{tupla!assegnazione}
\index{assegnazione!tupla}
\index{scambio, schema di}
\index{schema!di scambio}

Spesso è utile scambiare i valori di due variabili tra loro. Con le istruzioni di assegnazione convenzionali, dobbiamo usare una variabile temporanea. Per esempio per scambiare {\tt a} e {\tt b}:

\begin{verbatim}
>>> temp = a
>>> a = b
>>> b = temp
\end{verbatim}
%
Questo metodo è farraginoso; l'utilizzo dell'{\bf assegnazione di tupla} è più elegante:

\begin{verbatim}
>>> a, b = b, a
\end{verbatim}
%
La parte sinistra dell'assegnazione è una tupla di variabili; la parte
   destra una tupla di valori o espressioni. Ogni valore è assegnato alla rispettiva variabile. Tutte le espressioni sulla destra vengono valutate prima della rispettiva assegnazione.

Ovviamente il numero di variabili sulla sinistra deve corrispondere al
   numero di valori sulla destra:
\index{eccezione!ValueError}
\index{ValueError}

\begin{verbatim}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
\end{verbatim}
%
Più in generale, il lato destro può essere composto da ogni tipo di sequenza (stringhe, liste o tuple). Per esempio, per separare un indirizzo email tra nome utente e dominio, potete scrivere:
\index{split, metodo}
\index{metodo!split}
\index{email, indirizzo}

\begin{verbatim}
>>> indirizzo = 'monty@python.org'
>>> nome, dominio = indirizzo.split('@')
\end{verbatim}
%
Il valore di ritorno di {\tt split} è una lista con due elementi; il primo è assegnato alla variabile {\tt nome}, il secondo a {\tt dominio}.

\begin{verbatim}
>>> print nome
monty
>>> print dominio
python.org
\end{verbatim}
%

\section{Tuple come valori di ritorno}
\index{tupla}
\index{valore!tupla}
\index{valore di ritorno!tupla}
\index{funzione!tupla come valore di ritorno}

In senso stretto, una funzione può restituire un solo valore di ritorno, ma se il valore è una tupla, l'effetto pratico è quello di restituire valori molteplici. Per esempio, se volete dividere due interi e calcolare quoziente e resto, è poco efficiente calcolare {\tt x/y} e poi {\tt x\%y}.  Meglio calcolarli entrambi in una volta sola.
\index{divmod}

La funzione predefinita {\tt divmod} riceve due argomenti e restituisce una tupla di due valori, il quoziente e il resto. E potete memorizzare il risultato con una tupla:

\begin{verbatim}
>>> t = divmod(7, 3)
>>> print t
(2, 1)
\end{verbatim}
%
Oppure, usate l'assegnazione di tupla per conservare gli elementi separatamente:
\index{tupla!assegnazione}
\index{assegnazione!tupla}

\begin{verbatim}
>>> quoziente, resto = divmod(7, 3)
>>> print quoziente
2
>>> print resto
1
\end{verbatim}
%
Ecco un esempio di funzione che restituisce una tupla:

\begin{verbatim}
def min_max(t):
    return min(t), max(t)
\end{verbatim}
%
{\tt max} e {\tt min} sono funzioni predefinite che estraggono da una sequenza il valore massimo e quello minimo.  \verb"min_max" li estrae entrambi e restituisce una tupla di due valori.
\index{max, funzione}
\index{funzione!max}
\index{min, funzione}
\index{funzione!min}


\section{Tuple di argomenti a lunghezza variabile}
\index{lunghezza variabile, tupla di argomenti}
\index{argomento!tupla di lunghezza variabile}
\index{raccolta}
\index{parametro!raccolta}
\index{argomento!raccolta}

Le funzioni possono ricevere un numero variabile di argomenti. Un nome di parametro che comincia con {\tt *}, {\bf raccoglie} gli argomenti in una tupla. Per esempio, {\tt stampatutti} riceve un qualsiasi numero di argomenti e li visualizza:

\begin{verbatim}
def stampatutti(*args):
    print args
\end{verbatim}
%
Il parametro di raccolta può avere qualunque nome, ma per convenzione si usa {\tt args}. Ecco come funziona:

\begin{verbatim}
>>> stampatutti(1, 2.0, '3')
(1, 2.0, '3')
\end{verbatim}
%
Il contrario della raccolta è l'{\bf esplosione}.  Se avete una sequenza di valori e volete passarla a una funzione come argomenti multipli, usate ancora
 l'operatore {\tt *}. Per esempio, {\tt divmod} richiede esattamente due argomenti; passare una tupla non funziona:

% removing this because we haven't seen optional parameters yet
%You can combine the gather operator with required and positional
%arguments:

%%\begin{verbatim}
%def pointless(required, optional=0, *args):
%    print required, optional, args
%\end{verbatim}
%\afterverb
%
%Run this function with 1, 2, 3 and 4 or more arguments and
%make sure you understand what it does.
\index{esplosione}
\index{argomento!esplosione}
\index{TypeError}
\index{eccezione!TypeError}

\begin{verbatim}
>>> t = (7, 3)
>>> divmod(t)
TypeError: divmod expected 2 arguments, got 1
\end{verbatim}
%
Ma se esplodete la tupla, funziona:

\begin{verbatim}
>>> divmod(*t)
(2, 1)
\end{verbatim}
%
\vspace{0.2in}
\begin{exercise}

Molte funzioni predefinite possono usare le tuple di argomenti a lunghezza variabile. Ad esempio, {\tt max} e {\tt min} ricevono un numero qualunque di argomenti:
\index{max, funzione}
\index{funzione!max}
\index{min, funzione}
\index{funzione!min}

\begin{verbatim}
>>> max(1,2,3)
3
\end{verbatim}
%
Ma con {\tt sum} non funziona.
\index{sum, funzione}
\index{funzione!sum}

\begin{verbatim}
>>> sum(1,2,3)
TypeError: sum expected at most 2 arguments, got 3
\end{verbatim}
%
Scrivete una funzione di nome {\tt sommatutto} che riceva un numero di argomenti a piacere e ne restituisca la somma.

\end{exercise}


\section{Liste e tuple}
\index{zip, funzione}
\index{funzione!zip}

{\tt zip} è una funzione predefinita che riceve due o più sequenze e le abbina in una lista di tuple, dove ciascuna tupla contiene un elemento di ciascuna sequenza.  In Python 3, {\tt zip} restituisce un iteratore di tuple, ma per la maggior parte degli scopi un iteratore si comporta come una lista.
\index{Python 3}

Questo esempio abbina una stringa e una lista:

\begin{verbatim}
>>> s = 'abc'
>>> t = [0, 1, 2]
>>> zip(s, t)
[('a', 0), ('b', 1), ('c', 2)]
\end{verbatim}
%
Il risultato è una lista di tuple, e ciascuna tupla contiene un carattere della stringa e il corrispondente elemento della lista.
\index{lista!di tuple}

Se le sequenze non sono della stessa lunghezza, il risultato ha la lunghezza di quella più corta:

\begin{verbatim}
>>> zip('Anna', 'Edi')
[('A', 'E'), ('n', 'd'), ('n', 'i')]
\end{verbatim}
%
Potete usare l'assegnazione di tupla in un ciclo {\tt for} per attraversare una lista di tuple:
\index{attraversamento}
\index{tupla!assegnazione}
\index{assegnazione!tupla}

\begin{verbatim}
t = [('a', 0), ('b', 1), ('c', 2)]
for lettera, numero in t:
    print numero, lettera
\end{verbatim}
%
Ad ogni ciclo, Python seleziona la tupla successiva all'interno della lista e ne assegna gli elementi a {\tt lettera} e {\tt numero}, quindi li stampa.  Il risultato di questo ciclo è:
\index{ciclo}

\begin{verbatim}
0 a
1 b
2 c
\end{verbatim}
%
Se combinate {\tt zip}, {\tt for} e assegnazione di tupla, ottenete un utile costrutto per attraversare due o più sequenze contemporaneamente. Per esempio, \verb"corrispondenza" prende due sequenze, {\tt t1} e
{\tt t2}, e restituisce {\tt True} se esiste almeno un indice {\tt i}
tale che {\tt t1[i] == t2[i]}:
\index{for, ciclo}

\begin{verbatim}
def corrispondenza(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
\end{verbatim}
%
Se volete attraversare gli elementi di una sequenza e i loro indici, potete usare la funzione predefinita {\tt enumerate}:
\index{attraversamento}
\index{enumerate, funzione}
\index{funzione!enumerate}

\begin{verbatim}
for indice, elemento in enumerate('abc'):
    print indice, elemento
\end{verbatim}
%
Il risultato del ciclo è ancora:

\begin{verbatim}
0 a
1 b
2 c
\end{verbatim}
%



\section{Dizionari e tuple}
\label{dictuple}
\index{dizionario}
\index{items, metodo}
\index{metodo!items}
\index{chiave-valore, coppia}

I dizionari hanno un metodo di nome {\tt items} che restituisce una lista di tuple, dove ogni tupla è una delle coppie chiave-valore.

\begin{verbatim}
>>> d = {'a':0, 'b':1, 'c':2}
>>> t = d.items()
>>> print t
[('a', 0), ('c', 2), ('b', 1)]
\end{verbatim}
%
Come di consueto nei dizionari, gli elementi non sono in un ordine particolare. In Python 3, {\tt items} restituisce un iteratore, ma per la maggior parte degli scopi gli iteratori si comportano come le liste.

Per altro verso, potete usare una lista di tuple per inizializzare un nuovo dizionario: \index{dizionario!inizializzazione}

\begin{verbatim}
>>> t = [('a', 0), ('c', 2), ('b', 1)]
>>> d = dict(t)
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}

La combinazione di {\tt dict} e {\tt zip} produce un modo conciso di creare un dizionario:
\index{zip, funzione!uso con dict}

\begin{verbatim}
>>> d = dict(zip('abc', range(3)))
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}
%
Anche il metodo dei dizionari {\tt update} prende una lista di tuple e le aggiunge, come coppie chiave-valore, a un dizionario esistente.
\index{update, metodo}
\index{metodo!update}
\index{attraversamento!dizionario}
\index{dizionario!attraversamento}

Mettendo assieme {\tt items}, assegnazione di tupla e {\tt for}, ottenete un costrutto per attraversare chiavi e valori di un dizionario:

\begin{verbatim}
for chiave, valore in d.items():
    print valore, chiave
\end{verbatim}
%
L'output di questo ciclo è nuovamente:

\begin{verbatim}
0 a
2 c
1 b
\end{verbatim}
%

L'uso delle tuple come chiavi di un dizionario è frequente (soprattutto perché le liste non si possono usare in quanto mutabili). Per esempio, un elenco telefonico può mappare da coppie di nomi e cognomi ai numeri di telefono. Supponendo di aver definito {\tt cognome}, {\tt nome} e {\tt numero}, possiamo scrivere:
\index{tupla!come chiave di dizionario}
\index{hash-abile}

\begin{verbatim}
elenco[cognome,nome] = numero
\end{verbatim}
%
L'espressione tra parentesi quadre è una tupla. Possiamo usare l'assegnazione di tupla per attraversare questo dizionario.
\index{tupla!in parentesi quadre}

\begin{verbatim}
for cognome, nome in elenco:
    print nome, cognome, elenco[cognome,nome]
\end{verbatim}
%
Questo ciclo attraversa le chiavi in {\tt elenco}, che sono tuple. Assegna gli elementi di ogni tupla a {\tt cognome} e {\tt nome}, quindi stampa il nome completo e il numero di telefono corrispondente.

Ci sono due modi per rappresentare le tuple in un diagramma di stato. La versione più dettagliata mostra gli indici e gli elementi così come compaiono in una lista. Per esempio la tupla \verb"('Cleese', 'John')" comparirebbe come in Figura~\ref{fig.tuple1}.
\index{diagramma!di stato}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/tuple1.pdf}}
\caption{Diagramma di stato.}
\label{fig.tuple1}
\end{figure}

Ma in un diagramma più ampio è meglio tralasciare i dettagli. Per esempio, quello dell'elenco telefonico può essere come in Figura~\ref{fig.dict2}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/dict2.pdf}}
\caption{Diagramma di stato.}
\label{fig.dict2}
\end{figure}

Qui le tuple sono mostrate usando la sintassi di Python come abbreviazione grafica.

Il numero di telefono nel diagramma è quello dei reclami della BBC, per cui vi prego, non chiamatelo.



\section{Confrontare tuple}
\index{confronto!tupla}
\index{tupla!confronto}
\index{sort, metodo}
\index{metodo!sort}

Gli operatori di confronto funzionano con le tuple e le altre sequenze; Python inizia a confrontare il primo elemento di ciascuna sequenza. Se sono uguali, passa all'elemento successivo e così via, finché non trova due elementi diversi. Gli eventuali elementi che seguono vengono trascurati (anche se sono molto grandi).

\begin{verbatim}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
\end{verbatim}
%
Il metodo {\tt sort} funziona nello stesso modo. Ordina innanzitutto basandosi sul primo elemento, ma in caso di uguaglianza ordina in base al secondo elemento, e così via. 

Questa caratteristica conduce a uno schema di calcolo detto {\bf DSU} [acronimo dell'inglese Decorate-Sort-Undecorate, NdT] che:

\begin{description}

\item[Decora] una sequenza, creando una lista di tuple contenenti una o più chiavi di ordinamento che precedono gli elementi della sequenza,

\item[Ordina] la lista di tuple e

\item[Rimuove] la decorazione, estraendo gli elementi ordinati della sequenza.

\end{description}

\label{DSU}
\index{DSU, schema}
\index{schema!DSU}
\index{decorate-sort-undecorate, schema}
\index{schema!decorate-sort-undecorate}

Per esempio, supponiamo di avere una lista di parole e di volerle ordinare dalla più lunga alla più corta:

\begin{verbatim}
def ordina_lungh(parole):
    t = []
    for parola in parole:
       t.append((len(parola), parola))

    t.sort(reverse=True)

    res = []
    for lunghezza, parola in t:
        res.append(parola)
    return res
\end{verbatim}
%
Il primo ciclo crea una lista di tuple, dove ogni tupla contiene una parola preceduta dalla sua lunghezza.

{\tt sort} confronta dapprima il primo elemento, la lunghezza, e prende in considerazione il secondo, la parola, solo per risolvere i casi di parità. L'argomento con nome {\tt reverse=True} dice a {\tt sort} di procedere in ordine decrescente.
\index{argomento!con nome}
\index{attraversamento}

Il secondo ciclo attraversa la lista di tuple ordinata, e crea una nuova lista delle parole in ordine decrescente.

\vspace{0.2in}
\begin{exercise}

In questo esempio, i casi di pari lunghezza vengono risolti confrontando l'ordine delle parole, per cui parole di uguale lunghezza compaiono in ordine alfabetico inverso. Per altre applicazioni, si può preferire un criterio casuale. Modificate questo esempio in modo che le parole di uguale lunghezza compaiano in ordine casuale. Suggerimento: vedere la funzione {\tt random} nel modulo {\tt random}.
Soluzione: \url{http://thinkpython.com/code/unstable_sort.py}.

\index{random, modulo}
\index{modulo!random}
\index{random, funzione}
\index{funzione!random}

\end{exercise}


\section{Sequenze di sequenze}
\index{sequenza}

Ci siamo concentrati finora sulle liste di tuple, ma quasi tutti gli esempi di questo capitolo funzionano anche con liste di liste, tuple di tuple, e tuple di liste. Per evitare di elencare tutte le possibili combinazioni, è più semplice usare il termine sequenze di sequenze.

In molti casi, i diversi tipi di sequenze (strighe, liste, tuple) possono essere intercambiabili. E allora, come e perché scegliere di usarne una piuttosto di un'altra?
\index{stringa}
\index{lista}
\index{tupla}
\index{mutabilità}
\index{immutabilità}

Le stringhe sono ovviamente le più limitate, perché gli elementi devono essere dei caratteri. E sono anche immutabili. Se dovete cambiare i caratteri in una stringa, anziché crearne una nuova, utilizzare una lista di caratteri può essere una scelta migliore.

Le liste sono usate più di frequente delle tuple, soprattutto perché sono mutabili. Ma ci sono alcuni casi in cui le tuple sono preferibili:

\begin{enumerate}

\item In certi contesti, come un'istruzione {\tt return}, è sintatticamente più semplice creare una tupla anziché una lista. In altri contesti, è preferibile una lista.

\item Se vi serve una sequenza da usare come chiave di un dizionario, dovete per forza usare un tipo immutabile come una tupla o una stringa.

\item Se state passando una sequenza come argomento a una funzione, usare le tuple riduce le possibilità di comportamenti imprevisti dovuti agli alias.

\end{enumerate}

Siccome le tuple sono immutabili, non possiedono metodi come {\tt sort} e {\tt reverse}, che modificano delle liste esistenti.
Però Python contiene le funzioni {\tt sorted} e {\tt reversed}, che richiedono come parametro qualsiasi sequenza e restituiscono una nuova lista con gli stessi elementi in ordine diverso.
\index{sorted, funzione}
\index{funzione!sorted}
\index{reversed, funzione}
\index{funzione!reversed}


\section{Debug}
\index{debug}
\index{struttura di dati}
\index{formato, errore di}
\index{errore!di formato}

Liste, dizionari e tuple sono chiamate genericamente {\bf strutture di dati}; in questo capitolo abbiamo iniziato a vedere strutture di dati composte, come liste di tuple, e dizionari che contengono tuple come chiavi e liste come valori. Si tratta di elementi utili, ma soggetti a quelli che io chiamo {\bf errori di formato}; cioè errori causati dal fatto che una struttura di dati è di tipo, dimensione o composizione sbagliati. Ad esempio, se un programma si aspetta una lista che contiene un numero intero e invece gli passate un intero puro e semplice (non incluso in una lista), non funzionerà.
\index{structshape, modulo}
\index{modulo!structshape}

% TODO: structshape is now part of Swampy

Per facilitare il debug di questo genere di errori, ho scritto un modulo di nome {\tt structshape} che contiene una funzione, anch'essa di nome
{\tt structshape}, che riceve come argomento una qualunque struttura di dati e restituisce una stringa che ne riassume il formato. Potete scaricarlo dal sito \url{http://thinkpython.com/code/structshape.py}

Questo è il risultato per una lista semplice:

\begin{verbatim}
>>> from structshape import structshape
>>> t = [1,2,3]
>>> print structshape(t)
list of 3 int
\end{verbatim}
%
Un programma più aggraziato avrebbe scritto ``list of 3 int{\em s}'', ma è più semplice non avere a che fare con i plurali. Ecco una lista di liste:

\begin{verbatim}
>>> t2 = [[1,2], [3,4], [5,6]]
>>> print structshape(t2)
list of 3 list of 2 int
\end{verbatim}
%
Se gli elementi della lista non sono dello stesso tipo,
{\tt structshape} li raggruppa, in ordine, per tipo:

\begin{verbatim}
>>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
>>> print structshape(t3)
list of (3 int, float, 2 str, 2 list of int, int)
\end{verbatim}
%
Ecco una lista di tuple:

\begin{verbatim}
>>> s = 'abc'
>>> lt = zip(t, s)
>>> print structshape(lt)
list of 3 tuple of (int, str)
\end{verbatim}
%
Ed ecco un dizionario di 3 elementi in cui corrispondono interi a stringhe

\begin{verbatim}
>>> d = dict(lt) 
>>> print structshape(d)
dict of 3 int->str
\end{verbatim}
%
Se fate fatica a tenere sotto controllo le vostre strutture di dati,
{\tt structshape} può esservi di aiuto.


\section{Glossario}

\begin{description}

\item[tupla:] Una sequenza di elementi immutabile.
\index{tupla}

\item[assegnazione di tupla:] Assegnazione costituita da una sequenza sul lato destro e una tupla di variabili su quello sinistro. Il lato destro viene valutato, quindi gli elementi vengono assegnati alle variabili sulla sinistra.
\index{tupla!assegnazione}
\index{assegnazione!tupla}

\item[raccolta:] L'operazione di assemblare una tupla di argomenti a lunghezza variabile.
\index{raccolta}

\item[esplosione:] L'operazione di trattare una sequenza come una lista di argomenti.
\index{esplosione}

\item[DSU:] Acronimo di ``Decorate-Sort-Undecorate'', uno schema che comporta la costruzione di una lista di tuple, il suo ordinamento, e l'estrazione di parte dei risultati.
\index{DSU, schema}

\item[struttura di dati:] Una raccolta di valori correlati, spesso organizzati in liste, dizionari, tuple, ecc.
\index{struttura di dati}

\item[formato (di una struttura di dati):] Un riassunto di tipo, dimensione e composizione di una struttura di dati.
\index{formato}

\end{description}


\section{Esercizi}

\begin{exercise}

Scrivete una funzione di nome \verb"piu_frequente" che riceva una stringa e stampi le lettere in ordine di frequenza decrescente. Trovate delle frasi di esempio in diverse lingue e osservate come varia la frequenza delle lettere. Confrontate i vostri risultati con le tabelle del sito
\url{http://en.wikipedia.org/wiki/Letter_frequencies}.  Soluzione:
\url{http://thinkpython.com/code/most_frequent.py}.  
\index{lettere!frequenza} 
\index{frequenza!di lettere}

\end{exercise}


\begin{exercise}
\label{anagrams}
\index{anagramma, insieme}
\index{insieme!anagramma}

Ancora anagrammi!

\begin{enumerate}

\item Scrivete un programma che legga un elenco di parole da un file (vedi Paragrafo~\ref{wordlist}) e stampi tutti gli insiemi di parole che sono tra loro anagrammabili.

Un esempio di come si può presentare il risultato:

\begin{verbatim}
['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
\end{verbatim}
%
Suggerimento: potete costruire un dizionario che faccia corrispondere un insieme di lettere con una lista di parole che si possono scrivere con quelle lettere. Il problema è: come rappresentare gli insiemi di lettere in modo che possano essere usati come chiave?

\item Modificate il programma in modo che stampi l'insieme di anagrammi più numeroso per primo, seguito dal secondo, e così via.
\index{Scarabeo}

\item Nel gioco Scarabeo, fate un ``en-plein'' quando giocate tutte le sette lettere sul vostro leggio formando, insieme a una lettera sul tavolo, una parola di otto lettere. Con quale gruppo di 8 lettere si può fare un ``en-plein'' con maggior probabilità?
Suggerimento: il gruppo dà sette combinazioni.

% (7, ['angriest', 'astringe', 'ganister', 'gantries', 'granites',
% 'ingrates', 'rangiest'])

Soluzione: \url{http://thinkpython.com/code/anagram_sets.py}.

\end{enumerate}
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{metatesi}

Si ha una metatesi quando una parola si può ottenere scambiando due lettere di un'altra parola, per esempio, ``conversa'' e ``conserva''.  Scrivete un programma che trova tutte le coppie con metatesi nel dizionario. Suggerimento: non provate tutte le possibili coppie di parole e non provate tutti i possibili scambi. Soluzione: \url{http://thinkpython.com/code/metathesis.py}.
Fonte: Esercizio suggerito da un esempio nel sito \url{http://puzzlers.org}.

\end{exercise}


\vspace{0.2in}
\begin{exercise}
\index{Car Talk}
\index{Puzzler}

Ed ecco un altro quesito di Car Talk:
(\url{http://www.cartalk.com/content/puzzlers}):

\begin{quote}
Qual è la più lunga parola inglese che rimane una parola valida se le togliete una lettera alla volta? 
Le lettere possono essere rimosse sia agli estremi o in mezzo, ma senza spostare le lettere rimanenti. Ogni volta che togliete una lettera, ottenete un'altra parola inglese. Se andate avanti, ottenete un'altra parola. Ora, voglio sapere qual è la parola più lunga possibile e quante lettere ha.

Vi faccio un piccolo esempio: Sprite. Partite da sprite, togliete una lettera, una interna, come la r e resta la parola spite, poi togliete la e finale e avete spit, togliamo la s e resta pit, poi it, infine I.
\end{quote}
\index{parola, riducibile}

Scrivete un programma che trovi tutte le parole che sono riducibili in questa maniera, quindi trovate la più lunga.

Questo esercizio è un po' più impegnativo degli altri, quindi eccovi alcuni suggerimenti:

\begin{enumerate}

\item Potete scrivere una funzione che prenda una parola e calcoli una lista di tutte le parole che si possono formare togliendo una lettera. Queste sono le ``figlie'' della parola.
\index{definizione!ricorsiva}

\item Ricorsivamente, una parola è riducibile se qualcuna delle sue figlie è a sua volta riducibile. Come caso base, potete considerare riducibile la stringa vuota.

\item L'elenco di parole che ho fornito, {\tt words.txt}, non contiene parole di una lettera. Potreste quindi aggiungere ``I'', ``a'', e la stringa vuota.

\item Per migliorare le prestazioni del programma, potete memoizzare le parole che sono risultate riducibili.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/reducible.py}.

\end{exercise}




%\begin{exercise}
%\url{http://en.wikipedia.org/wiki/Word_Ladder}
%\end{exercise}




\chapter{Esercitazione: Scelta della struttura di dati}

\section{Analisi di frequenza delle parole}
\label{analysis}

Come al solito, tentate almeno di risolvere i seguenti esercizi prima di leggere le mie risoluzioni.

\vspace{0.2in}
\begin{exercise}

Scrivete un programma che legga un file, separi ogni riga in singole parole, scarti gli spazi bianchi e la punteggiatura dalle parole, e converta tutto in lettere minuscole.
\index{string, modulo}
\index{modulo!string}

Suggerimento: il modulo {\tt string} fornisce delle stringhe chiamate {\tt whitespace}, che contiene i caratteri spaziatori come spazio, tabulazione, a capo ecc., e {\tt punctuation} che contiene i caratteri di punteggiatura. Vediamo se Python ce lo conferma:

\begin{verbatim}
>>> import string
>>> print string.punctuation
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\end{verbatim}
%
Potete anche fare uso dei metodi delle stringhe {\tt strip},
{\tt replace} e {\tt translate}.
\index{strip, metodo}
\index{metodo!strip}
\index{replace, metodo}
\index{metodo!replace}
\index{translate, metodo}
\index{metodo!translate}

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{Progetto Gutenberg}

Andate sul sito del Progetto Gutenberg (\url{http://gutenberg.org}) e scaricate il libro fuori copyright che preferite, in formato di testo semplice.
\index{testo!semplice}

Modificate il programma dell'esercizio precedente in modo che legga il libro da voi scaricato, salti le informazioni di intestazione all'inizio del file, ed elabori il resto come sopra.

Quindi modificate il programma in modo che conti il numero di parole totale del libro, e quante volte è usata ciascuna parola.
\index{parola, frequenza}
\index{frequenza!di parole}

Visualizzate il numero di parole diverse usate nel libro. Confrontate libri diversi di diversi autori, scritti in epoche diverse. Quale autore usa il vocabolario più ricco?
\end{exercise}

\vspace{0.2in}
\begin{exercise}

Modificate il programma dell'esercizio precedente in modo da visualizzare le 20 parole più usate nel libro.

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Modificate il programma precedente in modo che acquisisca un elenco di parole (vedi Paragrafo~\ref{wordlist}) e quindi stampi l'elenco delle parole nel libro che non sono nell'elenco. Quante di esse sono errori di stampa? Quante sono parole comuni che {\em dovrebbero} essere nell'elenco, e quante sono del tutto oscure?

\end{exercise}


\section{Numeri casuali}
\index{numero casuale}
\index{deterministico}
\index{pseudocasuale}

A parità di dati di partenza, la maggior parte dei programmi fanno la stessa cosa ogni volta che vengono eseguiti, e per questo motivo sono detti  deterministici. Di solito il determinismo è una buona cosa, in quanto dagli stessi dati in ingresso è logico aspettarsi sempre lo stesso risultato. Per alcune applicazioni, invece, serve che l'esecuzione sia imprevedibile: i videogiochi sono un esempio lampante, ma ce ne sono tanti altri.

Creare un programma realmente non-deterministico è una cosa piuttosto difficile, ma ci sono dei sistemi per renderlo almeno apparentemente non-deterministico. Uno di questi è utilizzare degli algoritmi che generano dei numeri {\bf pseudocasuali}. Questi numeri non sono veri numeri casuali, dato che sono generati da un elaboratore deterministico, ma a prima vista è praticamente impossibile distinguerli da numeri casuali.
\index{random, modulo}
\index{modulo!random}

Il modulo {\tt random} contiene delle funzioni che generano numeri pseudocasuali (d'ora in avanti chiamati ``casuali'' per semplicità).
\index{random, funzione}
\index{funzione!random}

La funzione {\tt random} restituisce un numero casuale in virgola mobile compreso nell'intervallo tra 0.0 e 1.0 (incluso 0.0 ma escluso 1.0).  Ad ogni chiamata di {\tt random}, si ottiene il numero successivo di una lunga serie di numeri casuali. Per vedere un esempio provate ad eseguire questo ciclo:

\begin{verbatim}
import random

for i in range(10):
    x = random.random()
    print x
\end{verbatim}
%
La funzione {\tt randint} richiede due parametri interi, uno  {\tt inferiore} e uno  {\tt superiore}, e restituisce un intero casuale nell'intervallo tra i due parametri (entrambi compresi)
\index{randint, funzione}
\index{funzione!randint}

\begin{verbatim}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
\end{verbatim}
%
Per estrarre un elemento a caso da una sequenza, potete usare
{\tt choice}:
\index{choice, funzione}
\index{funzione!choice}

\begin{verbatim}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
\end{verbatim}
%
Il modulo {\tt random} contiene anche delle funzioni per generare valori pseudocasuali da distribuzioni continue, incluse gaussiane, esponenziali, gamma, e alcune altre.

\vspace{0.2in}
\begin{exercise}
\index{istogramma!scelta casuale}

Scrivete una funzione di nome \verb"estrai_da_isto" che prenda un istogramma come definito nel Paragrafo~\ref{histogram} e restituisca un valore casuale dall'istogramma, scelto in modo che la probabilità sia proporzionale alla frequenza. Per esempio, dato questo istogramma:

\begin{verbatim}
>>> t = ['a', 'a', 'b']
>>> isto = istogramma(t)
>>> print isto
{'a': 2, 'b': 1}
\end{verbatim}
%
la vostra funzione dovrebbe restituire {\tt 'a'} con probabilità $2/3$ e {\tt 'b'} con probabilità $1/3$.
\end{exercise}


\section{Istogramma di parole}

Provate a risolvere gli esercizi precedenti prima di procedere oltre. Le soluzioni sono scaricabili da
 \url{http://thinkpython.com/code/analyze_book.py}.  Vi servirà anche \url{http://thinkpython.com/code/emma.txt}.

Ecco un programma che legge un file e costruisce un istogramma della parole in esso contenute:
\index{istogramma!frequenza delle parole}

\begin{verbatim}
import string

def elabora_file(nomefile):
    isto = dict()
    fp = open(nomefile)
    for riga in fp:
        elabora_riga(riga, isto)
    return isto

def elabora_riga(riga, isto):
    riga = riga.replace('-', ' ')
    
    for parola in riga.split():
        parola = parola.strip(string.punctuation + string.whitespace)
        parola = parola.lower()

        isto[parola] = isto.get(parola, 0) + 1

isto = elabora_file('emma.txt')
\end{verbatim}
%
Questo programma legge il file {\tt emma.txt}, che contiene il testo di {\em
  Emma} di Jane Austen.
\index{Austin, Jane}

\verb"elabora_file" legge ciclicamente le righe del file, passandole una per volta a \verb"elabora_riga".  L'istogramma {\tt isto} viene usato come un accumulatore.
\index{accumulatore!istogramma}
\index{attraversamento}

\verb"elabora_riga" usa il metodo delle stringhe {\tt replace} per sostituire i trattini con gli spazi, prima di usare {\tt split} per suddividere la riga in una lista di stringhe. Attraversa poi la lista di parole e usa {\tt strip}
e {\tt lower} per togliere la punteggiatura e convertire in lettere minuscole. (Diciamo per semplicità che le stringhe sono ``convertite'': essendo queste immutabili, i metodi come {\tt strip} e {\tt lower} in realtà restituiscono nuove stringhe).

Infine, \verb"elabora_riga" aggiorna l'istogramma creando un nuovo elemento o incrementandone uno esistente.
\index{aggiornamento!istogramma}

Per contare il numero di parole totali, possiamo aggiungere le frequenze nell'istogramma:

\begin{verbatim}
def parole_totali(isto):
    return sum(isto.values())
\end{verbatim}
%
Il numero di parole diverse è semplicemente il numero di elementi nel dizionario:

\begin{verbatim}
def parole_diverse(isto):
    return len(isto)
\end{verbatim}
%
Ed ecco del codice per stampare i risultati:

\begin{verbatim}
print 'Numero totale di parole:', parole_totali(isto)
print 'Numero di parole diverse:', parole_diverse(isto)
\end{verbatim}
%
E i relativi risultati:

\begin{verbatim}
Numero totale di parole: 161080
Numero di parole diverse: 7214
\end{verbatim}
%

\section{Parole più comuni}
\index{DSU, schema}
\index{schema!DSU}

Per trovare le parole più comuni, possiamo applicare lo schema DSU;
\verb"piu_comuni" prende un istogramma e restituisce una lista di tuple parola-frequenza, ordinate in ordine di frequenza decrescente:

\begin{verbatim}
def piu_comuni(isto):
    t = []
    for chiave, valore in isto.items():
        t.append((valore, chiave))

    t.sort(reverse=True)
    return t
\end{verbatim}
%
Ecco un ciclo che stampa le dieci parole più comuni:

\begin{verbatim}
t = piu_comuni(hist)
print "Le parole piu' comuni sono:"
for freq, parola in t[0:10]:
    print parola, '\t', freq
\end{verbatim}
%
E questi sono i risultati nel caso di {\em Emma}:

\begin{verbatim}
Le parole piu' comuni sono:
to 	5242
the 	5205
and 	4897
of 	4295
i 	3191
a 	3130
it 	2529
her 	2483
was 	2400
she 	2364
\end{verbatim}
%

\section{Parametri opzionali}
\index{parametro!opzionale}

Abbiamo visto funzioni predefinite e metodi che ricevono un numero variabile di argomenti. È possibile anche scrivere funzioni definite dall'utente con degli argomenti opzionali. Ad esempio, questa è una funzione che stampa le parole più comuni in un istogramma:

\begin{verbatim}
def stampa_piu_comuni(isto, num=10):
    t = piu_comuni(isto)
    print "Le parole piu' comuni sono:"
    for freq, parola in t[:num]:
        print parola, '\t', freq
\end{verbatim}

Il primo parametro è obbligatorio; il secondo è opzionale. Il {\bf valore di default} di {\tt num} è 10.
\index{valore di default}

Se passate un solo argomento:

\begin{verbatim}
stampa_piu_comuni(isto)
\end{verbatim}

{\tt num} assume il valore predefinito. Se ne passate due:

\begin{verbatim}
stampa_piu_comuni(isto, 20)
\end{verbatim}

{\tt num} assume il valore che avete specificato. In altre parole, l'argomento opzionale {\bf sovrascrive} il valore predefinito.
\index{sovrascrittura}

Se una funzione ha sia parametri obbligatori che opzionali, tutti quelli obbligatori devono essere scritti per primi, seguiti da quelli opzionali.


\section{Sottrazione di dizionari}
\index{dizionario!sottrazione}
\index{sottrazione!dizionario}

Trovare le parole del libro non comprese nell'elenco {\tt words.txt} è un problema che possiamo classificare come sottrazione di insiemi, cioè occorre trovare le parole appartenenti a un insieme (le parole contenute nel libro) che non si trovano nell'altro insieme (l'elenco).

{\tt sottrai} prende i dizionari {\tt d1} e {\tt d2} e ne restituisce uno nuovo che contiene tutte le chiavi di {\tt d1} che non si trovano in {\tt d2}.  Siccome non ci interessano affatto i valori, li impostiamo tutti a None.

\begin{verbatim}
def sottrai(d1, d2):
    res = dict()
    for chiave in d1:
        if chiave not in d2:
            res[chiave] = None
    return res
\end{verbatim}
%
Quindi usiamo \verb"elabora_file" per costruire un istogramma di
{\tt words.txt}, per poi sottrarre:

\begin{verbatim}
parole = elabora_file('words.txt')
diff = sottrai(isto, parole)

print "Le parole del libro che non si trovano nell'elenco sono:"
for parola in diff.keys():
    print parola,
\end{verbatim}
%
Ecco alcuni dei risultati per {\em Emma}:

\begin{verbatim}
Le parole del libro che non si trovano nell'elenco sono:
 rencontre jane's blanche woodhouses disingenuousness 
friend's venice apartment ...
\end{verbatim}
%
Alcune parole sono nomi propri e possessivi. Altre come ``rencontre'' sono desuete. Ma qualcuna è davvero una parola comune che nell'elenco dovrebbe esserci!

\begin{exercise}
\index{insieme}
\index{tipo!set}

Python ha una struttura di dati chiamata {\tt set}, o insieme, che fornisce molte operazioni comuni sugli insiemi. Leggetene la documentazione sul sito  
\url{http://docs.python.org/2/library/stdtypes.html#types-set} e scrivete un programma che usi la sottrazione di insiemi per trovare le parole del libro che non sono nell'elenco. Soluzione:
\url{http://thinkpython.com/code/analyze_book2.py}.

\end{exercise}


\section{Parole a caso}
\label{randomwords}
\index{istogramma!scelta casuale}

Per scegliere una parola a caso dall'istogramma, l'algoritmo più semplice è  costruire una lista che contiene più copie di ciascuna parola, secondo la frequenza osservata, e poi estrarre a caso da questa lista:

\begin{verbatim}
def parola_caso(h):
    t = []
    for parola, freq in h.items():
        t.extend([parola] * freq)

    return random.choice(t)
\end{verbatim}
%
L'espressione {\tt [parola] * freq} crea una lista con {\tt freq}
copie della stringa {\tt parola}.  Il metodo {\tt extend}
è simile a {\tt append}, con la differenza che l'argomento è una sequenza.

\vspace{0.2in}
\begin{exercise}
\label{randhist}
\index{algoritmo}

Questo algoritmo funziona, ma non è molto efficiente: ogni volta che estraete una parola, ricostruisce la lista, che è grande come il libro originale. Un ovvio miglioramento è di costruire la lista una sola volta e poi fare estrazioni multiple, ma la lista è ancora grande.

Un'alternativa è:

\begin{enumerate}

\item Usare {\tt keys} per ottenere una lista delle parole del libro.

\item Costruire una lista che contiene la somma cumulativa delle frequenze delle parole (vedere l'Esercizio~\ref{cumulative}).  L'ultimo elemento della lista è il numero totale delle parole nel libro, $n$.
  
\item Scegliere un numero a caso da 1 a $n$.  Usare una ricerca binaria
  (vedere l'Esercizio~\ref{bisection}) per trovare l'indice dove il numero casuale si inserirebbe nella somma cumulativa.

\item Usare l'indice per trovare la parola corrispondente nella lista di parole.

\end{enumerate}

Scrivete un programma che usi questo algoritmo per scegliere una parola a caso dal libro. Soluzione: \url{http://thinkpython.com/code/analyze_book3.py}.

\end{exercise}



\section{Analisi di Markov}
\label{markov}
\index{Markov, analisi di}

Scegliendo a caso delle parole dal libro, potete avere un'idea del vocabolario usato dall'autore, ma difficilmente otterrete una frase di senso compiuto:

\begin{verbatim}
this the small regard harriet which knightley's it most things
\end{verbatim}
%
Una serie di parole estratte a caso raramente hanno senso, perché non esistono relazioni tra parole successive. In una frase, per esempio, è prevedibile che ad un articolo come ``il'' segua un aggettivo o un sostantivo, ma non un verbo o un avverbio.

Un modo per misurare questo tipo di relazioni è l'analisi di Markov che, per una data sequenza di parole, descrive la probabilità della parola che segue. Prendiamo la canzone dei Monty Python {\em Eric, the Half a Bee} che comincia così:

\begin{quote}
Half a bee, philosophically, \\
Must, ipso facto, half not be. \\
But half the bee has got to be \\
Vis a vis, its entity. D'you see? \\
\\
But can a bee be said to be \\
Or not to be an entire bee \\
When half the bee is not a bee \\
Due to some ancient injury? \\
\end{quote}
%
In questo testo, la frase ``half the'' è sempre seguita dalla parola ``bee,''
ma la frase ``the bee'' può essere seguita sia da
``has'' che da ``is''.
\index{prefisso}
\index{suffisso}
\index{mappatura}

Il risultato dell'analisi di Markov è una mappatura da ciascun prefisso
(come ``half the'' e ``the bee'') a tutti i possibili suffissi (come ``has'' e ``is'').
\index{testo!casuale}

Eseguita questa mappatura, potete generare un testo casuale partendo da qualunque prefisso e scegliendo a caso uno dei possibili suffissi. Poi, potete combinare la fine del prefisso e il nuovo suffisso per formare il successivo prefisso, e ripetere l'operazione.

Ad esempio, se partite con il prefisso ``Half a,'' la parola successiva sarà senz'altro ``bee,'' perché il prefisso compare solo una volta nel testo. Il prefisso successivo sarà ``a bee,'' quindi il suffisso successivo potrà essere ``philosophically'', ``be'' oppure ``due''.

In questo esempio, la lunghezza del prefisso è sempre di due parole, ma potete fare l'analisi di Markov con prefissi di qualunque lunghezza. La lunghezza del prefisso è detta ``ordine'' dell'analisi.

\vspace{0.2in}
\begin{exercise}

Analisi di Markov:

\begin{enumerate}

\item Scrivete un programma che legga un testo da un file ed esegua l'analisi di Markov. Il risultato dovrebbe essere un dizionario che fa corrispondere i prefissi a una raccolta di possibili suffissi. La raccolta può essere una lista, tupla o dizionario: a voi valutare la scelta più appropriata. Potete testare il vostro programma con una lunghezza del prefisso di due parole, ma dovreste scrivere il programma in modo da poter provare facilmente anche lunghezze superiori.

\item Aggiungete una funzione al programma precedente per generare un testo casuale basato sull'analisi di Markov. Ecco un esempio tratto da {\em Emma} con prefisso di lunghezza 2: 

\begin{quote}
He was very clever, be it sweetness or be angry, ashamed or only
amused, at such a stroke. She had never thought of Hannah till you
were never meant for me?" "I cannot make speeches, Emma:" he soon cut
it all himself.
\end{quote}

In questo esempio, ho lasciato la punteggiatura attaccata alle parole. Il risultato sintatticamente è quasi accettabile, ma non del tutto. Semanticamente, è quasi sensato, ma non del tutto.

Cosa succede se aumentate la lunghezza del prefisso? Il testo casuale è più sensato?
\index{minestrone}

\item Ottenuto un programma funzionante, potete tentare un ``minestrone'': se analizzate testi presi da due o più libri, il testo generato mescolerà il vocabolario e le frasi dei sorgenti in modi interessanti.

\end{enumerate}

Fonte: Questa esercitazione è tratta da un esempio in Kernighan e
Pike, {\em The Practice of Programming}, Addison-Wesley, 1999.

\end{exercise}

Cercate di svolgere questo esercizio prima di andare oltre; poi potete scaricare la mia soluzione dal sito \url{http://thinkpython.com/code/markov.py}.  Vi servirà anche \url{http://thinkpython.com/code/emma.txt}.


\section{Strutture di dati}
\index{struttura di dati}

Utilizzare l'analisi di Markov per generare testi casuali è divertente, ma c'è anche un obiettivo in questo esercizio: la scelta della struttura di dati. Per risolverlo, dovevate infatti scegliere:

\begin{itemize}

\item Come rappresentare i prefissi.

\item Come rappresentare la raccolta di possibili suffissi.

\item Come rappresentare la mappatura da ciascun prefisso alla raccolta di suffissi.

\end{itemize}

Ok, l'ultima è facile: il solo tipo in grado di mappare che abbiamo visto è il dizionario, quindi la scelta è scontata.

Per i prefissi, le possibili scelte sono: stringa, lista di stringhe o tuple di stringhe. Per i suffissi, un'opzione è una lista, l'altra è un istogramma (cioè un dizionario).
\index{implementazione}

Quale scegliere? Per prima cosa dovete chiedervi quali tipi di operazione dovete implementare per ciascuna struttura di dati. Per i prefissi, ci serve poter rimuovere le parole all'inizio e aggiungerne in coda. Per esempio, se il prefisso attuale è ``Half a,'' e la parola successiva è ``bee,'' dobbiamo essere in grado di formare il prefisso successivo, ``a bee''.
\index{tupla!come chiave di dizionario}

La prima ipotesi allora potrebbe essere una lista, dato che permette di aggiungere e rimuovere elementi in modo semplice, tuttavia abbiamo anche bisogno di usare i prefissi come chiavi di un dizionario, cosa che esclude le liste. Con le tuple non possiamo aggiungere o rimuovere, ma possiamo sempre usare l'operatore di addizione per formare una nuova tupla:

\begin{verbatim}
def cambia(prefisso, parola):
    return prefisso[1:] + (parola,)
\end{verbatim}
%
{\tt cambia} prende una tupla di parole, {\tt prefisso}, e una stringa, 
{\tt parola}, e forma una nuova tupla che comprende tutte le parole
in {\tt prefisso} tranne la prima, e {\tt parola} aggiunta alla fine.

Per la raccolta di suffissi, le operazioni che dobbiamo eseguire comprendono l'aggiunta di un nuovo suffisso (o l'incremento della frequenza di un suffisso esistente) e l'estrazione di un elemento a caso.

Aggiungere un nuovo suffisso è ugualmente semplice sia nel caso di implementazione di una lista sia di un istogramma. Estrarre un elemento da una lista è facile, da un istogramma difficile da fare in modo efficiente (vedere Esercizio~\ref{randhist}).

Sinora abbiamo considerato soprattutto la facilità di implementazione, ma ci sono altri fattori da tenere in considerazione nella scelta delle strutture di dati. Una è il tempo di esecuzione. A volte ci sono ragioni teoriche per attendersi che una struttura sia più veloce di un'altra; per esempio ho già accennato che l'operatore {\tt in} è più rapido nei dizionari che non nelle liste, almeno in presenza di un gran numero di elementi.

Ma spesso non è possibile sapere {\em a priori} quale implementazione sarà più veloce. Una scelta possibile è implementarle entrambe e provare quale si comporta meglio. Questo approccio è detto {\bf benchmarking}.  Un'alternativa pratica è quella di scegliere la struttura di dati più facile da implementare e vedere se è abbastanza veloce per quell'applicazione. Se è così, non c'è bisogno di andare oltre. Altrimenti, ci sono strumenti, come il modulo {\tt profile} che è in grado di segnalare i punti in cui il programma impiega la maggior parte del tempo.
\index{benchmarking}
\index{profile, modulo}
\index{modulo!profile}

Altro fattore da considerare è lo spazio di archiviazione. Ad esempio, usare un istogramma per la raccolta di suffissi può richiedere meno spazio, perché è necessario memorizzare ogni parola solo una volta, indipendentemente da quante volte compaia nel testo. In qualche caso, risparmiare spazio significa avere un programma più veloce; in casi estremi, il programma può non funzionare affatto se provoca l'esaurimento della memoria. Ma per molte applicazioni, lo spazio è di secondaria importanza rispetto al tempo di esecuzione.

Un'ultima considerazione: in questa discussione, era sottinteso che dovremmo usare una stessa struttura di dati sia per l'analisi che per la generazione. Ma siccome sono fasi separate, nulla vieta di usare un tipo di struttura per l'analisi e poi convertirlo in un'altra struttura per la generazione. Sarebbe un guadagno, se il tempo risparmiato durante la generazione superasse quello impiegato nella conversione.


\section{Debug}
\index{debug}

Quando fate il debug di un programma, e specialmente se state affrontando un bug ostico, ci sono quattro cose da provare:

\begin{description}

\item[leggere:] Esaminate il vostro codice, rileggetevelo e controllate che dica esattamente quello che voi intendete dire.

\item[eseguire:] Sperimentate facendo modifiche ed eseguendo le diverse versioni. Spesso, se nel programma visualizzate la cosa giusta al posto giusto, il problema diventa evidente, anche se talvolta dovrete spendere un po' di tempo per inserire qualche ``impalcatura''.

\item[rimuginare:] Prendetevi il tempo per pensarci su! Che tipo di errore è: di sintassi, di runtime o di semantica? Che informazioni si traggono dal messaggio di errore o dall'output del programma? Che tipo di errore potrebbe causare il problema che vedete? Quali modifiche avete fatto prima che si verificasse il problema?

\item[tornare indietro:] A un certo punto, la cosa migliore da fare è tornare sui vostri passi, annullare le ultime modifiche, fino a riottenere un programma funzionante e comprensibile. Poi potete rifare da capo.

\end{description}

I programmatori principianti a volte si fissano su uno di questi punti e tralasciano gli altri. Ciascuno di essi ha dei punti deboli.
\index{errore!di battitura}

Per esempio, leggere il codice va bene se il problema è un errore di battitura, ma non se c'è un fraintendimento concettuale. Se non capite cosa fa il vostro programma, potete leggerlo 100 volte senza riuscire a trovare l'errore, perché l'errore sta nella vostra testa.
\index{debug!sperimentale}

Fare esperimenti va bene, specie se si tratta di piccoli, semplici test. Ma se fate esperimenti senza pensare o leggere il codice, potete cascare in uno schema che io chiamo ``programmare a tentoni'', che significa fare tentativi a casaccio finché il programma non fa la cosa giusta. Inutile dirlo, questo può richiedere un sacco di tempo.
\index{tecnica di sviluppo!programmazione a tentoni}

Dovete prendervi il tempo di riflettere. Il debug è come una scienza sperimentale. Dovete avere almeno un'ipotesi di quale sia il problema. Se ci sono due o più possibilità, provate a elaborare un test che ne elimini una.

Prendersi una pausa aiuta a pensare. Come pure parlarne. Spiegando il problema a qualcun altro (o anche a voi stessi), talvolta si trova la risposta ancora prima di finire la domanda.

Ma anche le migliori tecniche di debug falliranno se ci sono troppi errori o se il codice che state cercando di sistemare è troppo grande e complesso. Allora l'opzione migliore è di tornare indietro e semplificare il programma, fino ad ottenere qualcosa di funzionante e che riuscite a capire.

I principianti spesso sono riluttanti a tornare sui loro passi e si spaventano all'idea di cancellare anche una singola riga di codice (anche se è sbagliata). Se vi fa sentire meglio, copiate il programma in un altro file prima di sfrondarlo, potrete così ripristinare i pezzi di codice un po' per volta.

Trovare un bug difficile richiede lettura, esecuzione, rimuginazione e a volte ritornare sui propri passi. Se rimanete bloccati su una di queste attività, provate le altre.


\section{Glossario}

\begin{description}

\item[deterministico:] Qualità di un programma di fare le stesse cose ogni volte che viene eseguito, a parità di dati di input.
\index{deterministico}

\item[pseudocasuale:] Detto di una sequenza di numeri che sembrano casuali, ma sono generati da un programma deterministico.
\index{pseudocasuale}

\item[valore di default:] Il valore predefinito di un parametro opzionale quando non viene specificato altrimenti.
\index{default, valore di}

\item[sovrascrivere:] Sostituire un valore di default con un argomento.
\index{sovrascrittura}

\item[benchmarking:] Procedura di scelta tra strutture di dati di vario tipo, implementando le alternative e provandole su un campione di possibili input.
\index{benchmarking}

\end{description}


\section{Esercizi}

\begin{exercise}
\index{frequenza!di parole}
\index{Zipf, legge di}

Il ``rango'' di una parola è la sua posizione in un elenco di parole ordinate in base alla frequenza: la parola più comune ha rango 1, la seconda più comune rango 2, ecc.

La legge di Zipf descrive una relazione tra rango e frequenza delle parole nei linguaggi naturali
(\url{http://it.wikipedia.org/wiki/Legge_di_Zipf}), in particolare predice che la frequenza, $f$, della parola di rango $r$ è:

\[ f = c r^{-s} \]
%
dove $s$ e $c$ sono parametri che dipendono dal linguaggio e dal testo. Logaritmizzando ambo i lati dell'equazione, si ottiene:
\index{logaritmo}

\[ \log f = \log c - s \log r \]
%
che rappresentata su un grafico con log $r$ in ascissa e log $f$ in ordinata, è una retta di coefficiente angolare $-s$ e termine noto log $c$.

Scrivete un programma che legga un testo da un file, conti le frequenza delle parole e stampi una riga per ogni parola, in ordine decrescente di frequenza, con i valori di log $f$ e log $r$.  Usate un programma a vostra scelta per costruire il grafico dei risultati e controllare se formano una retta. Riuscite a stimare il valore di $s$?

Soluzione: \url{http://thinkpython.com/code/zipf.py}.  Per i grafici potete eventualmente installare matplotlib (vedere
\url{http://matplotlib.sourceforge.net/}).
\index{Matplotlib}

\end{exercise}


\chapter{File}


\section{Persistenza}
\index{file}
\index{tipo!file}
\index{persistenza}

La maggior parte dei programmi che abbiamo visto finora sono transitori, nel senso che vengono eseguiti per breve tempo e producono un risultato, ma quando vengono chiusi i loro dati spariscono. Se rieseguite il programma, esso ricomincia da zero.

Altri programmi sono {\bf persistenti}: sono eseguiti per un lungo tempo (o di continuo); mantengono almeno una parte dei loro dati archiviati in modo permanente, come su un disco fisso; e se vengono arrestati e riavviati, riprendono il loro lavoro da dove lo avevano lasciato.

Esempi di programmi persistenti sono i sistemi operativi, eseguiti praticamente ogni volta che un computer viene acceso, e i web server, che lavorano di continuo in attesa di richieste provenienti dalla rete.

Per i programmi, uno dei modi più semplici di mantenere i loro dati è di leggerli e scriverli su file di testo. Abbiamo già visto qualche programma che legge dei file di testo; in questo capitolo ne vedremo alcuni che li scrivono.

Un'alternativa è conservare la situazione del programma in un database. In questo capitolo mostrerò un semplice database e un modulo, {\tt pickle}, che rende agevole l'archiviazione dei dati.
\index{pickle, modulo}
\index{modulo!pickle}


\section{Lettura e scrittura}
\index{file!lettura e scrittura}

Un file di testo è un una sequenza di caratteri salvata su un dispositivo permanente come un disco fisso, una memoria flash o un CD-ROM. Abbiamo già visto come aprire e leggere un file nel Paragrafo~\ref{wordlist}.
\index{open, funzione}
\index{funzione!open}

Per scrivere un file, lo dovete aprire indicando la modalità \verb"'w'" come secondo parametro:

\begin{verbatim}
>>> fout = open('output.txt', 'w')
>>> print fout
<open file 'output.txt', mode 'w' at 0xb7eb2410>
\end{verbatim}
%
Se il file esiste già, l'apertura in modalità scrittura lo ripulisce dai vecchi dati e riparte da zero, quindi fate attenzione! Se non esiste, ne viene creato uno nuovo.

Il metodo {\tt write} inserisce i dati nel file.

\begin{verbatim}
>>> riga1 = "E questa qui e' l'acacia,\n"
>>> fout.write(riga1)
\end{verbatim}
%
Come sempre, l'oggetto file tiene traccia di dove si trova, e se invocate ancora il metodo {\tt write} aggiunge i dati in coda al file.

\begin{verbatim}
>>> riga2 = "l'emblema della nostra terra.\n"
>>> fout.write(riga2)
\end{verbatim}
%
Quando avete finito di scrivere, dovete chiudere il file.

\begin{verbatim}
>>> fout.close()
\end{verbatim}
%
\index{close, metodo}
\index{metodo!close}


\section{L'operatore di formato}
\index{formato!operatore di}
\index{operatore!di formato}

L'argomento di {\tt write} deve essere una stringa, e se volessimo inserire valori di tipo diverso in un file dovremmo prima convertirli in stringhe. Il metodo più semplice per farlo è usare {\tt str}:

\begin{verbatim}
>>> x = 52
>>> f.write(str(x))
\end{verbatim}
%
Un'alternativa è utilizzare l'{\bf operatore di formato}, {\tt \%}.  Quando viene applicato agli interi, {\tt \%} rappresenta l'operatore modulo.  Ma se il primo operando è una stringa, {\tt \%} diventa l'operatore di formato.
\index{formato!stringa di}
\index{stringa!di formato}

Il primo operando è detto {\bf stringa di formato}, che contiene una o più {\bf sequenze di formato}, che specificano il formato del secondo operando. Il risultato è una stringa.
\index{formato!sequenza di}
\index{sequenza!di formato}

Per esempio, la sequenza di formato \verb"'%d'" significa che il secondo operando dovrebbe essere nel formato di numero intero ({\tt d} sta per ``decimale'', nel senso di sistema di numerazione):

\begin{verbatim}
>>> cammelli = 42
>>> '%d' % cammelli
'42'
\end{verbatim}
%
Il risultato è la stringa \verb"'42'", che non va confusa con il valore intero {\tt 42}.

Una sequenza di formato può comparire dovunque all'interno di una
   stringa, e così possiamo incorporare un valore in una frase:

\begin{verbatim}
>>> cammelli = 42
>>> 'Ho contato %d cammelli.' % cammelli
'Ho contato 42 cammelli.'
\end{verbatim}
%
Se nella stringa c'è più di una sequenza di formato, il secondo operando deve essere una tupla. Ciascuna sequenza di formato corrisponde a un elemento della tupla, nell'ordine.

L'esempio che segue usa \verb"'%d'" per formattare un intero,
\verb"'%g'" per formattare un decimale a virgola mobile (non chiedetemi perché), e \verb"'%s'" per formattare una stringa:

\begin{verbatim}
>>> 'In %d anni ho contato %g %s.' % (3, 0.1, 'cammelli')
'In 3 anni ho contato 0.1 cammelli.'
\end{verbatim}
%
Il numero degli elementi nella tupla deve naturalmente essere
   corrispondente a quello delle sequenze di formato nella stringa, ed i tipi degli elementi devono corrispondere a quelli delle sequenze di formato:
\index{eccezione!TypeError}
\index{TypeError}

\begin{verbatim}
>>> '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> '%d' % 'dollari'
TypeError: illegal argument type for built-in operation
\end{verbatim}
%
Nel primo esempio, non ci sono abbastanza elementi; nel secondo, l'elemento è del tipo sbagliato.

L'operatore di formato è potente, ma può essere difficile da usare. Per saperne di più: 
\url{http://docs.python.org/2/library/stdtypes.html#string-formatting}.

% You can specify the number of digits as part of the format sequence.
% For example, the sequence \verb"'%8.2f'"
% formats a floating-point number to be 8 characters long, with
% 2 digits after the decimal point:

% % \begin{verbatim}
% >>> '%8.2f' % 3.14159
% '    3.14'
% \end{verbatim}
% \afterverb
% %
% The result takes up eight spaces with two
% digits after the decimal point.  


\section{Nomi di file e percorsi}
\label{paths}
\index{file!nome}
\index{percorso}
\index{directory}
\index{cartella}

Il file sono organizzati in {\bf directory} (chiamate anche ``cartelle'').
Ogni programma in esecuzione ha una ``directory attuale'', che è la directory predefinita per la maggior parte delle operazioni che lo riguardano.
Ad esempio, quando aprite un file in lettura, Python lo cerca nella sua directory attuale.
\index{os, modulo}
\index{modulo!os}

Il modulo {\tt os} fornisce delle funzioni per lavorare con file e directory (``os'' sta per ``sistema operativo'').  {\tt os.getcwd} restituisce il nome della directory attuale:
\index{getcwd, funzione}
\index{funzione!getcwd}

\begin{verbatim}
>>> import os
>>> cwd = os.getcwd()
>>> print cwd
/home/dinsdale
\end{verbatim}
%
{\tt cwd} sta per ``{\em current working directory}'' (directory di lavoro attuale). 
Il risultato di questo esempio è {\tt /home/dinsdale}, che è la directory home di un utente di nome {\tt dinsdale}.
\index{lavoro, directory di}
\index{directory!di lavoro}

Una stringa come {\tt cwd} che localizza un file è chiamata {\bf percorso}.
Si distinguono un {\bf percorso relativo} che parte dalla directory attuale e un {\bf percorso assoluto} che parte dalla directory principale del file system.
\index{percorso!relativo}
\index{percorso!assoluto}

I percorsi visti finora sono semplici nomi di file, quindi sono percorsi relativi alla directory corrente. Per avere invece il percorso assoluto, potete usare {\tt os.path.abspath}:

\begin{verbatim}
>>> os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
\end{verbatim}
%
{\tt os.path.exists} controlla se un file o una cartella esistono:
\index{exists, funzione}
\index{funzione!exists}

\begin{verbatim}
>>> os.path.exists('memo.txt')
True
\end{verbatim}
%
Se esiste, {\tt os.path.isdir} controlla se è una directory:

\begin{verbatim}
>>> os.path.isdir('memo.txt')
False
>>> os.path.isdir('musica')
True
\end{verbatim}
%
Similmente, {\tt os.path.isfile} controlla se è un file.

{\tt os.listdir} restituisce una lista dei file e delle altre directory nella cartella indicata:

\begin{verbatim}
>>> os.listdir(cwd)
['musica', 'immagini', 'memo.txt']
\end{verbatim}
%
Per dimostrare l'uso di queste funzioni, l'esempio seguente
``esplora'' il contenuto di una directory, stampa il nome di tutti i file e si chiama ricorsivamente su tutte le sottodirectory.
\index{directory!esplorazione}

\begin{verbatim}
def esplora(dirnome):
    for nome in os.listdir(dirnome):
        percorso = os.path.join(dirnome, nome)

        if os.path.isfile(percorso):
            print percorso
        else:
            esplora(percorso)
\end{verbatim}
%
{\tt os.path.join} prende il nome di una directory e il nome di un file e li unisce a formare un percorso completo.  

\vspace{0.2in}
\begin{exercise}

Il modulo {\tt os} contiene una funzione di nome {\tt walk}
che è simile a questa ma più versatile. Leggetene la documentazione e usatela per stampare i nomi dei file di una data directory e delle sue sottodirectory. 

Soluzione: \url{http://thinkpython.com/code/walk.py}.

\end{exercise}


\section{Gestire le eccezioni}
\label{catch}

Parecchie cose possono andare male quando cercate di leggere e scrivere  file. Se cercate di aprire un file che non esiste, si verifica un
{\tt IOError}:
\index{open, funzione}
\index{funzione!open}
\index{eccezione!IOError}
\index{IOError}

\begin{verbatim}
>>> fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad_file'
\end{verbatim}
%
Se non avete il permesso di accedere al file:
\index{file!permesso}
\index{permesso, accesso a file}

\begin{verbatim}
>>> fout = open('/etc/passwd', 'w')
IOError: [Errno 13] Permission denied: '/etc/passwd'
\end{verbatim}
%
E se cercate di aprire una directory in lettura, ottenete:

\begin{verbatim}
>>> fin = open('/home')
IOError: [Errno 21] Is a directory
\end{verbatim}
%
Per evitare questi errori, potete usare funzioni come {\tt os.path.exists}
e {\tt os.path.isfile}, ma ci vorrebbe molto tempo e molto codice per controllare tutte le possibilità (se ``{\tt Errno 21}'' significa qualcosa, ci sono almeno 21 cose che possono andare male).
\index{eccezione, gestione}
\index{try, istruzione}
\index{istruzione!try}

È meglio allora andare avanti e provare---e affrontare i problemi quando si presentano---che è proprio quello che fa l'istruzione {\tt try}. La sintassi è simile a un'istruzione {\tt if}:

\begin{verbatim}
try:    
    fin = open('file_corrotto')
    for riga in fin:
        print riga
    fin.close()
except:
    print 'Qualcosa non funziona.'
\end{verbatim}
%
Python comincia con l'eseguire la clausola {\tt try}.  Se tutto va bene, tralascia la clausola {\tt except} e procede. Se si verifica un'eccezione, salta fuori dalla clausola {\tt try} e va ad eseguire la clausola {\tt except}.

Utilizzare in questo modo l'istruzione {\tt try} viene detto {\bf
gestire} un'eccezione. Nell'esempio precedente, la clausola {\tt except} stampa un messaggio di errore che non è di grande aiuto. In genere, gestire un'eccezione vi dà la possibilità di sistemare il problema, o riprovare, o per lo meno arrestare il programma in maniera morbida.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome {\tt sed} che richieda come argomenti una stringa modello, una stringa di sostituzione, e due nomi di file. La funzione deve leggere il primo file e scriverne il contenuto nel secondo file (creandolo se necessario). Se la stringa modello compare da qualche parte nel testo del file, deve sostituirla con la seconda stringa.

Se si verifica un errore in apertura, lettura, scrittura, chiusura del file, il vostro programma deve gestire l'eccezione, stampare un messaggio di errore e terminare. Soluzione: \url{http://thinkpython.com/code/sed.py}.

\end{exercise}


\section{Database}
\index{database}

Un {\bf database} è un file che è progettato per archiviare dati. La maggior parte dei database sono organizzati come un dizionario, nel senso che fanno una mappatura da chiavi a valori. La grande differenza è che i database risiedono su disco (o altro dispositivo permanente), e persistono quando il programma viene chiuso.
\index{anydbm, modulo}
\index{modulo!anydbm}

Il modulo {\tt anydbm} fornisce un'interfaccia per creare e aggiornare file di database. Come esempio, creerò un database che contiene le didascalie di alcuni file di immagini.
\index{open, funzione}
\index{funzione!open}

Un database si apre in modo simile agli altri file:

\begin{verbatim}
>>> import anydbm
>>> db = anydbm.open('didascalie.db', 'c')
\end{verbatim}
%
La modalità \verb"'c'" significa che il database deve essere creato se non esiste già. Il risultato è un oggetto database che può essere utilizzato (per la maggior parte delle operazioni) come un dizionario. Se create un nuovo elemento, {\tt anydbm} aggiorna il file di database.
\index{aggiornamento!di database}


\begin{verbatim}
>>> db['cleese.png'] = 'Foto di John Cleese.'
\end{verbatim}
%
Quando accedete a uno degli elementi, {\tt anydbm} legge il file:

\begin{verbatim}
>>> print db['cleese.png']
Foto di John Cleese.
\end{verbatim}
%
Se fate una nuova assegnazione a una chiave esistente, {\tt anydbm} sostituisce il vecchio valore:

\begin{verbatim}
>>> db['cleese.png'] = 'Foto di John Cleese che cammina in modo ridicolo.'
>>> print db['cleese.png']
Foto di John Cleese che cammina in modo ridicolo.
\end{verbatim}
%
Molti metodi dei dizionari, come {\tt keys} e {\tt items}, funzionano anche con gli oggetti database, come pure l'iterazione con un'istruzione {\tt for}.
\index{dizionario, metodi!anydbm, modulo}

\begin{verbatim}
for chiave in db:
    print chiave
\end{verbatim}
%
Come con gli altri file, dovete chiudere il database quando avete finito:

\begin{verbatim}
>>> db.close()
\end{verbatim}
%
\index{close, metodo}
\index{metodo!close}


\section{Pickling}
\index{pickling}

Un limite di {\tt anydbm} è che le chiavi e i valori devono essere delle stringhe. Se cercate di utilizzare qualsiasi altro tipo, si verifica un errore.
\index{pickle, modulo}
\index{modulo!pickle}

Il modulo {\tt pickle} può essere di aiuto. Trasforma quasi ogni tipo di oggetto in una stringa adatta per essere inserita in un database, e quindi ritrasforma la stringa in oggetto.

{\tt pickle.dumps} accetta un oggetto come parametro e ne restituisce una serializzazione, ovvero un rappresentazione sotto forma di una stringa ({\tt dumps} è l'abbreviazione di ``dump string'', scarica stringa):

\begin{verbatim}
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
'(lp0\nI1\naI2\naI3\na.'
\end{verbatim}
%
Il formato non è immediatamente leggibile: è progettato per essere facile da interpretare da parte di {\tt pickle}. In seguito, {\tt pickle.loads}
(``carica stringa'') ricostruisce l'oggetto:

\begin{verbatim}
>>> t1 = [1, 2, 3]
>>> s = pickle.dumps(t1)
>>> t2 = pickle.loads(s)
>>> print t2
[1, 2, 3]
\end{verbatim}
%
Sebbene il nuovo oggetto abbia lo stesso valore del vecchio, non è in genere lo stesso oggetto:

\begin{verbatim}
>>> t1 == t2
True
>>> t1 is t2
False
\end{verbatim}
%
In altre parole, fare una serializzazione con pickle e poi l'operazione inversa, ha lo stesso effetto di copiare l'oggetto.

Potete usare {\tt pickle} per archiviare in un database tutto ciò che non è una stringa. In effetti, questa combinazione è tanto frequente da essere stata incapsulata in un modulo chiamato {\tt shelve}.  
\index{shelve, modulo}
\index{modulo!shelve}

\vspace{0.2in}
\begin{exercise}
\index{anagramma, insieme}
\index{insieme!anagramma}

Se avete scaricato la mia soluzione dell'Esercizio~\ref{anagrams} dal sito
\url{http://thinkpython.com/code/anagram_sets.py}, avrete visto che crea un dizionario che fa corrispondere una stringa ordinata di lettere alla lista di parole che possono essere scritte con quelle lettere. Per esempio, {\tt   'opst'} corrisponde alla lista {\tt ['opts', 'post', 'pots', 'spot', 'stop', 'tops']}.

Scrivete un modulo che importi \verb"anagram_sets" e fornisca due nuove funzioni: \verb"arch_anagrammi" deve archiviare il dizionario di anagrammi in uno ``shelf''; \verb"leggi_anagrammi" deve cercare una parola e restituire una lista dei suoi anagrammi. Soluzione: \url{http://thinkpython.com/code/anagram_db.py}

\end{exercise}


\section{Pipe}
\index{shell}
\index{pipe}

Molti sistemi operativi forniscono un'interfaccia a riga di comando, nota anche come {\bf shell}.  Le shell sono dotate di comandi per spostarsi nel file system e per lanciare le applicazioni. Per esempio, in UNIX potete cambiare directory con il comando {\tt cd},
visualizzarne il contenuto con {\tt ls}, e lanciare un web browser scrivendone il nome, per esempio {\tt firefox}.
\index{ls (comando Unix)}
\index{comando Unix!ls}

Qualsiasi programma lanciabile dalla shell può essere lanciato anche da Python usando un {\bf pipe}, che è un oggetto che rappresenta un programma in esecuzione.

Ad esempio, il comando Unix {\tt ls -l} di norma mostra il contenuto della cartella attuale (in formato esteso). Potete lanciare {\tt ls} anche con {\tt os.popen}\footnote{{\tt popen} ora è deprecato, cioè siamo invitati a smettere di usarlo e ad iniziare ad usare invece il modulo {\tt subprocess}. Ma per i casi semplici, trovo che
{\tt subprocess} sia più complicato del necessario. Pertanto continuerò ad usare {\tt popen} finché non verrà rimosso definitivamente.}:
\index{popen, funzione}
\index{funzione!popen}

\begin{verbatim}
>>> cmd = 'ls -l'
>>> fp = os.popen(cmd)
\end{verbatim}
%
L'argomento è una stringa che contiene un comando shell. Il valore di ritorno è un oggetto che si comporta proprio come un file aperto. Potete leggere l'output del processo {\tt ls} una riga per volta con {\tt readline}, oppure ottenere tutto in una volta con {\tt read}:
\index{readline, metodo}
\index{metodo!readline}
\index{read, metodo}
\index{metodo!read}

\begin{verbatim}
>>> res = fp.read()
\end{verbatim}
%
Quando avete finito, chiudete il pipe come fosse un file:
\index{close, metodo}
\index{metodo!close}

\begin{verbatim}
>>> stat = fp.close()
>>> print stat
None
\end{verbatim}
%
Il valore di ritorno è lo stato finale del processo {\tt ls};
{\tt None} significa che si è chiuso normalmente (senza errori).

Altro esempio, in molti sistemi Unix il comando {\tt md5sum}
legge il contenuto di un file e ne calcola una checksum . Per saperne di più: \url{http://it.wikipedia.org/wiki/MD5}.  Questo comando è un mezzo efficiente per controllare se due file hanno lo stesso contenuto. La probabilità che due diversi contenuti diano la stessa checksum è piccolissima (per intenderci, è improbabile che succeda prima che l'universo collassi).
\index{md5}
\index{checksum}

Potete allora usare un pipe per eseguire {\tt md5sum} da Python e ottenere il risultato:

\begin{verbatim}
>>> nomefile = 'book.tex'
>>> cmd = 'md5sum ' + nomefile
>>> fp = os.popen(cmd)
>>> res = fp.read()
>>> stat = fp.close()
>>> print res
1e0033f0ed0656636de0d75144ba32e0  book.tex
>>> print stat
None
\end{verbatim}

\vspace{0.2in}
\begin{exercise}
\label{checksum}
\index{MP3}

In una grande raccolta di file MP3 possono esserci più copie della stessa canzone, messe in cartelle diverse o con nomi di file differenti. Scopo di questo esercizio è di ricercare i duplicati.

\begin{enumerate}

\item Scrivete un programma che cerchi in una cartella e, ricorsivamente, nelle sue sottocartelle, e restituisca un elenco dei percorsi completi di tutti i file con una stessa estensione (come {\tt .mp3}).
Suggerimento: {\tt os.path} contiene alcune funzioni utili per trattare nomi di file e percorsi.
\index{duplicato}
\index{md5, algoritmo}
\index{algoritmo!md5}
\index{checksum}

\item Per riconoscere i duplicati, potete usare {\tt md5sum}
per calcolare la ``checksum'' di ogni file. Se due file hanno la stessa checksum, significa che con ogni probabilità hanno lo stesso contenuto.
\index{md5sum}

\item Per effettuare un doppio controllo, usate il comando Unix {\tt diff}.
\index{diff}

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/find_duplicates.py}.

\end{exercise}


\section{Scrivere moduli}
\label{modules}
\index{modulo, scrittura}
\index{conteggio}

Qualunque file che contenga codice Python può essere importato come modulo. Per esempio, supponiamo di avere un file di nome {\tt wc.py} che contiene il codice che segue:

\begin{verbatim}
def contarighe(nomefile):
    conta = 0
    for riga in open(nomefile):
        conta += 1
    return conta

print contarighe('wc.py')
\end{verbatim}
%
Se eseguite questo programma, legge se stesso e stampa il numero delle righe nel file, che è 7. Potete anche importare il file in questo modo:

\begin{verbatim}
>>> import wc
7
\end{verbatim}
%
Ora avete un oggetto modulo {\tt wc}:
\index{oggetto!modulo}

\begin{verbatim}
>>> print wc
<module 'wc' from 'wc.py'>
\end{verbatim}
%
Che fornisce una funzione di nome \verb"contarighe":

\begin{verbatim}
>>> wc.contarighe('wc.py')
7
\end{verbatim}
%
Ecco come scrivere moduli in Python.

L'unico difetto di questo esempio è che quando importate il modulo, esegue anche il codice di prova in fondo. Di solito, invece, un modulo definisce solo delle nuove funzioni ma non le esegue.
\index{import, istruzione}
\index{istruzione!import}

I programmi che verranno importati come moduli usano spesso questo costrutto:

\begin{verbatim}
if __name__ == '__main__':
    print contarighe('wc.py')
\end{verbatim}
%
\verb"__name__" è una variabile predefinita che viene impostata all'avvio del programma. Se questo viene avviato come script,
\verb"__name__" ha il valore \verb"__main__"; in quel caso, il codice viene eseguito. Altrimenti, se viene importato come modulo, il codice di prova viene saltato.

\vspace{0.2in}
\begin{exercise}

Scrivete questo esempio in un file di nome {\tt wc.py} ed eseguitelo come script. Poi avviate l'interprete e scrivete
{\tt import wc}.  Che valore ha \verb"__name__"
quando il modulo viene importato?

Attenzione: Se importate un modulo già importato, Python non fa nulla. Non rilegge il file, anche se è cambiato.
\index{modulo!reload}
\index{reload, funzione}
\index{funzione!reload}

Se volete ricaricare un modulo potete usare la funzione {\tt reload}, ma potrebbe dare delle noie, quindi la cosa più sicura è riavviare l'interprete e importare nuovamente il modulo.

\end{exercise}



\section{Debug}
\index{debug}
\index{spaziatore}

Quando leggete e scrivete file, è possibile incontrare dei problemi con gli spaziatori. Questi errori sono difficili da correggere perché spazi, tabulazioni e ritorni a capo di solito non sono visibili.

\begin{verbatim}
>>> s = '1 2\t 3\n 4'
>>> print s
1 2	 3
 4
\end{verbatim}
\index{repr, funzione}
\index{funzione!repr}
\index{stringa!rappresentazione}

La funzione predefinita {\tt repr} può essere utile: riceve come argomento qualsiasi oggetto e restituisce una rappresentazione dell'oggetto in forma di stringa. Per le stringhe, essa rappresenta gli spaziatori con delle sequenze con barra inversa:

\begin{verbatim}
>>> print repr(s)
'1 2\t 3\n 4'
\end{verbatim}

Questa funzione può quindi aiutare nel debug.

Un altro problema in cui potreste imbattervi è che sistemi diversi usano caratteri diversi per indicare la fine della riga. Alcuni usano il carattere di ritorno a capo, rappresentato da \verb"\n".  Altri usano quello di ritorno carrello, rappresentato da \verb"\r".  Alcuni usano entrambi. Se spostate i file da un sistema all'altro, queste incongruenze possono causare errori.
\index{fine riga, carattere}

Comunque, esistono per ogni sistema delle applicazioni che convertono da un formato a un altro. Potete trovarne (e leggere altro sull'argomento) sul sito \url{http://it.wikipedia.org/wiki/Ritorno_a_capo}.  Oppure, naturalmente, potete scriverne una voi.


\section{Glossario}

\begin{description}

\item[persistente:] Di un programma eseguito per un tempo indefinito e che memorizza almeno parte dei suoi dati in dispositivi permanenti.
\index{persistenza}

\item[operatore di formato:] Operatore indicato da {\tt \%}, che a partire da una stringa di formato e una tupla produce una stringa che include gli elementi della tupla, ciascuno nel formato specificato dalla stringa di formato.
\index{operatore!di formato}

\item[stringa di formato:] Stringa usata con l'operatore di formato e che contiene le sequenze di formato.  
\index{stringa!di formato}

\item[sequenza di formato:] Sequenza di caratteri in una stringa di formato, come {\tt \%d}, che specifica in quale formato deve essere un valore.
\index{sequenza!di formato}

\item[file di testo:] Sequenza di caratteri salvata in un dispositivo di archiviazione permanente come un disco fisso.
\index{file!di testo}

\item[directory:] Raccolta di file; è dotata di un nome ed è chiamata anche cartella.
\index{directory}

\item[percorso:] Stringa che localizza un file.
\index{percorso}

\item[percorso relativo:] Un percorso che parte dalla cartella di lavoro attuale.
\index{percorso!relativo}

\item[percorso assoluto:] Un percorso che parte dalla cartella principale del file system.
\index{percorso!assoluto}

\item[gestire:] Prevenire l'arresto di un programma causato da un errore, mediante le istruzioni {\tt try}
e {\tt except}.
\index{gestire}

\item[database:] Un file i cui contenuti sono organizzati come un dizionario, con chiavi che corrispondono a valori.
\index{database}

\end{description}


\section{Esercizi}

\begin{exercise}
\label{urllib}
\index{urllib, modulo}
\index{modulo!urllib}
\index{URL}

Il modulo {\tt urllib} contiene dei metodi per manipolare indirizzi web e scaricare informazioni da Internet. L'esempio seguente scarica e stampa un messaggio segreto da {\tt thinkpython.com}:

\begin{verbatim}
import urllib

conn = urllib.urlopen('http://thinkpython.com/secret.html')
for riga in conn:
    print riga.strip()
\end{verbatim}

Eseguite questo codice e seguite le istruzioni che vi verranno date. Soluzione: \url{http://thinkpython.com/code/zip_code.py}.
\index{esercizio, segreto}

\end{exercise}


%\begin{exercise}
%\index{Internet Movie Database (IMDb)}
%\index{IMDb (Internet Movie Database)}
%\index{database}

%The Internet Movie Database (IMDb) is an online collection of
%information about movies.  Their database is available
%in plain text format, so it is reasonably easy to read from
%Python.  For this exercise, the files you need
%are {\tt actors.list.gz} and {\tt actresses.list.gz}; you
%can download them from \url{http://www.imdb.com/interfaces#plain}.
%\index{plain text}
%\index{text!plain}
%\index{parse}

%I have written a program that parses these files and
%splits them into actor names, movie titles, etc.  You can
%download it from \url{http://thinkpython.com/code/imdb.py}.

%If you run {\tt imdb.py} as a script, it reads {\tt actors.list.gz}
%and prints one actor-movie pair per line.  Or, if you {\tt import
%imdb} you can use the function \verb"process_file" to, well,
%process the file.  The arguments are a filename, a function
%object and an optional number of lines to process.  Here is
%an example:
%
%\begin{verbatim}
%import imdb

%def print_info(actor, date, title, role):
%    print actor, date, title, role

%imdb.process_file('actors.list.gz', print_info)
%\end{verbatim}

%When you call \verb"process_file", it opens {\tt filename}, reads the
%contents, and calls \verb"print_info" once for each line in the file.
%\verb"print_info" takes an actor, date, movie title and role as
%arguments and prints them.

%\begin{enumerate}

%\item Write a program that reads {\tt actors.list.gz} and {\tt
%  actresses.list.gz} and uses {\tt shelve} to build a database
%that maps from each actor to a list of his or her films.
%\index{shelve module}
%\index{module!shelve}

%\item Two actors are ``costars'' if they have been in at least one
%  movie together.  Process the database you built in the previous step
%  and build a second database that maps from each actor to a list of
%  his or her costars.
%\index{Bacon, Kevin}
%\index{Kevin Bacon Game}

%\item Write a program that can play the ``Six Degrees of Kevin
%  Bacon,'' which you can read about at
%  \url{http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon}.  This
%problem is challenging because it requires you to find the shortest
%path in a graph.  You can read about shortest path algorithms
%at \url{http://en.wikipedia.org/wiki/Shortest_path_problem}.

%\end{enumerate}

%\end{exercise}


\chapter{Classi e oggetti}

Il codice degli esempi di questo capitolo è scaricabile dal sito
\url{http://thinkpython.com/code/Point1.py}; le soluzioni degli esercizi da
\url{http://thinkpython.com/code/Point1_soln.py}.


\section{Tipi definiti dall'utente}
\label{point}
\index{tipo!definito dall'utente}

Abbiamo usato molti dei tipi predefiniti in Python, e ora siamo pronti
   per crearne uno nuovo: come esempio, creeremo un tipo che chiameremo {\tt Punto}, che rappresenta un punto in un piano cartesiano bidimensionale.
\index{punto, matematico}

Nella notazione matematica, il punto è denotato da una coppia ordinata di numeri, dette coordinate; le coordinate dei punti sono spesso scritte tra parentesi con una virgola che separa i due valori. Per esempio, $(0,0)$ rappresenta l'origine e $(x,y)$ il punto che si trova a $x$ unità a destra e $y$ unità in alto rispetto all'origine.

Ci sono alcuni modi per rappresentare i punti in Python:

\begin{itemize}

\item Memorizzare le coordinate in due variabili separate, {\tt x} e {\tt y}.

\item Memorizzare le coordinate come elementi di una lista o di una tupla.

\item Creare un nuovo tipo che rappresenti i punti come degli oggetti.

\end{itemize}
\index{rappresentazione}

L'ultima opzione è un pochino più complicata delle altre, ma ha dei vantaggi che saranno presto chiariti.

Un tipo definito dall'utente è chiamato anche {\bf classe}.
Una definizione di classe ha questa sintassi:
\index{classe}
\index{oggetto}
\index{classe!definizione di}
\index{definizione!di classe}

\begin{verbatim}
class Punto(object):
    """Rappresenta un punto in un piano."""
\end{verbatim}
%
L'intestazione indica che la nuova classe è un {\tt Punto},
che è un tipo di oggetto, {\tt object}, che a sua volta è un tipo predefinito.
\index{Punto, classe}
\index{classe!Punto}

Il corpo è una stringa di documentazione che spiega cosa fa la classe. Al suo interno si possono poi definire funzioni e variabili, ma ci arriveremo tra poco.
\index{docstring}

La definizione di una classe di nome {\tt Punto} crea un oggetto classe.

\begin{verbatim}
>>> print Punto
<class '__main__.Punto'>
\end{verbatim}
%
Poiché la classe {\tt Punto} è stata definita al livello principale, il suo ``cognome e nome'' è \verb"__main__.Punto".
\index{oggetto!classe}


L'oggetto classe è simile ad uno stampo che ci permette di fabbricare degli oggetti. Per creare un nuovo oggetto Punto, basta chiamare {\tt Punto} come se fosse una funzione.

\begin{verbatim}
>>> nuovo = Punto()
>>> print nuovo
<__main__.Punto instance at 0xb7e9d3ac>
\end{verbatim}
%
Il valore di ritorno è un riferimento ad un oggetto Punto, che qui abbiamo assegnato alla variabile {\tt nuovo}.  
La creazione di un nuovo oggetto è detta
{\bf istanziazione}, e l'oggetto è un'{\bf istanza} della classe.
\index{istanza}
\index{istanziare}

Quando stampate un'istanza, Python informa a quale classe appartiene e in quale posizione di memoria è collocata (il prefisso {\tt 0x} significa che il numero che segue è in formato esadecimale).
\index{esadecimale}


\section{Attributi}
\label{attributes}
\index{istanza!attributo di}
\index{attributo!di istanza}
\index{dot notation}

Potete assegnare dei valori ad un'istanza usando la notazione a punto:

\begin{verbatim}
>>> nuovo.x = 3.0
>>> nuovo.y = 4.0
\end{verbatim}
%
Questa sintassi è simile a quella usata per la selezione di una variabile appartenente ad un modulo, tipo {\tt math.pi} o {\tt string.whitespace}.  In questo caso però, stiamo assegnando dei valori a degli elementi di un oggetto, ai quali è stato attribuito un nome (x e y). Questi elementi sono detti {\bf attributi}.

Il diagramma di stato in Figura~\ref{fig.point} mostra il risultato delle assegnazioni. Un diagramma di stato che illustra un oggetto e i suoi attributi è detto {\bf diagramma di oggetto} .
\index{diagramma!di stato}
\index{diagramma!di oggetto}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/point.pdf}}
\caption{Diagramma di oggetto}
\label{fig.point}
\end{figure}


La variabile {\tt nuovo} fa riferimento ad un oggetto Punto che contiene due
   attributi, ed ogni attributo fa riferimento ad un numero in virgola mobile.

Potete leggere il valore di un attributo usando la stessa sintassi:

\begin{verbatim}
>>> print nuovo.y
4.0
>>> x = nuovo.x
>>> print x
3.0
\end{verbatim}
%
L'espressione {\tt nuovo.x} significa: ``Vai all'oggetto a cui {\tt nuovo}
fa riferimento e prendi il valore di {\tt x}''. In questo caso, assegniamo il valore ad  una variabile di nome {\tt x}. Non c'è conflitto tra la variabile locale {\tt x} e l'attributo {\tt x}.

Potete usare la notazione a punto all'interno di qualunque espressione, per esempio:

\begin{verbatim}
>>> print '(%g, %g)' % (nuovo.x, nuovo.y)
(3.0, 4.0)
>>> distanza = math.sqrt(nuovo.x**2 + nuovo.y**2)
>>> print distanza
5.0
\end{verbatim}
%
Potete anche passare un'istanza come argomento, nel modo consueto:
\index{istanza!come argomento}

\begin{verbatim}
def stampa_punto(p):
    print '(%g, %g)' % (p.x, p.y)
\end{verbatim}
%
La funzione \verb"stampa_punto" riceve come argomento un Punto e lo visualizza in notazione matematica. Per invocarla, passate {\tt nuovo} come argomento:

\begin{verbatim}
>>> stampa_punto(nuovo)
(3.0, 4.0)
\end{verbatim}
%
Dentro alla funzione, il parametro {\tt p} è un alias di {\tt nuovo}, quindi se la funzione modifica {\tt p}, anche {\tt nuovo} viene modificato di conseguenza.
\index{alias}

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"distanza_tra_punti" che riceva due Punti come argomenti e ne restituisca la distanza.

\end{exercise}



\section{Rettangoli}
\label{rectangles}

A volte è abbastanza ovvio stabilire gli attributi necessari ad un oggetto, ma in altre occasioni occorre fare delle scelte. Immaginate di progettare una classe che rappresenti un rettangolo: quali attributi dovete usare per specificarne le dimensioni e la collocazione nel piano? Per semplicità, ignorate l'inclinazione e supponete che il rettangolo sia allineato in orizzontale o verticale.
\index{rappresentazione}

Ci sono almeno due possibili scelte: 

\begin{itemize}

\item Definire il centro del rettangolo oppure un angolo, e le sue dimensioni (altezza e larghezza);

\item Definire due angoli opposti.

\end{itemize}

È difficile stabilire quale delle due opzioni sia la migliore, ma giusto per fare un esempio implementeremo la prima.
\index{Rettangolo, classe}
\index{classe!Rettangolo}

Definiamo la nuova classe:

\begin{verbatim}
class Rettangolo(object):
    """Rappresenta un rettangolo. 

    attributi: larghezza, altezza, angolo.
    """
\end{verbatim}
%
La docstring elenca gli attributi:  {\tt larghezza} e
{\tt altezza} sono numeri; {\tt angolo} è un oggetto Punto che identifica l'angolo in basso a sinistra.

Per ottenere una rappresentazione di un rettangolo, dovete istanziare un oggetto Rettangolo e assegnare dei valori ai suoi attributi:

\begin{verbatim}
box = Rettangolo()
box.larghezza = 100.0
box.altezza = 200.0
box.angolo = Punto()
box.angolo.x = 0.0
box.angolo.y = 0.0
\end{verbatim}
%
L'espressione {\tt box.angolo.x} significa:
``Vai all'oggetto a cui {\tt box} fa riferimento e seleziona l'attributo chiamato
{\tt angolo}; poi vai a quell'oggetto e seleziona l'attributo chiamato {\tt x}.''

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/rectangle.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.rectangle}
\end{figure}


La Figura~\ref{fig.rectangle} mostra lo stato di questo oggetto.
\index{diagramma!di stato}
\index{diagramma!di oggetto}
Un oggetto che è un attributo di un altro oggetto è detto {\bf oggetto contenuto} (embedded).
\index{oggetto contenuto (embedded)}


\section{Istanze come valori di ritorno}
\index{istanza!come valore di ritorno}
\index{valore di ritorno}

Le funzioni possono restituire istanze. Per esempio, \verb"trova_centro"
prende un oggetto {\tt Rettangolo} come argomento e restituisce un oggetto {\tt Punto} che contiene le coordinate del centro di {\tt Rettangolo}:

\begin{verbatim}
def trova_centro(rett):
    p = Punto()
    p.x = rett.angolo.x + rett.larghezza/2.0
    p.y = rett.angolo.y + rett.altezza/2.0
    return p
\end{verbatim}
%
Ecco un esempio che passa {\tt box} come argomento e assegna il Punto risultante a {\tt centro}:

\begin{verbatim}
>>> centro = trova_centro(box)
>>> stampa_punto(centro)
(50.0, 100.0)
\end{verbatim}
%

\section{Gli oggetti sono mutabili}
\index{oggetto!mutabile}
\index{mutabilità}

Potete cambiare lo stato di un oggetto con un'assegnazione ad uno dei suoi attributi. Per esempio, per cambiare le dimensioni di un rettangolo senza cambiarne la posizione, potete modificare i valori di {\tt larghezza} e {\tt altezza}:

\begin{verbatim}
box.larghezza = box.larghezza + 50
box.altezza = box.altezza + 100
\end{verbatim}
%
Potete anche scrivere delle funzioni che modificano oggetti. Per esempio,
\verb"accresci_rettangolo" prende un oggetto Rettangolo e due numeri,
{\tt dlargh} e {\tt dalt}, e li aggiunge alla larghezza e all'altezza del rettangolo:

\begin{verbatim}
def accresci_rettangolo(rett, dlargh, dalt):
    rett.larghezza += dlargh
    rett.altezza += dalt
\end{verbatim}
%
Ecco un esempio dell'effetto della funzione:

\begin{verbatim}
>>> print box.larghezza
100.0
>>> print box.altezza
200.0
>>> accresci_rettangolo(box, 50, 100)
>>> print box.larghezza
150.0
>>> print box.altezza
300.0
\end{verbatim}
%
Dentro la funzione, {\tt rett} è un alias di {\tt box}, pertanto se la funzione modifica {\tt rett}, anche {\tt box} cambia.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"sposta_rettangolo" che prenda come parametri un Rettangolo e due valori {\tt dx} e {\tt dy}.  La funzione deve spostare il rettangolo nel piano, aggiungendo {\tt dx} alla coordinata {\tt x} di {\tt angolo}, e aggiungendo {\tt dy} alla coordinata {\tt y} di {\tt angolo}.

\end{exercise}


\section{Copia}
\label{copying}
\index{alias}

Abbiamo già visto che gli alias possono rendere il programma difficile
   da leggere, perché una modifica in un punto del programma può dare degli effetti inattesi in un altro punto. Non è semplice tenere traccia di tutte le variabili che potrebbero fare riferimento ad un dato oggetto.
\index{copia!di un oggetto}
\index{oggetto!copia}
\index{copy, modulo}
\index{modulo!copy}

La copia di un oggetto è spesso una comoda alternativa all'alias.
Il modulo {\tt copy} contiene una funzione, anch'essa di nome {\tt copy}, che permette di duplicare qualsiasi oggetto:

\begin{verbatim}
>>> p1 = Punto()
>>> p1.x = 3.0
>>> p1.y = 4.0

>>> import copy
>>> p2 = copy.copy(p1)
\end{verbatim}
%
{\tt p1} e {\tt p2} contengono gli stessi dati, ma non sono lo stesso Punto.

\begin{verbatim}
>>> stampa_punto(p1)
(3.0, 4.0)
>>> stampa_punto(p2)
(3.0, 4.0)
>>> p1 is p2
False
>>> p1 == p2
False
\end{verbatim}
%
L'operatore {\tt is} indica che {\tt p1} e {\tt p2} non sono lo stesso oggetto, come volevasi dimostrare. Ma forse avevate previsto che l'operatore {\tt ==} desse {\tt True}, perché i due punti contengono gli stessi dati. In tal caso, non vi farà piacere di apprendere che nel caso di istanze, il comportamento predefinito dell'operatore {\tt ==} è lo stesso dell'operatore {\tt is}: controlla l'identità dell'oggetto e non l'equivalenza. Questo comportamento però può essere cambiato---più avanti vedremo come.
\index{is, operatore}
\index{operatore!is}

Nell'usare {\tt copy.copy} per duplicare un Rettangolo, noterete che copia l'oggetto Rettangolo ma non l'oggetto Punto contenuto.
\index{oggetto contenuto (embedded)!copia}

\begin{verbatim}
>>> box2 = copy.copy(box)
>>> box2 is box
False
>>> box2.angolo is box.angolo
True
\end{verbatim}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/rectangle2.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.rectangle2}
\end{figure}

La Figura~\ref{fig.rectangle2} mostra la situazione del diagramma di oggetto.
\index{diagramma!di stato}
\index{diagramma!di oggetto}

Questa operazione è chiamata {\bf copia shallow} (o copia superficiale) perché copia l'oggetto ed ogni riferimento che contiene, ma non gli oggetti contenuti.
\index{shallow, copia}
\index{copia!shallow}

Nella maggior parte dei casi, questo non è desiderabile. Nel nostro esempio, invocare \verb"accresci_rettangolo" su uno dei Rettangoli non influenzerebbe l'altro, ma invocare \verb"sposta_rettangolo" su uno dei due, influenzerebbe entrambi! Questo comportamento genera confusione ed è foriero di errori.
\index{profonda, copia}
\index{copia!profonda}

Fortunatamente, il modulo {\tt copy} contiene anche un altro metodo chiamato {\tt
deepcopy} che non solo copia l'oggetto, ma anche gli oggetti a cui si riferisce, e gli oggetti a cui questi ultimi a loro volta si riferiscono, e così via. Non vi sorprenderà che questa si chiami {\bf copia profonda}.
\index{deepcopy, funzione}
\index{funzione!deepcopy}

\begin{verbatim}
>>> box3 = copy.deepcopy(box)
>>> box3 is box
False
>>> box3.angolo is box.angolo
False
\end{verbatim}
%
{\tt box3} e {\tt box} sono oggetti completamente diversi.

\vspace{0.2in}
\begin{exercise}

Scrivete una versione di \verb"sposta_rettangolo" che crei e restituisca un nuovo Rettangolo anziché modificare quello di origine.

\end{exercise}


\section{Debug}
\label{hasattr}
\index{debug}

Iniziando a lavorare con gli oggetti, è facile imbattersi in alcuni nuovi tipi di eccezioni. Se cercate di accedere ad un attributo che non esiste, si verifica un {\tt AttributeError}:
\index{eccezione!AttributeError}
\index{AttributeError}

\begin{verbatim}
>>> p = Punto()
>>> print p.z
AttributeError: Punto instance has no attribute 'z'
\end{verbatim}
%
Se non siete sicuri di che tipo sia un oggetto, potete chiederlo:
\index{type, funzione}
\index{funzione!type}

\begin{verbatim}
>>> type(p)
<type '__main__.Punto'>
\end{verbatim}
%
Se volete sapere se un oggetto ha un certo attributo, usate la funzione predefinita {\tt hasattr}:
\index{hasattr, funzione}
\index{funzione!hasattr}

\begin{verbatim}
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
\end{verbatim}
%
Il primo argomento può essere un qualunque oggetto, il secondo è una {\em
stringa} che contiene il nome dell'attributo.


\section{Glossario}

\begin{description}

\item[classe:] Tipo di dato definito dall'utente. Una definizione di classe crea un nuovo oggetto classe.
\index{classe}

\item[oggetto classe:] Oggetto che contiene le informazioni su un tipo definito dall'utente e che può essere usato per creare istanze del tipo.
\index{oggetto!classe}

\item[istanza:] Oggetto che appartiene ad una classe.
\index{istanza}

\item[attributo:] Uno dei valori associati ad un oggetto, dotato di un nome.
\index{attributo!istanza}
\index{istanza!attributo di}

\item[contenuto (oggetto):] Oggetto che è contenuto come attributo di un altro oggetto (detto contenitore).
\index{oggetto contenuto (embedded)}

\item[copia shallow:] copia ``superficiale'' dei contenuti di un oggetto, senza includere alcun riferimento ad eventuali oggetti contenuti; è implementata grazie alla funzione {\tt copy} del modulo {\tt copy}.
\index{copia!shallow}

\item[copia profonda:] Copia del contenuto di un oggetto e anche degli eventuali
oggetti interni e degli oggetti a loro volta contenuti in essi; è implementata grazie alla funzione {\tt deepcopy} del modulo {\tt copy}.
\index{copia!profonda}

\item[diagramma di oggetto:] Diagramma che mostra gli oggetti, i loro attributi e i valori di questi ultimi.
\index{diagramma!di oggetto}

\end{description}


\section{Esercizi}

\begin{exercise}
\label{canvas}
\index{Swampy}
\index{World, modulo}
\index{modulo!World}

Swampy (vedere Capitolo~\ref{turtlechap}) contiene un modulo di nome {\tt
  World}, che definisce un nuovo tipo chiamato anch'esso {\tt World}.
Lo potete importare in questo modo:

\begin{verbatim}
from swampy.World import World
\end{verbatim}

Oppure così, a seconda di come avete installato Swampy:

\begin{verbatim}
from World import World
\end{verbatim}

Il codice seguente crea un oggetto World e chiama il metodo {\tt mainloop} che resta in attesa dell'azione dell'utente.

\begin{verbatim}
world = World()
world.mainloop()
\end{verbatim}

Dovrebbe apparire una finestra con una barra del titolo e un riquadro vuoto. Useremo questa finestra per disegnare Punti, Rettangoli e altre figure. Aggiungete le righe seguenti prima della chiamata a \verb"mainloop" ed eseguite di nuovo il programma.
\index{Canvas!oggetto}
\index{oggetto!Canvas}

\begin{verbatim}
canvas = world.ca(width=500, height=500, background='white')
bbox = [[-150,-100], [150, 100]]
canvas.rectangle(bbox, outline='black', width=2, fill='green4')
\end{verbatim}

Ora dovreste vedere un rettangolo verde con contorno nero. La prima riga crea un'Area di disegno (Canvas), che appare nella finestra come un riquadro bianco. L'oggetto Canvas contiene dei metodi come {\tt rectangle} che disegnano varie forme.
\index{contenitore}

{\tt bbox} è una lista di liste che rappresenta il ``contenitore''
del rettangolo. La prima coppia di coordinate è l'angolo in basso a sinistra del rettangolo, la seconda è quello in alto a destra.

Potete disegnare un cerchio in questo modo:

\begin{verbatim}
canvas.circle([-25,0], 70, outline=None, fill='red')
\end{verbatim}

Il primo parametro sono le coordinate del centro del cerchio, il secondo è il raggio.

Se aggiungete queste righe, il risultato somiglierà alla bandiera dello stato del Bangladesh.
(vedi \url{http://en.wikipedia.org/wiki/Gallery_of_sovereign-state_flags}).
\index{Bangladesh, bandiera}

\begin{enumerate}

\item Scrivete una funzione di nome \verb"disegna_rettangolo" che richieda un'Area di disegno (Canvas) e un Rettangolo come argomenti, e disegni una rappresentazione del rettangolo nel Canvas.

\item Aggiungete un attributo di nome {\tt color} all'oggetto Rettangolo e modificate \verb"disegna_rettangolo" in modo che usi il nuovo attributo come colore di riempimento.

\item Scrivete una funzione di nome \verb"disegna_punto" che richieda un'Area di disegno e un Punto come argomenti e disegni una rappresentazione del punto nel Canvas.

\item Definite una nuova classe di nome Cerchio con degli appropriati attributi e istanziate alcuni oggetti Cerchio.  Scrivete una funzione \verb"disegna_cerchio" che disegni cerchi nel Canvas.
\index{Repubblica Ceca, bandiera}

\item Scrivete un programma che disegni la bandiera della Repubblica Ceca. Suggerimento: potete disegnare un poligono in questo modo:

\begin{verbatim}
points = [[-150,-100], [150, 100], [150, -100]]
canvas.polygon(points, fill='blue')
\end{verbatim}

\end{enumerate}
\index{lista dei colori}
\index{colori disponibili}

Ho scritto un programmino che elenca i colori disponibili, scaricabile da \url{http://thinkpython.com/code/color_list.py}.

\end{exercise}


\chapter{Classi e funzioni}
\label{time}

Il codice degli esempi di questo capitolo è scaricabile dal sito
\url{http://thinkpython.com/code/Time1.py}.

\section{Tempo}
\label{time.object}

Facciamo un altro esempio di tipo definito dall'utente, e definiamo una classe chiamata {\tt Tempo} che permette di rappresentare un'ora del giorno:
\index{tipo!definito dall'utente}
\index{Tempo, classe}
\index{classe!Tempo}

\begin{verbatim}
class Tempo(object):
    """Rappresenta un'ora del giorno.
       
    attributi: ora, minuto, secondo
    """
\end{verbatim}
%
Possiamo creare un nuovo oggetto {\tt Tempo}, assegnandogli tre attributi per le
ore, i minuti e i secondi:

\begin{verbatim}
tempo = Tempo()
tempo.ora = 11
tempo.minuto = 59
tempo.secondo = 30
\end{verbatim}
%
Il diagramma di stato dell'oggetto {\tt Tempo} è riportato in Figura~\ref{fig.time}.
\index{diagramma!di stato}
\index{diagramma!di oggetto}

\vspace{0.2in}
\begin{exercise}
\label{ex.printtime}

Scrivete una funzione di nome \verb"stampa_tempo" che accetti un oggetto
Tempo come argomento e ne stampi il risultato nel formato {\tt ore:minuti:secondi}.
Suggerimento: la sequenza di formato \verb"'%.2d'" stampa un intero usando almeno due cifre, compreso uno zero iniziale dove necessario.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\label{isafter}
\index{booleana, funzione}

Scrivete una funzione booleana \verb"viene_dopo" che riceva come argomenti due oggetti Tempo, {\tt t1} e {\tt t2}, e restituisca {\tt True} se {\tt t1} è temporalmente successivo a {\tt t2} e {\tt False} in caso contrario.  Sfida: non usate un'istruzione {\tt if}.
\end{exercise}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/time.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.time}
\end{figure}


\section{Funzioni pure}
\index{prototipo ed evoluzioni}
\index{tecnica di sviluppo!prototipo ed evoluzioni}

Nei prossimi paragrafi scriveremo due funzioni che aggiungono dei valori, espressi in termini temporali. Illustreremo così due tipi di funzioni: le funzioni pure e i modificatori. Dimostreremo anche una tecnica di sviluppo che chiameremo {\bf prototipo ed evoluzioni}, che è un modo di affrontare un problema complesso partendo da un prototipo semplice e trattando poi in maniera incrementale gli aspetti di maggior complessità.

Ecco un semplice prototipo della funzione \verb"somma_tempo":

\begin{verbatim}
def somma_tempo(t1, t2):
    somma = Tempo()
    somma.ora = t1.ora + t2.ora
    somma.minuto = t1.minuto + t2.minuto
    somma.secondo = t1.secondo + t2.secondo
    return somma
\end{verbatim}
%
La funzione crea un nuovo oggetto {\tt Tempo}, ne inizializza gli attributi, e restituisce un riferimento al nuovo oggetto. Questa è detta {\bf funzione pura},  perché non modifica alcuno degli oggetti che le vengono passati come argomento e, oltre a restituire un valore, non ha effetti visibili come visualizzare valori o chiedere input all'utente.
\index{funzione!pura}

Per provare questa funzione, creiamo due oggetti Tempo: {\tt inizio}
che contiene l'ora di inizio di un film, come {\em I Monty Python e il Sacro Graal}, e {\tt durata} che contiene la durata del film, che è un'ora e 35 minuti.
\index{Monty Python e il Sacro Graal}

\verb"somma_tempo" ci dirà a che ora finisce il film.

\begin{verbatim}
>>> inizio = Tempo()
>>> inizio.ora = 9
>>> inizio.minuto = 45
>>> inizio.secondo =  0

>>> durata = Tempo()
>>> durata.ora = 1
>>> durata.minuto = 35
>>> durata.secondo = 0

>>> fine = somma_tempo(inizio, durata)
>>> stampa_tempo(fine)
10:80:00
\end{verbatim}
%
Il risultato, {\tt 10:80:00} non è soddisfacente. Il problema è che questa funzione non gestisce correttamente i casi in cui la somma dei minuti e dei secondi equivale o supera sessanta. Quando questo accade, dobbiamo ``riportare'' i 60 secondi come minuto ulteriore, o i 60 minuti come ora ulteriore.
\index{addizione!con riporto}

Ecco allora una versione migliorata della funzione:

\begin{verbatim}
def somma_tempo(t1, t2):
    somma = Tempo()
    somma.ora = t1.ora + t2.ora
    somma.minuto = t1.minuto + t2.minuto
    somma.secondo = t1.secondo + t2.secondo

    if somma.secondo >= 60:
        somma.secondo -= 60
        somma.minuto += 1

    if somma.minuto >= 60:
        somma.minuto -= 60
        somma.ora += 1

    return somma
\end{verbatim}
%
Sebbene questa funzione sia corretta, comincia ad essere lunga. Tra poco vedremo un'alternativa più concisa.


\section{Modificatori}
\label{increment}
\index{modificatore}
\index{funzione!modificatore}

Ci sono casi in cui è utile che una funzione possa modificare gli oggetti che assume come parametri. I cambiamenti risulteranno visibili anche al chiamante. Funzioni che si comportano in questo modo sono dette {\bf modificatori}.
\index{incremento}

{\tt incremento}, che aggiunge un dato numero di secondi ad un oggetto {\tt Tempo}, può essere scritta intuitivamente come modificatore. Ecco un primo abbozzo della funzione:

\begin{verbatim}
def incremento(tempo, secondi):
    tempo.secondo += secondi

    if tempo.secondo >= 60:
        tempo.secondo -= 60
        tempo.minuto += 1

    if tempo.minuto >= 60:
        tempo.minuto -= 60
        tempo.ora += 1
\end{verbatim}
%
La prima riga esegue l'operazione di addizione fondamentale, mentre le successive controllano i casi particolari che abbiamo già visto prima.
\index{caso!particolare}

Questa funzione è corretta? Cosa succede se il parametro {\tt secondi}
è molto più grande di 60?  

In questo caso non è più sufficiente un unico riporto tra secondi e minuti: dobbiamo fare in modo di ripetere il controllo più volte, finché {\tt tempo.secondo} diventa minore di 60. Allora, una possibile soluzione è quella di sostituire le istruzioni {\tt if} con delle istruzioni {\tt while}.
Questo renderebbe la funzione corretta, ma non molto efficiente.

\vspace{0.2in}
\begin{exercise}

Scrivete una versione corretta di {\tt incremento} che non contenga alcun ciclo.

\end{exercise}

Tutto quello che può essere fatto con i modificatori può anche essere fatto con le funzioni pure. Tanto è vero che alcuni linguaggi di programmazione prevedono unicamente l'uso di funzioni pure. Si può affermare che i programmi che utilizzano funzioni pure sono più veloci da sviluppare e meno soggetti ad errori rispetto a quelli che fanno uso dei modificatori. Ma in qualche caso i modificatori convengono, perché i programmi funzionali risultano meno efficienti.

In linea generale, raccomando di usare funzioni pure quando possibile e usare i modificatori solo se c'è un evidente vantaggio nel farlo. Questo tipo di approccio può essere definito {\bf stile di programmazione funzionale}.
\index{stile di programmazione funzionale}

\vspace{0.2in}
\begin{exercise}

Scrivete una versione ``pura'' di {\tt incremento} che crei e restituisca un nuovo oggetto Tempo anziché modificare il parametro.

\end{exercise}


\section{Sviluppo prototipale e Sviluppo pianificato}
\label{prototype}
\index{prototipo ed evoluzioni}
\index{tecnica di sviluppo!prototipo ed evoluzioni}
\index{sviluppo pianificato}
\index{tecnica di sviluppo!pianificato}

La tecnica di sviluppo del programma che sto illustrando in questo Capitolo è detta ``prototipo ed evoluzioni'': per ogni funzione, si inizia scrivendo una versione grezza (prototipo) che effettui solo i calcoli fondamentali, provandola e via via migliorandola e correggendo gli errori.

Sebbene questo approccio possa essere abbastanza efficace, specie se non avete una adeguata conoscenza del problema, può condurre a scrivere del codice inutilmente complesso (perché deve affrontare molti casi particolari) e poco affidabile (dato che è difficile essere certi che tutti gli errori siano stati rimossi).

Un'alternativa è lo {\bf sviluppo pianificato}, nel quale una conoscenza approfondita degli aspetti del problema da affrontare rende la programmazione molto più semplice. Nel nostro caso, questa conoscenza sta nel fatto che l'oggetto Tempo è rappresentabile da un numero a tre cifre in base numerica 60! (vedere \url{http://it.wikipedia.org/wiki/Sistema_sessagesimale}.)  L'attributo
{\tt secondo} è la ``colonna delle unità'', l'attributo {\tt minuto}
è la ``colonna delle sessantine'', e l'attributo {\tt ora} quella della ``trecentosessantine''.
\index{sessagesimale}

Quando abbiamo scritto \verb"somma_tempo" e {\tt incremento}, stavamo a tutti gli effetti calcolando una addizione in base 60, e questo è il motivo per cui dovevamo gestire i riporti tra secondi e minuti e tra minuti e ore.
\index{addizione!con riporto}

Questa osservazione ci suggerisce un altro tipo di approccio al problema: possiamo convertire l'oggetto Tempo in un numero intero e approfittare della capacità del computer di effettuare operazioni sui numeri interi.

Questa funzione converte Tempo in interi:

\begin{verbatim}
def tempo_in_int(tempo):
    minuti = tempo.ora * 60 + tempo.minuto
    secondi = minuti * 60 + tempo.secondo
    return secondi
\end{verbatim}
%
E questa è la funzione inversa, che converte gli interi in Tempi (ricordate che {\tt divmod} divide il primo argomento per il secondo e restituisce una tupla che contiene il quoziente e il resto).
\index{divmod}

\begin{verbatim}
def int_in_tempo(secondi):
    tempo = Tempo()
    minuti, tempo.secondo = divmod(secondi, 60)
    tempo.ora, tempo.minuto = divmod(minuti, 60)
    return tempo
\end{verbatim}
%
Per convincervi della esattezza di queste funzioni, pensateci un po' su e fate qualche prova. Una maniera di collaudarle è controllare che \verb"tempo_in_int(int_in_tempo(x)) == x" per vari valori di {\tt x}. Questo è un esempio di controllo di coerenza.
\index{coerenza, controllo di}

Quando vi siete convinti, potete usarle per riscrivere \verb"somma_tempo":

\begin{verbatim}
def somma_tempo(t1, t2):
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
\end{verbatim}
%
Questa versione è più concisa dell'originale e più facile da verificare.

\vspace{0.2in}
\begin{exercise}

Riscrivete {\tt incremento} usando \verb"tempo_in_int" e \verb"int_in_tempo".

\end{exercise}

Sicuramente, la conversione numerica da base 60 a base 10 e viceversa è più astratta e meno immediata rispetto al lavoro diretto con i tempi, che è istintivamente migliore.

Ma avendo l'intuizione di trattare i tempi come numeri in base 60, e    investendo il tempo necessario per scrivere le funzioni di conversione (\verb"tempo_in_int" e \verb"int_in_tempo"), abbiamo ottenuto un programma molto più corto, facile da leggere e correggere, e più affidabile.

Risulta anche più semplice aggiungere nuove caratteristiche, in un secondo tempo. Ad esempio, immaginate di dover sottrarre due Tempi per determinare l'intervallo trascorso. L'approccio iniziale avrebbe reso necessaria l'implementazione di  una sottrazione con il prestito. Invece, con le funzioni di conversione, è molto più facile e rapido avere un programma corretto.
\index{sottrazione!con prestito}
\index{generalizzazione}

Paradossalmente, qualche volta rendere un problema più difficile (o più generale) lo rende più semplice, perché ci sono meno casi particolari da gestire e minori possibilità di errore.


\section{Debug}
\index{debug}

Un oggetto Tempo è ben impostato se i valori di {\tt minuto} e {\tt
secondo} sono compresi tra 0 e 60 (zero incluso ma 60 escluso) e se 
{\tt ora} è positiva.  {\tt ora} e {\tt minuto} devono essere interi, ma potremmo anche permettere a {\tt secondo} di avere una parte decimale.
\index{invariante}

Requisiti come questi sono detti {\bf invarianti} perché devono essere sempre soddisfatti. In altre parole, se non sono soddisfatti significa che qualcosa non è andato per il verso giusto.

Scrivere del codice per controllare le invarianti può servire a trovare errori e a identificarne le cause. Per esempio, potete scrivere una funzione
 \verb"tempo_valido" che prende un oggetto Tempo e restituisce
{\tt False} se viola un'invariante:

\begin{verbatim}
def tempo_valido(tempo):
    if tempo.ora < 0 or tempo.minuto < 0 or tempo.secondo < 0:
        return False
    if tempo.minuto >= 60 or tempo.secondo >= 60:
        return False
    return True
\end{verbatim}
%
Poi, all'inizio di ogni funzione, potete controllare l'argomento per assicurarvi della sua validità:
\index{raise, istruzione}
\index{istruzione!raise}

\begin{verbatim}
def somma_tempo(t1, t2):
    if not tempo_valido(t1) or not tempo_valido(t2):
        raise ValueError, 'oggetto Tempo non valido in somma_tempo'
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
\end{verbatim}
%
Oppure potete usare un'istruzione {\tt assert}, che controlla una data invariante e solleva un'eccezione in caso di difetti:
\index{assert, istruzione}
\index{istruzione!assert}

\begin{verbatim}
def somma_tempo(t1, t2):
    assert tempo_valido(t1) and tempo_valido(t2)
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
\end{verbatim}
%
Le istruzioni {\tt assert} sono utili perché permettono di distinguere il codice che tratta le condizioni normali da quello che controlla gli errori.


\section{Glossario}

\begin{description}

\item[prototipo ed evoluzioni:] Tecnica di sviluppo del programma a partire da un prototipo che viene gradualmente provato, esteso e migliorato.
\index{prototipo ed evoluzioni}

\item[sviluppo pianificato:] Tecnica di sviluppo che coinvolge profonde conoscenze del problema e maggiore pianificazione rispetto allo sviluppo incrementale o per prototipo
\index{sviluppo pianificato}

\item[funzione pura:] Funzione che non modifica gli oggetti ricevuti come argomenti. La maggior parte delle funzioni pure sono produttive.
\index{funzione!pura}

\item[modificatore:] Funzione che cambia uno o più oggetti ricevuti come argomenti. La maggior parte dei modificatori non restituisce valori.
\index{modificatore}

\item[stile di programmazione funzionale:] Stile di programmazione in cui la maggior parte delle funzioni è pura.
\index{stile di programmazione funzionale}

\item[invariante:] Condizione che deve sempre essere vera durante l'esecuzione del programma.
\index{invariante}

\end{description}


\section{Esercizi}

Il codice degli esempi di questo capitolo è scaricabile dal sito
\url{http://thinkpython.com/code/Time1.py}; le soluzioni di questi esercizi si trovano in \url{http://thinkpython.com/code/Time1_soln.py}.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome \verb"moltiplica_tempo" che accetti un oggetto Tempo e un numero, e restituisca un nuovo oggetto Tempo che contiene il prodotto del Tempo iniziale per il numero.

Usate poi \verb"moltiplica_tempo" per scrivere una funzione che prenda un oggetto Tempo che rappresenta il tempo finale di una gara, e un numero che rappresenta la distanza percorsa, e restituisca un oggetto Tempo che rappresenta la media di gara (tempo al chilometro).
\index{passo di corsa}

\end{exercise}

%\begin{exercise}
%\index{Date class}
%\index{class!Date}

%Write a class definition for a Date object that has attributes {\tt
%  day}, {\tt month} and {\tt year}.  Write a function called
%\verb"increment_date" that takes a Date object, {\tt date} and an
%integer, {\tt n}, and returns a new Date object that
%represents the day {\tt n} days after {\tt date}.  Hint:
%``Thirty days hath September...''  Challenge: does your function
%deal with leap years correctly?  See \url{http://en.wikipedia.org/wiki/Leap_year}.

%\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{datetime, modulo}
\index{modulo!datetime}

Il modulo {\tt datetime} fornisce gli oggetti {\tt date} e {\tt time}, simili agli oggetti Data e Tempo di questo capitolo, ma che contengono un ricco insieme di metodi e operatori. Leggetene la documentazione sul sito \url{http://docs.python.org/2/library/datetime.html}.

\begin{enumerate}

\item Usate il modulo {\tt datetime} per scrivere un programma che ricavi la data odierna e visualizzi il giorno della settimana.
\index{compleanno}

\item Scrivete un programma che riceva una data di nascita come input e stampi l'età dell'utente e il numero di giorni, ore, minuti e secondi che mancano al prossimo compleanno.

\item Date due persone nate in giorni diversi, esiste un giorno in cui uno ha un'età doppia dell'altro. Questo è il loro ``Giorno del Doppio''. Scrivete un programma che prenda due date di nascita e calcoli quando si verifica il ``Giorno del Doppio''.

\item Un po' più difficile: scrivetene una versione più generale che calcoli il giorno in cui una persona ha $n$ volte l'età di un'altra.
\index{Giorno del Doppio}

\end{enumerate}

\end{exercise}


\chapter{Classi e metodi}

Il codice degli esempi di questo capitolo è scaricabile dal sito
\url{http://thinkpython.com/code/Time2.py}.

\section{Funzionalità orientate agli oggetti}
\index{programmazione!orientata agli oggetti}

Python è un {\bf linguaggio di programmazione orientato agli oggetti}, in altre parole contiene delle caratteristiche a supporto della programmazione orientata agli oggetti.

Non è facile definire la programmazione orientata agli oggetti, tuttavia abbiamo già visto alcune sue particolarità:

\begin{itemize}

\item I programmi sono costituiti da definizioni di oggetti e definizioni di funzioni, e buona parte dell'elaborazione è espressa in termini di operazioni sugli oggetti.

\item Ogni definizione di oggetto corrisponde ad un oggetto o concetto del mondo reale, e le funzioni che operano sugli oggetti corrispondono al modo in cui gli oggetti interagiscono tra loro nella realtà quotidiana.

\end{itemize}

Per esempio, la classe {\tt Tempo} definita nel Capitolo~\ref{time}
corrisponde al modo in cui le persone pensano alle ore del giorno, e le funzioni che abbiamo definite corrispondono al tipo di operazioni che le persone fanno con il tempo. Allo stesso modo, le classi {\tt Punto} e {\tt Rettangolo} corrispondono ai rispettivi concetti matematici.

Finora, non abbiamo tratto vantaggio dalle capacità di supporto della   programmazione orientata agli oggetti fornite da Python. A dire il vero, queste funzionalità non sono indispensabili; piuttosto, forniscono una sintassi alternativa per fare le cose che abbiamo già fatto. Ma in molti casi questa alternativa è più concisa e si adatta in modo più accurato alla struttura del programma.

Ad esempio, nel programma {\tt Time} non c'è una chiara connessione tra la definizione della classe e le definizioni di funzione che seguono. A un esame più attento, è però evidente che tutte queste funzioni ricevono almeno un oggetto {\tt Tempo} come argomento.
\index{metodo}
\index{funzione}

Questa osservazione giustifica l'esistenza dei {\bf metodi}; un metodo è una funzione associata ad una particolare classe. Abbiamo già visto qualche metodo per le stringhe, le liste, i dizionari e le tuple. In questo capitolo, definiremo metodi per i tipi definiti dall'utente.
\index{sintassi}
\index{semantica}

Da un punto di vista logico, i metodi sono la stessa cosa delle funzioni, ma con due differenze sintattiche:

\begin{itemize}

\item I metodi sono definiti all'interno di una definizione di classe, per      rendere esplicita la relazione tra la classe stessa ed il metodo.

\item La sintassi per invocare un metodo è diversa da quella usata per       chiamare una funzione.

\end{itemize}

Nei prossimi paragrafi prenderemo le funzioni scritte nei due capitoli    precedenti e le trasformeremo in metodi. Questa trasformazione è puramente meccanica e si fa semplicemente seguendo una serie di passi: se siete in grado di convertire da funzione a metodo e viceversa, riuscirete anche a scegliere la forma migliore, qualsiasi cosa dobbiate fare.


\section{Stampa di oggetti}
\index{oggetto!stampa}

Nel Capitolo~\ref{time}, abbiamo definito una classe chiamata
{\tt Tempo}, e nell'Esercizio~\ref{ex.printtime}, avete scritto una funzione di nome \verb"stampa_tempo":

\begin{verbatim}
class Tempo(object):
    """Rappresenta un'ora del giorno."""

def stampa_tempo(tempo):
    print '%.2d:%.2d:%.2d' % (tempo.ora, tempo.minuto, tempo.secondo)
\end{verbatim}
%
Per chiamare questa funzione occorre passare un oggetto {\tt Tempo} come    argomento:

\begin{verbatim}
>>> inizio = Tempo()
>>> inizio.ora = 9
>>> inizio.minuto = 45
>>> inizio.secondo = 00
>>> stampa_tempo(inizio)
09:45:00
\end{verbatim}
%
Per trasformare \verb"stampa_tempo" in un metodo, tutto quello che dobbiamo fare è spostare la definizione della funzione all'interno della definizione della classe. Notate bene la modifica nell'indentazione.
\index{indentazione}

\begin{verbatim}
class Tempo(object):
    def stampa_tempo(tempo):
        print '%.2d:%.2d:%.2d' % (tempo.ora, tempo.minuto, tempo.secondo)
\end{verbatim}
%
Ora ci sono due modi di chiamare \verb"stampa_tempo".  Il primo (e meno usato) è utilizzare la sintassi delle funzioni:
\index{funzione!sintassi}
\index{dot notation}


\begin{verbatim}
>>> Tempo.stampa_tempo(inizio)
09:45:00
\end{verbatim}
%
In questo uso della notazione a punto, {\tt Tempo} è il nome della classe e
 \verb"stampa_tempo" è il nome del metodo.  {\tt inizio} è passato come parametro.

Il secondo modo, più conciso, è usare la sintassi dei metodi:
\index{metodo!sintassi}

\begin{verbatim}
>>> inizio.stampa_tempo()
09:45:00
\end{verbatim}
%
Sempre usando la {\em dot notation}, \verb"stampa_tempo" è ancora il nome del metodo, mentre {\tt inizio} è l'oggetto sul quale il metodo è invocato, che è chiamato il {\bf soggetto}.  Come il soggetto di una frase è ciò a cui si riferisce la frase, il soggetto del metodo è ciò a cui si applica l'invocazione del metodo.
\index{soggetto}

All'interno del metodo, il soggetto viene assegnato al primo dei parametri: in questo caso, {\tt inizio} viene assegnato a {\tt tempo}.
\index{self (nome di parametro)}
\index{parametro!self}

Per convenzione, il primo parametro di un metodo viene chiamato {\tt self}, di conseguenza è bene riscrivere \verb"stampa_tempo" così:

\begin{verbatim}
class Tempo(object):
    def stampa_tempo(self):
        print '%.2d:%.2d:%.2d' % (self.ora, self.minuto, self.secondo)
\end{verbatim}
%
La ragione di questa convenzione è una metafora implicita:
\index{metafora, invocazione di metodo}

\begin{itemize}

\item La sintassi di una chiamata di funzione, \verb"stampa_tempo(inizio)",
  suggerisce che la funzione è la parte attiva, che dice qualcosa del tipo: ``Ehi, \verb"stampa_tempo"!  Ti passo un oggetto da stampare!''

\item Nella programmazione orientata agli oggetti, la parte attiva sono gli oggetti.  L'invocazione di un metodo come \verb"inizio.stampa_tempo()" dice:
  ``Ehi, {\tt inizio}!  Stampa te stesso!''

\end{itemize}

Questo cambio di prospettiva sarà anche più elegante, ma cogliere la sua utilità non è immediato. Nei semplici esempi che abbiamo visto finora, può non esserlo. Ma in altri casi, spostare la responsabilità dalle funzioni agli oggetti rende possibile scrivere funzioni più versatili e rende più facile mantenere e riusare il codice.

\vspace{0.2in}
\begin{exercise}
\label{convert}

Riscrivete \verb"tempo_in_int" (vedere Paragrafo~\ref{prototype}) come metodo.
Probabilmente è improprio riscrivere \verb"int_in_tempo" come metodo: su quale oggetto lo invochereste?

\end{exercise}


\section{Un altro esempio}
\index{incremento}

Ecco una versione di {\tt incremento} (vedere Paragrafo~\ref{increment}),
riscritto come metodo:

\begin{verbatim}
# all'interno della classe Tempo:

    def incremento(self, secondi):
        secondi += self.tempo_in_int()
        return int_in_tempo(secondi)
\end{verbatim}
%
Questa versione presuppone che pure \verb"tempo_in_int" sia stato scritto come metodo, come nell'Esercizio~\ref{convert}.  Notate anche che si tratta di una funzione pura e non un modificatore.

Ecco come invocare {\tt incremento}:

\begin{verbatim}
>>> inizio.stampa_tempo()
09:45:00
>>> fine = inizio.incremento(1337)
>>> fine.stampa_tempo()
10:07:17
\end{verbatim}
%
Il soggetto, {\tt inizio}, viene assegnato quale primo parametro, a
{\tt self}.  L'argomento, {\tt 1337}, viene assegnato quale secondo parametro, a {\tt secondi}.

Questo meccanismo può confondere le idee, specie se commettete qualche errore. Per esempio, se invocate {\tt incremento} con due argomenti ottenete:
\index{eccezione!TypeError}
\index{TypeError}

\begin{verbatim}
>>> fine = inizio.incremento(1337, 460)
TypeError: increment() takes exactly 2 arguments (3 given)
\end{verbatim}
%
Il messaggio di errore a prima vista non è chiaro, perché ci sono solo due argomenti tra parentesi. Ma bisogna tener conto che anche il soggetto è considerato un argomento, ecco perché in totale fanno tre.


\section{Un esempio più complesso}

\verb"viene_dopo" (vedere Esercizio~\ref{isafter}) è leggermente più complesso da scrivere come metodo, perché richiede come parametri due oggetti Tempo. In questo caso, la convenzione prevede di denominare il primo parametro {\tt self} e il secondo {\tt other}:
\index{other (nome di parametro)}
\index{parametro!other}

\begin{verbatim}
# all'interno della classe Tempo:

    def viene_dopo(self, other):
        return self.tempo_in_int() > other.tempo_in_int()
\end{verbatim}
%
Per usare questo metodo, lo dovete invocare su un oggetto e passare l'altro come argomento:

\begin{verbatim}
>>> fine.viene_dopo(inizio)
True
\end{verbatim}
%
Una particolarità di questa sintassi è che si legge quasi come in italiano:
``fine viene dopo inizio?''


\section{Il metodo speciale init}
\index{init, metodo}
\index{metodo!init}

Il metodo init (abbreviazione di {\em initialization}, ovvero inizializzazione) è un metodo speciale che viene invocato quando un oggetto viene istanziato. Il suo nome completo è \verb"__init__" (due caratteri underscore, 
seguiti da {\tt init}, e da altri due  underscore). Un metodo init per la classe  {\tt Tempo} può essere il seguente:

\begin{verbatim}
# all'interno della classe Tempo:

    def __init__(self, ora=0, minuto=0, secondo=0):
        self.ora = ora
        self.minuto = minuto
        self.secondo = secondo
\end{verbatim}
%
È prassi che i parametri di \verb"__init__" abbiano gli stessi nomi degli attributi. L'istruzione

\begin{verbatim}
        self.ora = ora
\end{verbatim}
%
memorizza il valore del parametro {\tt ora} come attributo di {\tt self}.
\index{parametro!opzionale}
\index{valore di default}
\index{sovrascrittura}

I parametri sono opzionali, quindi se chiamate {\tt Tempo} senza argomenti, ottenete i valori di default.

\begin{verbatim}
>>> tempo = Tempo()
>>> tempo.stampa_tempo()
00:00:00
\end{verbatim}
%
Se fornite un argomento, esso va a sovrascrivere {\tt ora}:

\begin{verbatim}
>>> tempo = Tempo (9)
>>> tempo.stampa_tempo()
09:00:00
\end{verbatim}
%
Se ne fornite due, sovrascrivono {\tt ora} e {\tt minuto}.

\begin{verbatim}
>>> tempo = Tempo(9, 45)
>>> tempo.stampa_tempo()
09:45:00
\end{verbatim}
%
E se ne fornite tre, sovrascrivono tutti e tre i valori di default.

\vspace{0.2in}
\begin{exercise}
\index{Punto, classe}
\index{classe!Punto}

Scrivete un metodo init per la classe {\tt Punto} che prenda {\tt x} e {\tt y} come parametri opzionali e li assegni agli attributi corrispondenti.
\end{exercise}


\section{Il metodo speciale {\tt \_\_str\_\_}}
\index{str metodo@\_\_str\_\_, metodo}
\index{metodo!\_\_str\_\_}

\verb"__str__" è un altro metodo speciale, come \verb"__init__",
che ha lo scopo di restituire una rappresentazione di un oggetto in forma di stringa.
\index{rappresentazione!di stringa}

Ecco ad esempio un metodo {\tt str} per un oggetto Tempo:

\begin{verbatim}
# all'interno della classe Tempo:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.ora, self.minuto, self.secondo)
\end{verbatim}
%
Quando stampate un oggetto con l'istruzione {\tt print}, Python invoca il metodo {\tt str}:
\index{print, istruzione}
\index{istruzione!print}

\begin{verbatim}
>>> tempo = Tempo(9, 45)
>>> print tempo
09:45:00
\end{verbatim}
%
Personalmente, quando scrivo una nuova classe, quasi sempre inizio con lo scrivere \verb"__init__", che rende più facile istanziare un oggetto, e 
\verb"__str__", che è utile per il debugging.

\vspace{0.2in}
\begin{exercise}

Scrivete un metodo {\tt str} per la classe {\tt Punto}.  Create un oggetto Punto e stampatelo.

\end{exercise}


\section{Operator overloading}
\label{operator.overloading}

Nelle classi definite dall'utente, avete la possibilità di adattare il comportamento degli operatori attraverso la definizione di altri appositi metodi speciali. Per esempio se definite il metodo speciale di nome \verb"__add__" per la classe {\tt Tempo}, potete poi usare l'operatore {\tt +} sugli oggetti Tempo.

Ecco come potrebbe essere scritta la definizione:
\index{add, metodo}
\index{metodo!add}

\begin{verbatim}
# all'interno della classe Tempo:

    def __add__(self, other):
        secondi = self.tempo_in_int() + other.tempo_in_int()
        return int_in_tempo(secondi)
\end{verbatim}
%
Ed ecco come può essere usata:

\begin{verbatim}
>>> inizio = Tempo(9, 45)
>>> durata = Tempo(1, 35)
>>> print inizio + durata
11:20:00
\end{verbatim}
%
Quando applicate l'operatore {\tt +} agli oggetti Tempo, Python invoca
\verb"__add__".  Quando stampate il risultato, Python invoca 
\verb"__str__".  Accadono parecchie cose, dietro le quinte!
\index{operator overloading}

Cambiare il comportamento degli operatori in modo che funzionino con i tipi definiti dall'utente è chiamato {\bf operator overloading} (letteralmente, sovraccarico degli operatori). In Python, per ogni operatore esiste un corrispondente metodo speciale, come
\verb"__add__".  Per ulteriori dettagli consultate
\url{http://docs.python.org/2/reference/datamodel.html#specialnames}.

\vspace{0.2in}
\begin{exercise}

Scrivete un metodo {\tt add} per la classe Punto.  

\end{exercise}


\section{Smistamento in base al tipo}

Nel Paragrafo precedente abbiamo sommato due oggetti Tempo, ma potrebbe anche capitare di voler aggiungere un numero intero a un oggetto Tempo. Quella che segue è una versione di \verb"__add__"
che controlla il tipo di {\tt other} e, a seconda dei casi, invoca o
\verb"somma_tempo" o {\tt incremento}:

\begin{verbatim}
# all'interno della classe Tempo:

    def __add__(self, other):
        if isinstance(other, Tempo):
            return self.somma_tempo(other)
        else:
            return self.incremento(other)

    def somma_tempo(self, other):
        secondi = self.tempo_in_int() + other.tempo_in_int()
        return int_in_tempo(secondi)

    def incremento(self, secondi):
        secondi += self.tempo_in_int()
        return int_in_tempo(secondi)
\end{verbatim}
%
La funzione predefinita {\tt isinstance} prende un valore e un oggetto classe, e restiutisce {\tt True} se il valore è un'istanza della classe.
\index{isinstance, funzione}
\index{funzione!isinstance}

Quindi, se {\tt other} è un oggetto Tempo, \verb"__add__" invoca
\verb"somma_tempo".  Altrimenti, considera che il parametro sia un numero, e invoca {\tt incremento}.  Questa operazione è detta {\bf smistamento in base al tipo}, perché invia il calcolo a metodi diversi a seconda del tipo di argomento.
\index{smistamento in base al tipo}

Ecco degli esempi che usano l'operatore {\tt +} con tipi diversi:

\begin{verbatim}
>>> inizio = Tempo(9, 45)
>>> durata = Tempo(1, 35)
>>> print inizio + durata
11:20:00
>>> print inizio + 1337
10:07:17
\end{verbatim}
%
Sfortunatamente, questa implementazione di addizione non è commutativa. Se l'intero è il primo operando vi risulterà infatti:
\index{commutatività}

\begin{verbatim}
>>> print 1337 + inizio
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
\end{verbatim}
%
Il problema è che, invece di chiedere all'oggetto Tempo di aggiungere un intero, Python chiede all'intero di aggiungere un oggetto Tempo, ma l'intero non ha la minima idea di come farlo. Ma a questo c'è una soluzione intelligente: il metodo speciale \verb"__radd__", che sta per {\em right-side add} (``addizione lato destro'').
Questo metodo viene invocato quando un oggetto Tempo compare sul lato destro dell'operatore {\tt +}.  Eccone la definizione:
\index{radd, metodo}
\index{metodo!radd}

\begin{verbatim}
# all'interno della classe Tempo:

    def __radd__(self, other):
        return self.__add__(other)
\end{verbatim}
%
Ed eccolo in azione:

\begin{verbatim}
>>> print 1337 + inizio
10:07:17
\end{verbatim}
%
\vspace{0.2in}
\begin{exercise}

Scrivete un metodo {\tt add} per i Punti che possa funzionare sia con un oggetto Punto che con una tupla:  

\begin{itemize}

\item Se il secondo operando è un Punto, il metodo deve restituire un nuovo Punto la cui coordinata $x$ sia la somma delle coordinate $x$ cdegli operandi, e lo stesso per le coordinate $y$.

\item Se il secondo operando è una tupla, il metodo deve aggiungere il primo elemento della tupla alla coordinata $x$ e il secondo elemento alla coordinata $y$, e restituire un nuovo Punto con le coordinate risultanti.

\end{itemize}

\end{exercise}

\section{Polimorfismo}

Lo smistamento in base al tipo è utile all'occorrenza, ma (fortunatamente) non è sempre necessario. Spesso potete evitarlo scrivendo le funzioni in modo che operino correttamente con argomenti di tipo diverso.
\index{smistamento in base al tipo}


Molte delle funzioni che abbiamo scritto per le stringhe, in realtà funzionano con qualsiasi tipo di sequenza.
Per esempio, nel Paragrafo~\ref{histogram}
abbiamo usato {\tt istogramma} per contare quante volte ciascuna lettera appare in una parola.

\begin{verbatim}
def istogramma(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
\end{verbatim}
%
Questa funzione è applicabile anche a liste, tuple e perfino dizionari, a condizione che agli elementi di {\tt s} sia applicabile un hash in modo che possano essere usati come chiavi in {\tt d}.

\begin{verbatim}
>>> t = ['spam', 'uovo', 'spam', 'spam', 'bacon', 'spam']
>>> istogramma(t)
{'bacon': 1, 'uovo': 1, 'spam': 4}
\end{verbatim}
%
Le funzioni che sono in grado di operare con tipi diversi sono dette {\bf polimorfiche}.
Il polimorfismo facilita il riuso del codice.  Ad esempio, la funzione predefinita {\tt sum}, che addiziona gli elementi di una sequenza, funziona alla sola condizione che gli elementi della sequenza siano addizionabili.
\index{polimorfismo}

Dato che agli oggetti Tempo abbiamo fornito un metodo {\tt add}, funzionano con
{\tt sum}:

\begin{verbatim}
>>> t1 = Tempo(7, 43)
>>> t2 = Tempo(7, 41)
>>> t3 = Tempo(7, 37)
>>> totale = sum([t1, t2, t3])
>>> print totale
23:01:00
\end{verbatim}
%
In linea generale, se tutte le operazioni all'interno di una funzione si possono applicare ad un dato tipo, allora la funzione può operare con quel tipo.

Il miglior genere di polimorfismo è quello involontario, quando scoprite che una funzione che avete già scritto può essere applicata anche ad un tipo che non avevate previsto.


\section{Debug}
\index{debug}

È consentito aggiungere attributi in qualsiasi momento dell'esecuzione di un programma, ma per i puristi della teoria dei tipi è una prassi discutibile avere oggetti dello stesso tipo con differenti gruppi di attributi. Di solito, inizializzare tutti gli attributi di un oggetto nel metodo init è una prassi migliore
\index{init, metodo}
\index{attributo!inizializzazione}

Se non siete certi che un oggetto abbia un particolare attributo, potete usare la funzione predefinita {\tt hasattr} (vedere Paragrafo~\ref{hasattr}).
\index{hasattr, funzione}
\index{funzione!hasattr}
\index{dict, attributo@\_\_dict\_\_ attributo}
\index{attributo!\_\_dict\_\_}

Un altro modo di accedere agli attributi di un oggetto è tramite l'attributo speciale \verb"__dict__", che è un dizionario che fa corrispondere nomi degli attributi (come stringhe) e valori:

\begin{verbatim}
>>> p = Punto(3, 4)
>>> print p.__dict__
{'y': 4, 'x': 3}
\end{verbatim}
%
Per gli scopi del debug, può essere utile tenere questa funzione a portata di mano:

\begin{verbatim}
def stampa_attributi(obj):
    for attr in obj.__dict__:
        print attr, getattr(obj, attr)
\end{verbatim}
%
\verb"stampa_attributi" attraversa gli elementi nel dizionario relativo all'oggetto e stampa ciascun nome di attributo con il suo valore.
\index{attraversamento!dizionario}
\index{dizionario!attraversamento}

La funzione predefinita {\tt getattr} prende un oggetto e un nome di attributo (come stringa) e restituisce il valore dell'attributo.
\index{getattr, funzione}
\index{funzione!getattr}


\section{Interfaccia e implementazione}

Uno degli scopi della progettazione orientata agli oggetti è di rendere più agevole la manutenzione del software, che significa poter mantenere il programma funzionante quando altre parti del sistema vengono cambiate e poter modificare il programma per adeguarlo a dei nuovi requisiti.
\index{interfaccia}
\index{implementazione}
\index{manutenzione}
\index{progettazione!orientata agli oggetti}

Un principio di progettazione che aiuta a raggiungere questo obiettivo è di tenere le interfacce separate dalle implementazioni.
Per gli oggetti, significa che i metodi forniti da una classe non devono dipendere da come vengono rappresentati gli attributi.
\index{attributo}

Per esempio, in questo capitolo abbiamo sviluppato una classe che rappresenta un'ora del giorno. I metodi forniti da questa classe comprendono
\verb"tempo_in_int", \verb"viene_dopo", e \verb"somma_tempo".

Quei metodi possono essere implementati in diversi modi. I dettagli dell'implementazione dipendono da come rappresentiamo il tempo. In questo capitolo, gli attributi di un oggetto {\tt Tempo} sono {\tt ora}, {\tt minuto}, e {\tt secondo}.

Come alternativa, avremmo potuto sostituire quegli attributi con un singolo numero intero, come secondi trascorsi dalla mezzanotte. Con questa implementazione, alcuni metodi come \verb"viene_dopo", sarebbero diventati più facili da scrivere, ma altri più difficili.

Dopo aver sviluppato una nuova classe, potreste scoprire una implementazione migliore. Se altre parti del programma usano quella classe, cambiare l'interfaccia può essere dispendioso in termini di tempo e fonte di errori.  

Ma se avete progettato l'interfaccia accuratamente, potete cambiare l'implementazione senza cambiare l'interfaccia, che significa che non occorre cambiare altre parti del programma.

Mantenere l'interfaccia separata dall'implementazione comporta il dover nascondere gli attributi. Il codice in altre parti del programma (esterne alla definizione di classe) dovrebbe usare metodi per leggere e modificare lo stato dell'oggetto e non accedere direttamente agli attributi.  Questo principio è detto {\bf information hiding} (occultamento delle informazioni);
vedere \url{http://en.wikipedia.org/wiki/Information_hiding} e \url{http://it.wikipedia.org/wiki/Incapsulamento_%28informatica%29}.
\index{information hiding}

\vspace{0.2in}
\begin{exercise}

Scaricate il codice degli esempi di questo capitolo
(\url{http://thinkpython.com/code/Time2.py}).  Cambiate gli attributi di {\tt Tempo} con un singolo intero che rappresenta i secondi dalla mezzanotte. Quindi modificate i metodi (e la funzione \verb"int_in_tempo") in modo che funzionino con la nuova implementazione. Non dovete cambiare il codice di prova in {\tt main}.  Quando avete finito, l'output dovrebbe essere lo stesso di prima. Soluzione: \url{http://thinkpython.com/code/Time2_soln.py}

\end{exercise}


\section{Glossario}

\begin{description}

\item[linguaggio orientato agli oggetti:] Linguaggio che possiede delle caratteristiche, come classi definite dall'utente e sintassi dei metodi, che facilitano la programmazione orientata agli oggetti. 
\index{linguaggio!orientato agli oggetti}

\item[programmazione orientata agli oggetti:] Paradigma di programmazione in cui i dati e le operazioni sui dati vengono organizzati in classi e metodi.
\index{programmazione!orientata agli oggetti}

\item[metodo:] Funzione definita all'interno di una definizione di classe e che viene invocata su istanze di quella classe.
\index{metodo}

\item[soggetto:] L'oggetto sul quale viene invocato un metodo.
\index{soggetto}

\item[operator overloading:] Cambiare il comportamento di un operatore come
{\tt +} in modo che funzioni con un tipo definito dall'utente.
\index{overloading}
\index{operator overloading}

\item[smistamento in base al tipo:] Schema di programmazione che controlla il tipo di un operando e invoca funzioni diverse in base ai diversi tipi.
\index{smistamento in base al tipo}

\item[polimorfico:] Di una funzione che può operare con più di un tipo di dati.
\index{polimorfismo}

\item[information hiding:] Principio per cui l'interfaccia di un oggetto non deve dipendere dalla sua implementazione, con particolare riferimento alla rappresentazione dei suoi attributi.
\index{information hiding}


\end{description}

\section{Esercizi}

\begin{exercise}
\index{valore di default!evitare i mutabili}
\index{oggetto mutabile, come valore di default}
\index{peggior bug}
\index{bug!il peggiore}
\index{Canguro, classe}
\index{classe!Canguro}

Questo esercizio è un aneddoto monitorio su uno degli errori più comuni e difficili da trovare in Python. Scrivete una definizione di una classe di nome {\tt Canguro} con i metodi seguenti:

\begin{enumerate}

\item Un metodo \verb"__init__" che inizializza un attributo di nome
\verb"contenuto_tasca" ad una lista vuota.

\item Un metodo di nome \verb"intasca" che prende un oggetto di qualsiasi tipo e lo inserisce in \verb"contenuto_tasca".

\item Un metodo \verb"__str__" che restituisce una stringa di rappresentazione  dell'oggetto Canguro e dei contenuti della tasca.

\end{enumerate}
%
Provate il codice creando due oggetti {\tt Canguro}, assegnandoli a variabili di nome {\tt can} e {\tt guro}, e aggiungendo poi {\tt guro} al contenuto della tasca di {\tt can}.

Scaricate \url{http://thinkpython.com/code/BadKangaroo.py}.  Contiene una soluzione al problema precedente, ma con un grande e serio errore. Trovatelo e sistematelo.  

Se vi bloccate, potete scaricare
\url{http://thinkpython.com/code/GoodKangaroo.py}, che spiega il problema e illustra una soluzione.
\index{alias}
\index{contenuto, oggetto}
\index{oggetto!contenuto}

\end{exercise}



\vspace{0.2in}
\begin{exercise}
\index{Visual, modulo}
\index{modulo!Visual}
\index{vpython, modulo}
\index{modulo!vpython}

Visual è un modulo Python che offre supporto alla grafica 3-D. Dato che non è sempre incluso in un'installazione standard di Python, potrebbe essere necessario installarlo dal vostro repository software o scaricandolo da\url{http://vpython.org}.

L'esempio che segue crea uno spazio 3-D ampio 256 unità, in altezza, larghezza e profondità, e imposta il ``centro'' nel punto $(128,128,128)$.  Quindi, disegna una sfera di colore blu.

\begin{verbatim}
from visual import *

scene.range = (256, 256, 256)
scene.center = (128, 128, 128)

color = (0.1, 0.1, 0.9)          # mostly blue
sphere(pos=scene.center, radius=128, color=color)
\end{verbatim}

{\tt color} è una tupla che esprime il colore in formato RGB; cioè gli elementi sono i livelli di Rosso-Verde-Blu, compresi tra 0.0 e 1.0 (vedere
\url{http://it.wikipedia.org/wiki/RGB}).

Se eseguite questo codice, dovreste vedere una finestra con sfondo nero e una sfera blu. Se trascinate premendo il pulsante centrale verso l'alto e il basso, potete zoomare la scena, mentre trascinando con il pulsante destro si può ruotarla, anche se con una sola sfera blu non si colgono bene le differenze.

Il ciclo seguente crea un cubo di sfere:

\begin{verbatim}
t = range(0, 256, 51)
for x in t:
    for y in t:
        for z in t:
            pos = x, y, z
            sphere(pos=pos, radius=10, color=color)
\end{verbatim}

\begin{enumerate}

\item Inserite questo codice in uno script e accertatevi che funzioni.

\item Modificate il programma in modo che ogni sfera nel cubo abbia un colore che corrisponda alla sua posizione nello spazio RGB. Notate che la coordinate spaziali vanno da 0 a 255, mentre i valori delle tuple sono compresi nell'intervallo 0.0-1.0 .
\index{lista dei colori}
\index{colori disponibili}

\item Scaricate \url{http://thinkpython.com/code/color_list.py}
e usate la funzione \verb"read_colors" per generare una lista dei colori disponibili nel vostro sistema, i loro nomi e valori RGB. Per ogni colore con nome, disegnate una sfera nella posizione che corrisponde ai suoi valori RGB.



\end{enumerate}

Confrontate la mia soluzione sul sito \url{http://thinkpython.com/code/color_space.py}.

\end{exercise}


\chapter{Ereditarietà}

In questo capitolo illustrerò delle classi che rappresentano carte da gioco, mazzi di carte e mani di poker. Se non giocate a poker, potete leggere qualcosa in proposito sul sito \url{http://it.wikipedia.org/wiki/Poker}, ma non è un obbligo: vi spiegherò quello che serve. Gli esempi di codice di questo capitolo si trovano all'indirizzo
\url{http://thinkpython.com/code/Card.py}.
\index{carte da gioco, francesi}
\index{poker}

Se non conoscete bene le carte da gioco francesi, potete consultare il sito \url{http://it.wikipedia.org/wiki/Carte_da_gioco}.


\section{Oggetti Carta}

In un mazzo ci sono 52 carte, e ciascuna appartiene a uno tra quattro semi e a uno tra tredici valori. I semi sono Picche, Cuori, Quadri e Fiori (in ordine decrescente nel gioco del bridge). I valori sono Asso, 2, 3, 4, 5, 6, 7, 8, 9, 10, Fante, Regina e Re. A seconda del gioco, l'Asso può essere superiore al Re o inferiore al 2.
\index{valore (delle carte da gioco)}
\index{seme}

Se vogliamo definire un nuovo oggetto che rappresenti una carta da gioco, è evidente quali attributi dovrebbe avere: {\tt valore} e
{\tt seme}.  È meno evidente stabilire di che tipo devono essere questi attributi. Una possibilità è usare stringhe contenenti parole come
\verb"'Picche'" per i semi e \verb"'Regina'" per i valori. Ma un problema di questa implementazione è che non è facile confrontare le carte per vedere quale abbia un seme o un valore superiore.
\index{codificare}
\index{criptare}
\index{corrispondenza}
\index{rappresentazione}

Un'alternativa è usare degli interi per {\bf codificare} valori e semi.
In questo contesto, ``codificare'' significa determinare una corrispondenza tra numeri e semi o numeri e valori. Non significa che debba essere un segreto (quello è ``criptare'').

\newcommand{\mymapsto}{$\mapsto$}

Per esempio, questa tabella mostra i semi e i corrispondenti codici interi:

\begin{tabular}{l c l}
Picche & \mymapsto & 3 \\
Cuori & \mymapsto & 2 \\
Quadri & \mymapsto & 1 \\
Fiori & \mymapsto & 0
\end{tabular}

In questo modo, diventa facile confrontare le carte: siccome ai semi più alti corrispondono numeri più alti, si possono confrontare i semi confrontando i loro codici corrispondenti.

Nel caso dei valori, la corrispondenza è abbastanza immediata: ogni valore numerico corrisponde al rispettivo intero, mentre per le figure:

\begin{tabular}{l c l}
Fante & \mymapsto & 11 \\
Regina & \mymapsto & 12 \\
Re & \mymapsto & 13 \\
\end{tabular}

Uso il simbolo \mymapsto~per chiarire che queste corrispondenze non fanno parte del programma Python. Fanno parte del progetto del programma, ma non compaiono esplicitamente nel codice.
\index{Carta, classe}
\index{classe!Carta}

Ecco come si può presentare la definizione di classe per {\tt Carta}:

\begin{verbatim}
class Carta(object):
    """Rappresenta una carta da gioco standard."""

    def __init__(self, seme=0, valore=2):
        self.seme = seme
        self.valore = valore
\end{verbatim}
%
Come al solito, il metodo init prevede un parametro opzionale per ciascun attributo. La carta di default è il 2 di fiori.
\index{init, metodo}
\index{metodo!init}

Per creare una carta, si chiama la classe {\tt Carta} con il seme e il valore desiderati.

\begin{verbatim}
regina_di_quadri = Carta(1, 12)
\end{verbatim}
%


\section{Attributi di classe}
\label{class.attribute}
\index{classe!attributo di}
\index{attributo!di classe}

Per stampare gli oggetti Carta in un modo comprensibile agli utenti, occorre stabilire una corrispondenza dai codici interi ai relativi semi e valori. Un modo naturale per farlo è usare delle liste di stringhe, che assegneremo a degli {\bf attributi di classe}:

\begin{verbatim}
# all'interno della classe Carta:

    nomi_semi = ['Fiori', 'Quadri', 'Cuori', 'Picche']
    nomi_valori = [None, 'Asso', '2', '3', '4', '5', '6', '7', 
              '8', '9', '10', 'Fante', 'Regina', 'Re']

    def __str__(self):
        return '%s di %s' % (Carta.nomi_valori[self.valore],
                             Carta.nomi_semi[self.seme])
\end{verbatim}
%
Variabili come \verb"nomi_semi" e \verb"nomi_valori", che sono definite dentro la classe ma esternamente a ogni metodo, sono chiamate attributi di classe perché sono associati all'oggetto classe {\tt Carta}.
\index{istanza!attributo di}
\index{attributo!di istanza}

Questo termine li distingue da variabili come {\tt seme} e {\tt
  valore}, che sono chiamati {\bf attributi di istanza} perché sono associati ad una specifica istanza.
\index{dot notation}

Ad entrambi i tipi si accede usando la notazione a punto. Per esempio in \verb"__str__", {\tt self} è un oggetto carta e {\tt self.valore} è il suo valore.  Allo stesso modo, {\tt Carta} è un oggetto classe, e \verb"Carta.nomi_valori" è una lista di stringhe associata alla classe.

Ogni carta ha i suoi propri {\tt seme} e {\tt valore}, ma esiste una sola copia di \verb"nomi_semi" e \verb"nomi_valori".

Mettendo insieme il tutto, l'espressione
\verb"Carta.nomi_valori[self.valore]" significa ``usa l'attributo {\tt valore} dell'oggetto {\tt self} come indice nella lista \verb"nomi_valori"
dalla classe {\tt Carta}, e seleziona la stringa corrispondente.''

Il primo elemento della lista \verb"nomi_valori" è {\tt None} perché non esiste una carta di valore zero. Includendo {\tt None} come segnaposto, otteniamo una corrispondenza corretta per cui all'indice 2 corrisponde la stringa \verb"'2'", e così via. Per evitare questo trucco, avremmo potuto usare un dizionario al posto di una lista.

Con i metodi che abbiamo visto fin qui, possiamo creare e stampare i nomi delle carte:

\begin{verbatim}
>>> carta1 = Carta(2, 11)
>>> print carta1
Fante di Cuori
\end{verbatim}

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/card1.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.card1}
\end{figure}

La Figura~\ref{fig.card1} è un diagramma dell'oggetto classe {\tt Carta} e di una Carta, sua istanza.
\index{diagramma!di stato}
\index{diagramma!di oggetto}
{\tt Carta} è un oggetto classe, quindi è di tipo {\tt type}.  {\tt
carta1} invece è di tipo {\tt Carta}.  (Per motivi di spazio ho omesso i contenuti di \verb"nomi_semi" e \verb"nomi_valori").


\section{Confrontare le carte}
\label{comparecard}
\index{operatore!relazionale}


Per i tipi predefiniti, esistono gli operatori relazionali
({\tt <}, {\tt >}, {\tt ==}, etc.)
che permettono di confrontare i valori e determinare quale è maggiore, minore o uguale a un altro. Per i tipi definiti dall'utente, possiamo sovrascrivere il comportamento degli operatori predefiniti grazie a un metodo speciale chiamato
\verb"__cmp__".  

\verb"__cmp__" richiede due parametri, {\tt self} e {\tt other},
e restituisce un numero positivo se il primo oggetto è più grande del secondo, un numero negativo se il secondo oggetto è maggiore, e 0 se sono equivalenti.
\index{sovrascrittura}
\index{operator overloading}

L'ordinamento corretto delle carte da gioco non è immediato. Per esempio, tra il 3 di Fiori e il 2 di Quadri, quale è più grande? Una carta ha un valore maggiore, ma l'altra ha un seme superiore. Per confrontare le carte, bisogna prima stabilire se è più importante il seme oppure il valore.

La risposta dipenderà dalle regole del gioco a cui stiamo giocando, ma per semplificare supponiamo che sia più importante il seme, per cui le carte di Picche sovrastano tutte quelle di Quadri, e così via.
\index{cmp metodo@\_\_cmp\_\_, metodo}
\index{metodo!\_\_cmp\_\_}

Deciso questo, possiamo scrivere \verb"__cmp__":

\begin{verbatim}
# all'interno della classe Carta:

    def __cmp__(self, other):
        # controlla i semi
        if self.seme > other.seme: return 1
        if self.seme < other.seme: return -1

        # semi uguali... controlla i valori
        if self.valore > other.valore: return 1
        if self.valore < other.valore: return -1

        # valori uguali... parita'
        return 0    
\end{verbatim}
%
Potete scriverlo anche in modo più compatto, usando un confronto di tuple:
\index{tupla!confronto}
\index{confronto!tupla}

\begin{verbatim}
# all'interno della classe Carta:

    def __cmp__(self, other):
        t1 = self.seme, self.valore
        t2 = other.seme, other.valore
        return cmp(t1, t2)
\end{verbatim}
%
La funzione predefinita {\tt cmp} ha la stessa interfaccia del metodo \verb"__cmp__": prende due valori e restituisce un numero positivo se il primo è maggiore, uno negativo se il secondo è maggiore e 0 se sono uguali.
\index{cmp, funzione}
\index{funzione!cmp}

In Python 3, la funzione {\tt cmp} non esiste più e il metodo \verb"__cmp__"
non è più supportato. In sostituzione si trova \verb"__lt__",
che restituisce {\tt True} se {\tt self} è minore di {\tt other}.
Potete implementare \verb"__lt__" usando delle tuple e l'operatore \verb"<".

\vspace{0.2in}
\begin{exercise}

Scrivete un metodo \verb"__cmp__" per gli oggetti Tempo. Suggerimento: potete usare un confronto di tuple, ma anche prendere in considerazione una sottrazione intera.

%    def __cmp__(self, other):
%        return time_to_int(self) - time_to_int(other)

%If {\tt self} is later than {\tt other}, the result is
%a positive number.  If {\tt other} is later, the result
%is negative.  And if {\tt self} and {\tt other} are equal
%(but not necessarily identical)
%the result is zero.

\end{exercise}


\section{Mazzi di carte}
\index{lista!di oggetti}
\index{mazzo, carte da gioco}

Ora che abbiamo le carte, il prossimo passo è definire i Mazzi. Dato che un mazzo è composto di carte, è ovvio che ogni Mazzo contenga una lista di carte come attributo.
\index{init, metodo}
\index{metodo!init}

Quella che segue è una definizione di classe di {\tt Mazzo}.  Il metodo init crea l'attributo {\tt carte} e genera l'insieme standard di 52 carte:
\index{composizione}
\index{ciclo!nidificato}
\index{Mazzo, classe}
\index{classe!Mazzo}

\begin{verbatim}
class Mazzo(object):

    def __init__(self):
        self.carte = []
        for seme in range(4):
            for valore in range(1, 14):
                carta = Carta(seme, valore)
                self.carte.append(carta)
\end{verbatim}
%
Il modo più facile di popolare il mazzo è quello di usare un ciclo nidificato. Il ciclo più esterno enumera i semi da 0 a 3; quello interno enumera i valori da 1 a 13. Ogni iterazione crea una nuova carta del seme e valore correnti e la accoda nella lista  {\tt self.carte}.
\index{append, metodo}
\index{metodo!append}


\section{Stampare il mazzo}
\label{printdeck}
\index{str metodo@\_\_str\_\_, metodo}
\index{metodo!\_\_str\_\_}

Ecco un metodo \verb"__str__" per {\tt Mazzo}:

\begin{verbatim}
#all'interno della classe Mazzo:

    def __str__(self):
        res = []
        for carta in self.carte:
            res.append(str(carta))
        return '\n'.join(res)
\end{verbatim}
%
Questo metodo illustra un modo efficiente di accumulare una stringa lunga: costruire una lista di stringhe e poi usare {\tt join}.
La funzione predefinita {\tt str} invoca il metodo \verb"__str__"
su ciascuna carta e restituisce la rappresentazione della stringa.
\index{accumulatore!stringa}
\index{stringa!accumulatore}
\index{join, metodo}
\index{metodo!join}
\index{ritorno a capo}

Dato che invochiamo {\tt join} su un carattere di ritorno a capo, le carte sono stampate su righe separate. Ed ecco quello che risulta:

\begin{verbatim}
>>> mazzo = Mazzo()
>>> print mazzo
Asso di Fiori
2 di Fiori
3 di Fiori
...
10 di Picche
Fante di Picche
Regina di Picche
Re di Picche
\end{verbatim}
%
Anche se il risultato viene visualizzato su 52 righe, si tratta di un'unica lunga stringa che contiene caratteri di ritorno a capo.


\section{Aggiungere, togliere, mescolare e ordinare}

Per distribuire le carte, ci serve un metodo che tolga una carta dal mazzo e la restituisca. Il metodo delle liste {\tt pop} è adatto allo scopo:
\index{pop, metodo}
\index{metodo!pop}

\begin{verbatim}
#all'interno della classe Mazzo:

    def togli_carta(self):
        return self.carte.pop()
\end{verbatim}
%
Siccome {\tt pop} rimuove {\em l'ultima} carta della lista, è come se distribuissimo le carte dal fondo del mazzo. Nella realtà, questa sarebbe una cosa orribile, ma in questo contesto non ha importanza.
\index{append, metodo}
\index{metodo!append}

Per aggiungere una carta, usiamo il metodo delle liste {\tt append}:

\begin{verbatim}
#all'interno della classe Mazzo:

    def aggiungi_carta(self, carta):
        self.carte.append(carta)
\end{verbatim}
%
Un metodo come questo, che usa in realtà un'altra funzione senza fare molto di più, da alcuni viene chiamato {\bf impiallacciatura}.  Questa metafora deriva dall'industria del legno: l'impiallaciatura consiste nell'incollare un sottile strato di legno di buona qualità sulla superficie di un pannello economico.
\index{impiallacciatura}

In questo caso abbiamo definito un metodo ``sottile'' che esprime un'operazione su una lista, in una forma appropriata per i mazzi di carte.

Per fare un altro esempio, scriviamo anche un metodo per un Mazzo di nome {\tt mescola}, usando la funzione {\tt shuffle} contenuta nel modulo {\tt random}:
\index{random, modulo}
\index{modulo!random}
\index{shuffle, funzione}
\index{funzione!shuffle}

\begin{verbatim}
# all'interno della classe Mazzo:
            
    def mescola(self):
        random.shuffle(self.carte)
\end{verbatim}
%
Non scordate di importare {\tt random}.

\vspace{0.2in}
\begin{exercise}
\index{sort, metodo}
\index{metodo!sort}

Scrivete un metodo per Mazzo di nome {\tt ordina} che usi il metodo delle liste {\tt sort} per ordinare le carte in un {\tt Mazzo}. Per determinare il criterio di ordinamento, {\tt sort} utilizza il metodo \verb"__cmp__" che abbiamo definito.
\end{exercise}



\section{Ereditarietà}
\index{ereditarietà}
\index{programmazione!orientata agli oggetti}

La caratteristica più frequentemente associata alla programmazione orientata agli oggetti è l'{\bf ereditarietà}, che è la capacità di definire una nuova classe come versione modificata di una classe già esistente.
\index{madre, classe}
\index{figlia, classe}
\index{classe!figlia}
\index{sottoclasse}
\index{superclasse}

È chiamata ``ereditarietà'' perché la nuova classe eredita tutti i metodi della classe originale. Estendendo questa metafora, la classe originale è spesso definita {\bf madre} (o superclasse) e la classe derivata {\bf figlia} (o sottoclasse).

Come esempio, supponiamo di voler creare una classe che rappresenti una ``mano'' di carte, vale a dire un gruppo di carte distribuite a un giocatore. Una mano è simile a un mazzo: entrambi sono fatti di carte, ed entrambi richiedono operazioni come l'aggiunta e la rimozione di carte.

D'altra parte, ci sono altre operazioni che servono per la mano ma che non hanno senso per il mazzo. Nel poker, ad esempio, dobbiamo  confrontare due mani per vedere quale vince. Nel bridge, è utile calcolare il punteggio della mano per decidere la dichiarazione.

Questo tipo di relazione tra classi---simili, ma non uguali---porta all'ereditarietà.

La definizione di una classe figlia è uguale alle altre, a parte il fatto che compare fra parentesi il nome della classe madre:
\index{parentesi!classe madre in}
\index{madre, classe}
\index{classe!madre}
\index{Mano, classe}
\index{classe!Mano}

\begin{verbatim}
class Mano(Mazzo):
    """Rappresenta una mano di carte da gioco."""
\end{verbatim}
%
Questa definizione indica che {\tt Mano} eredita da {\tt Mazzo};
ciò comporta che per Mano possiamo utilizzare i metodi di Mazzo come \verb"togli_carta" e \verb"aggiungi_carta".

{\tt Mano} eredita anche \verb"__init__" da {\tt Mazzo}, ma in questo caso il metodo non fa la cosa giusta: invece di popolare la mano con 52 nuove carte, il metodo init di Mano dovrebbe inizializzare {\tt carte} con una lista vuota.
\index{sovrascrittura}
\index{init, metodo}
\index{metodo!init}

Ma se noi specifichiamo un nuovo metodo init nella classe {\tt Mano}, esso andrà a sovrascrivere quello della classe madre {\tt Mazzo}:

\begin{verbatim}
# all'interno della classe Mano:

    def __init__(self, label=''):
        self.carte = []
        self.label = label
\end{verbatim}
%
Allora, quando si crea una Mano, Python invoca questo metodo init specifico:

\begin{verbatim}
>>> mano = Mano('nuova mano')
>>> print mano.carte
[]
>>> print mano.label
nuova mano
\end{verbatim}
%
Ma gli altri metodi vengono ereditati da {\tt Mazzo}, pertanto possiamo usare \verb"togli_carta" e \verb"aggiungi_carta" per distribuire una carta:

\begin{verbatim}
>>> mazzo = Mazzo()
>>> carta = mazzo.togli_carta()
>>> mano.aggiungi_carta(carta)
>>> print mano
Re di Picche
\end{verbatim}
%
Viene poi spontaneo incapsulare questo codice in un metodo di nome \verb"sposta_carte":
\index{incapsulamento}

\begin{verbatim}
# all'interno della classe Mazzo:

    def sposta_carte(self, mano, num):
        for i in range(num):
            mano.aggiungi_carta(self.togli_carta())
\end{verbatim}
%
\verb"sposta_carte" prende come argomenti un oggetto Mano e il numero di carte da distribuire. Modifica sia {\tt self} che {\tt mano}, e restituisce {\tt None}.

In alcuni giochi, le carte si spostano da una mano all'altra, o da una mano di nuovo al mazzo. Potete usare \verb"sposta_carte" per qualsiasi di queste operazioni: {\tt self} può essere sia un Mazzo che una Mano, e {\tt mano}, a dispetto del nome, può anche essere un {\tt Mazzo}.

\vspace{0.2in}
\begin{exercise}

Scrivete un metodo per Mazzo di nome \verb"dai_mani" che prenda come parametri il numero di mani e il numero di carte da dare a ciascuna mano, e crei nuovi oggetti Mano, distribuisca il numero prefissato di carte a ogni mano e restituisca una lista di oggetti Mano.

\end{exercise}

L'ereditarietà è una caratteristica utile. Certi programmi che sarebbero ripetitivi senza ereditarietà, possono invece essere scritti in modo più elegante. Facilita il riuso del codice, poiché potete personalizzare il comportamento delle superclassi senza doverle modificare. In certi casi, la struttura dell'ereditarietà rispecchia quella del problema, il che rende il programma più facile da capire.

D'altra parte, l'ereditarietà può rendere il programma difficile da leggere. Quando viene invocato un metodo, a volte non è chiaro dove trovare la sua definizione. Il codice rilevante può essere sparso tra moduli diversi. Inoltre, molte cose che possono essere fatte usando l'ereditarietà si possono fare anche, o talvolta pure meglio, senza di essa. 


\section{Diagrammi di classe}
\label{class.diagram}

Sinora abbiamo visto i diagrammi di stack, che illustrano lo stato del programma, e i diagrammi di oggetto, che mostrano gli attributi di un oggetto e i loro valori. Questi diagrammi rappresentano una istantanea nell'esecuzione del programma, e quindi cambiano nel corso del programma.

Sono anche molto dettagliati, per alcuni scopi anche troppo. Un diagramma di classe è una rappresentazione più astratta della struttura di un programma. Invece di mostrare singoli oggetti, mostra le classi e le relazioni che sussistono tra le classi.

Ci sono alcuni tipi diversi di relazioni tra classi:

\begin{itemize}

\item Oggetti in una classe possono contenere riferimenti a oggetti in un'altra classe. Per esempio, ogni Rettangolo contiene un riferimento a un Punto, e ogni Mazzo contiene riferimenti a molte Carte. Questo tipo di relazione è chiamata {\bf HAS-A} (ha-un), come in: ``un Rettangolo ha un Punto''.

\item Una classe può ereditare da un'altra. Questa relazione è detta {\bf IS-A} (è-un), come in: ``una Mano è un tipo di Mazzo''.

\item Una classe può dipendere da un altra, nel senso che modifiche in una classe richiedono modifiche anche nell'altra.

\end{itemize}
\index{IS-A, relazione}
\index{HAS-A, relazione}
\index{diagramma!di classe}

Un {\bf diagramma di classe} è una rappresentazione grafica di queste relazioni.  Per esempio, la Figura~\ref{fig.class1} mostra le relazioni tra {\tt Carta}, {\tt Mazzo} e {\tt Mano}.

\begin{figure}
\centerline
{\includegraphics[scale=0.8]{figs/class1.pdf}}
\caption{Diagramma di classe.}
\label{fig.class1}
\end{figure}


La freccia con un triangolo vuoto rappresenta la relazione IS-A: in questo caso indica che Mano eredita da Mazzo.

La freccia standard rappresenta la relazione HAS-A; in questo caso un Mazzo ha riferimenti agli oggetti Carta.
\index{molteplicità (nel diagramma di classe)}

L'asterisco ({\tt *}) vicino alla testa della freccia indica una
{\bf molteplicità}, cioè quante Carte ha un Mazzo. Una molteplicità può essere un numero semplice, come {\tt 52}, un intervallo come {\tt 5..7}, o un asterisco che indica che un Mazzo può contenere un numero qualsiasi di Carte.

Un diagramma più dettagliato dovrebbe evidenziare che un Mazzo contiene in realtà una {\em lista} di Carte, ma i tipi predefiniti come liste e dizionari di solito non vengono inclusi in questi diagrammi.

\vspace{0.2in}
\begin{exercise}

Leggete {\tt TurtleWorld.py}, {\tt World.py} e {\tt Gui.py}
e disegnate un diagramma di classe che illustri le relazioni tra le classi ivi definite.

\end{exercise}


\section{Debug}
\index{debug}

L'ereditarietà può rendere il debug difficoltoso, perché quando invocate un metodo su un oggetto, può capitare di non sapere esattamente quale sia il metodo che viene invocato.
\index{polimorfismo}

Supponiamo che stiate scrivendo una funzione che lavori su oggetti Mano. Vorreste che fosse valida per Mani di tutti i tipi come ManiDiPoker, ManiDiBridge ecc. Se invocate un metodo come
{\tt mescola}, potrebbe essere quello definito in {\tt Mazzo},
ma se qualcuna delle sottoclassi sovrascrive il metodo, avrete invece quella diversa versione.
\index{flusso di esecuzione}

Quando siete incerti sul flusso di esecuzione del vostro programma, la soluzione più semplice è aggiungere istruzioni di stampa all'inizio di ogni metodo importante. Se {\tt Mazzo.mescola} stampa un messaggio come {\tt Sto eseguendo Mazzo.mescola}, allora il programma traccia il flusso di esecuzione mentre viene eseguito.

In alternativa, potete usare la funzione seguente, che richiede un oggetto e un nome di metodo (come stringa) e restituisce la classe che contiene la definizione del metodo:

\begin{verbatim}
def trova_classe_def(obj, nome_metodo):
    for ty in type(obj).mro():
        if nome_metodo in ty.__dict__:
            return ty
\end{verbatim}
%
Ecco un esempio:

\begin{verbatim}
>>> mano = Mano()
>>> print trova_classe_def(mano, 'mescola')
<class 'Carta.Mazzo'>
\end{verbatim}
%
Quindi il metodo {\tt mescola} di questa Mano è quello definito in{\tt Mazzo}.
\index{mro, metodo}
\index{metodo!mro}
\index{ordine di risoluzione dei metodi}

\verb"trova_classe_def" usa il metodo {\tt mro} per ricavare la lista degli oggetti classe (tipi) in cui verrà effettuata la ricerca dei metodi.  ``MRO'' sta per {\em Method Resolution Order} (ordine di risoluzione dei metodi).
\index{sovrascrittura}
\index{interfaccia}
\index{precondizione}
\index{postcondizione}

Un consiglio per la progettazione di un programma: ogni volta che sovrascrivete un metodo, l'interfaccia del nuovo metodo dovrebbe essere la stessa di quello sostituito: deve richiedere gli stessi parametri, restituire lo stesso tipo, rispettare le stesse precondizioni e postcondizioni. Se rispettate questa regola, vedrete che ogni funzione progettata per un'istanza di una superclasse, come Mazzo, funzionerà anche con le istanze delle sottoclassi come Mano o ManoDiPoker.

Se la violate, il vostro codice crollerà come (perdonatemi) un castello di carte.


\section{Incapsulamento dei dati}

Il capitolo~\ref{time} ha illustrato una tecnica di sviluppo detta
``progettazione orientata agli oggetti''.  Abbiamo identificato gli oggetti che ci servivano---{\tt  Tempo}, {\tt Punto} e {\tt Rettangolo}---e definito le classi per rappresentarli. Per ciascuno c'è un'evidente corrispondenza tra l'oggetto e una qualche entità del mondo reale (o per lo meno del mondo della matematica).
\index{tecnica di sviluppo}

Ma altre volte la scelta degli oggetti e del modo in cui interagiscono è meno ovvia. In questo caso serve una tecnica di sviluppo diversa. Nella stessa maniera in cui abbiamo scoperto le interfacce delle funzioni per mezzo dell'incapsulamento e della generalizzazione, scopriamo ora le interfacce delle classi tramite l'{\bf incapsulamento dei dati}.
\index{incapsulamento!dei dati}

L'analisi di Markov, vista nel Paragrafo~\ref{markov}, è un buon esempio. Se scaricate il mio codice dal sito \url{http://thinkpython.com/code/markov.py}, vi accorgerete che usa due variabili globali---\verb"suffix_map" e \verb"prefix"---che vengono lette e scritte da più funzioni.

\begin{verbatim}
suffix_map = {}        
prefix = ()            
\end{verbatim}

Siccome queste variabili sono globali, possiamo eseguire una sola analisi alla volta. Se leggessimo due testi contemporaneamente, i loro prefissi e suffissi verrebbero aggiunti nella stessa struttura di dati (il che produce comunque alcuni interessanti testi generati).

Per eseguire analisi multiple mantenendole separate, possiamo incapsulare lo stato di ciascuna analisi in un oggetto. Ecco come si presenta:

\begin{verbatim}
class Markov(object):

    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()    
\end{verbatim}

Poi, trasformiamo le funzioni in metodi. Ecco per esempio \verb"elabora_parola":

\begin{verbatim}
    def elabora_parola(self, parola, ordine=2):
        if len(self.prefix) < ordine:
            self.prefix += (parola,)
            return

        try:
            self.suffix_map[self.prefix].append(parola)
        except KeyError:
            # se non c'e' una voce per questo prefisso, creane una
            self.suffix_map[self.prefix] = [parola]

        self.prefix = shift(self.prefix, parola)        
\end{verbatim}

Questa trasformazione di un programma---cambiarne la forma senza cambiarne le funzioni---è un altro esempio di refactoring (vedi Paragrafo~\ref{refactoring}).
\index{refactoring}

L'esempio suggerisce una tecnica di sviluppo per progettare oggetti e metodi:

\begin{enumerate}

\item Cominciare scrivendo funzioni che leggono e scrivono variabili globali (dove necessario)

\item Una volta ottenuto un programma funzionante, cercare le associazioni tra le variabili globali e le funzioni che le usano.

\item Incapsulare le variabili correlate come attributi di un oggetto.

\item Trasformare le funzioni associate in metodi della nuova classe.

\end{enumerate}


\begin{exercise}

Scaricate il mio codice riferito al Paragrafo~\ref{markov}
(\url{http://thinkpython.com/code/markov.py}), e seguite i passi appena descritti per incapsulare le varibili globali come attributi di una nuova classe chiamata {\tt Markov}.  Soluzione: \url{http://thinkpython.com/code/Markov.py} (notare la M maiuscola).

\end{exercise}




\section{Glossario}

\begin{description}

\item[codificare:]  Rappresentare un insieme di valori usando un altro insieme di valori e costruendo una mappatura tra di essi.
\index{codificare}

\item[attributo di classe:] Attributo associato ad un oggetto classe. Gli attributi di classe sono definiti all'interno di una definizione di classe ma esternamente ad ogni metodo.
\index{classe!attributo di}
\index{attributo!di classe}

\item[attributo di istanza:] Attributo associato ad un'istanza di una classe.
\index{istanza!attributo di}
\index{attributo!di istanza}

\item[impiallacciatura:] Metodo o funzione che fornisce un'interfaccia diversa a un'altra funzione, senza tanti calcoli aggiuntivi.
\index{impiallacciatura}

\item[ereditarietà:] Capacità di definire una classe come versione modificata di una classe già definita in precedenza.
\index{ereditarietà}

\item[classe madre o superclasse:] Classe dalla quale una classe figlia eredita.
\index{classe!madre}

\item[classe figlia o sottoclasse:] Nuova classe creata ereditando da una classe esistente.
\index{classe!figlia}


\item[relazione IS-A:] Relazione tra una classe figlia e la sua classe madre.
\index{IS-A, relazione}

\item[relazione HAS-A:] Relazione tra due classi dove le istanze di una classe contengono riferimenti alle istanze dell'altra classe.
\index{HAS-A, relazione}

\item[diagramma di classe:] Diagramma che illustra le classi di un programma e le relazioni tra di esse.
\index{diagramma!di classe}

\item[molteplicità:] Notazione in un diagramma di classe che mostra, per una relazione HAS-A, quanti riferimenti ad istanze di un'altra classe ci sono.
\index{molteplicità (nel diagramma di classe)}

\end{description}


\section{Esercizi}

\begin{exercise}
\label{poker}

Quelle che seguono sono le possibili combinazioni nel gioco del poker, in ordine crescente di valore (e decrescente di probabilità):
\index{poker}

\begin{description}

\item[coppia:] due carte dello stesso valore
\vspace{-0.05in}

\item[doppia coppia:] due coppie di carte dello stesso valore
\vspace{-0.05in}

\item[tris:] tre carte dello stesso valore
\vspace{-0.05in}

\item[scala:] cinque carte con valori in sequenza (gli assi possono essere sia la carta di valore inferiore che quella di valore superiore, per cui {\tt Asso-2-3-4-5} è una scala, e anche {\tt 10-Fante-Regina-Re-Asso}, ma non {\tt Regina-Re-Asso-2-3}).
\vspace{-0.05in}

\item[colore:] cinque carte dello stesso seme
\vspace{-0.05in}

\item[full:] tre carte dello stesso valore più una coppia di carte dello stesso valore
\vspace{-0.05in}

\item[poker:] quattro carte dello stesso valore
\vspace{-0.05in}

\item[scala reale:] cinque carte dello stesso seme in scala (definita come sopra)
\vspace{-0.05in}

\end{description}
%
Scopo di questo esercizio è stimare la probabilità di avere servita una di queste combinazioni.

\begin{enumerate}

\item Scaricate i file seguenti da \url{http://thinkpython.com/code}:

\begin{description}

\item[{\tt Card.py}]: Versione completa delle classi {\tt Carta},
{\tt Mazzo} e {\tt Mano} di questo capitolo.

\item[{\tt PokerHand.py}]: Implementazione incompleta di una classe che rappresenta una mano di poker con del codice di prova.


\end{description}
%
\item Se eseguite {\tt PokerHand.py}, serve delle mani di sette carte e controlla se qualcuna contenga un colore. Leggete attentamente il codice prima di proseguire.

\item Aggiungete dei metodi a {\tt PokerHand.py} di nome \verb"ha_coppia",
\verb"ha_doppiacoppia", ecc. che restituiscano True o False a seconda che le mani soddisfino o meno il rispettivo criterio. Il codice deve funzionare indipendentemente dal numero di carte che contiene la mano (5 e 7 carte sono i casi più comuni).

\item Scrivete un metodo di nome {\tt classifica} che riconosca la combinazione più elevata in una mano e imposta di conseguenza l'attributo
{\tt label}.  Per esempio, una mano di 7 carte può contenere un colore e una coppia; deve essere etichettata ``colore''.

\item Quando siete sicuri che i vostri metodi di classificazione funzionano, il passo successivo è stimare la probabilità delle varie mani. Scrivete una funzione in {\tt PokerHand.py} che mescoli un mazzo di carte, lo divida in mani, le classifichi e conti quante volte compare ciascuna combinazione.

\item Stampate una tabella delle combinazioni con le rispettive probabilità. Eseguite il vostro programma con numeri sempre più grandi di mani finché i valori ottenuti convergono ad un ragionevole grado di accuratezza. Confrontate i vostri risultati con i valori pubblicati su \url{http://en.wikipedia.org/wiki/Hand_rankings}.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/PokerHandSoln.py}.
\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{Swampy}
\index{TurtleWorld}

Questo esercizio utilizza Turtleworld del Capitolo~\ref{turtlechap}.
Scriverete del codice per far giocare le Tartarughe ad Acchiapparella. Se non ne conoscete le regole, vedete \url{http://it.wikipedia.org/wiki/Ce_l%27hai}.

\begin{enumerate}

\item Scaricate \url{http://thinkpython.com/code/Wobbler.py} ed eseguitelo. Dovreste vedere un Mondo di Tartarughe con tre Tartarughe. Se premete il pulsante {\sf Run} le Tartarughe vagano a caso.

\item Leggete il codice e accertatevi di capire come funziona. La classe {\tt Wobbler} eredita da {\tt Turtle}, il che significa che i metodi di {\tt Turtle}: {\tt lt}, {\tt rt}, {\tt fd} e {\tt bk} funzionano in Wobblers.

Il metodo {\tt step} viene invocato da TurtleWorld. Esso invoca 
{\tt steer}, che gira la tartaruga nella direzione voluta,
{\tt wobble}, che provoca una rotazione casuale in proporzione alla goffaggine della tartaruga e {\tt move}, che sposta la tartaruga di alcuni pixel in avanti a seconda della sua velocità.
\index{Tagger}

\item Create un file di nome {\tt Tagger.py}.  Importate tutto da
  {\tt Wobbler}, quindi definite una classe di nome {\tt Tagger} che eredita da {\tt Wobbler}.  Chiamate \verb"make_world" passando l'oggetto classe {\tt Tagger} come argomento.

\item Aggiungete un metodo {\tt steer} a {\tt Tagger} per sovrascrivere quello in  {\tt Wobbler}.  Per iniziare, scrivete una versione che faccia puntare sempre la tartaruga verso l'origine. Suggerimento: usate la funzione matematica  {\tt atan2} e gli attributi della Tartaruga {\tt x}, {\tt y} e {\tt heading}.

\item Modificate {\tt steer} in modo che le tartarughe stiano ai margini. Per il debug provate a usare il pulsante {\sf Step} che invoca {\tt step} una volta su ciascuna Tartaruga.

\item Modificate {\tt steer} in modo che ciascuna Tartaruga punti verso quella più vicina. Suggerimento: le tartarughe hanno un attributo, {\tt world}, che è un riferimento al mondo TurtleWorld in cui vivono, e Turtleworld ha un attributo, {\tt animals}, che è una lista di tutte le Tartarughe nel mondo.

\item Modificate {\tt steer} in modo che le tartarughe giochino ad Acchiapparella. Potete aggiungere dei metodi a {\tt Tagger} e sovrascrivere {\tt steer} e
  \verb"__init__", ma senza modificare o sovrascrivere {\tt step}, {\tt
    wobble} o {\tt move}.  Inoltre, {\tt steer} può cambiare la direzione di moto della tartaruga ma non la posizione.

Aggiustate le regole e il vostro metodo {\tt steer} per una buona qualità del gioco: per esempio deve essere possibile che le tartarughe più lente tocchino quelle più veloci, all'occorrenza.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/Tagger.py}.
\end{exercise}



\chapter{Esercitazione: Tkinter}
\label{tkinter}

\section{Interfacce grafiche}

I programmi che abbiamo visto sinora funzionano in modalità testuale, ma molti di quelli in circolazione usano delle {\bf interfacce grafiche}, dette anche {\bf GUI} ({\em Graphical User Interface}).
\index{GUI}
\index{interfaccia grafica}
\index{Tkinter}

Per Python esistono alcune alternative per la scrittura di programmi basati su interfaccia grafica, come wxPython, Tkinter, e Qt. Ciascuna ha argomenti sia pro che contro, e per questo motivo Python non ha espresso uno standard.

Quello che prenderemo in considerazione è Tkinter, perché è il più semplice con cui iniziare. La maggior parte dei concetti che vedremo si potranno applicare anche agli altri moduli di GUI.

Esistono alcuni libri e pagine web dedicati a Tkinter. Una delle migliori risorse online è {\em An Introduction to Tkinter} di Fredrik Lundh.
\index{Gui, modulo}
\index{modulo!Gui}
\index{Swampy}

Ho scritto un modulo chiamato {\tt Gui.py} che fa parte di Swampy e contiene un'interfaccia semplificata alle funzioni e alle classi di Tkinter. Gli esempi di questo capitolo sono basati su questo modulo.

Ecco un semplice esempio che crea e visualizza un'interfaccia grafica: per crearla dovete importare {\tt Gui} da Swampy:
%
\begin{verbatim}
from swampy.Gui import *
\end{verbatim}
%
Oppure, a seconda di come avete installato Swampy, così:
%
\begin{verbatim}
from Gui import *
\end{verbatim}
%
Quindi istanziate un oggetto Gui:
%
\begin{verbatim}
g = Gui()
g.title('Gui')
g.mainloop()
\end{verbatim}
%
Eseguendo questo codice, dovrebbe comparire una finestra con un quadrato grigio vuoto e con il titolo {\sf Gui}.  {\tt mainloop} avvia l'{\bf evento
  ciclico}, che resta in attesa di una risposta da parte dell'utente e quindi agisce di conseguenza. È una specie di ciclo infinito: viene eseguito finché l'utente non fa qualcosa o preme Control-C o provoca la chiusura del programma.
\index{evento!ciclico}
\index{ciclo!infinito}

Questa Gui non fa gran che, perché non contiene alcun
{\bf controllo}. I controlli, o widget, sono gli elementi che caratterizzano un'interfaccia grafica e che includono:
\index{widget}
\index{controllo}

\begin{description}

\item[Pulsante (Button):] Un controllo, contenente testo o un'immagine, che esegue un azione quando viene premuto.

\item[Area (Canvas):] Una regione in cui possono essere disegnate linee, figure geometriche e altre forme.

\item[Casella di testo (Entry):] Un'area in cui l'utente può inserire del testo.

\item[Barra di scorrimento (Scrollbar):] Un controllo che permette di scorrere la parte visibile di un altro controllo.

\item[Riquadro (Frame):] Un contenitore, spesso non visibile, che contiene altri controlli.

\end{description}

Il riquadro grigio vuoto che vedete quando create una Gui è un Frame. Quando create un nuovo controllo, verrà aggiunto dentro questo Frame.



\section{Pulsanti e callback}
\index{Button, controllo}
\index{controllo!Button}

Il metodo {\tt bu} crea un controllo Button:

\begin{verbatim}
button = g.bu(text='Premi qui.')
\end{verbatim}
%
Il valore di ritorno di {\tt bu} è un oggetto Button. Il pulsante che compare nel Frame è una rappresentazione grafica di questo oggetto; potete controllare il comportamento del pulsante invocando dei metodi su di esso.
\index{opzione}

{\tt bu} riceve fino a 32 parametri che ne controllano l'aspetto e il funzionamento. Questi parametri sono detti
{\bf opzioni}.  Invece di dare valori a tutti i 32 parametri, è meglio usare gli argomenti con nome, come \verb"text='Premi qui.'",
specificando così solo quelli che vi interessano e lasciando il valore predefinito per tutti gli altri.
\index{nome, argomento con}
\index{argomento!con nome}

Quando aggiungete un controllo al Frame, quest'ultimo gli si adatta, cioè si restringe alle dimensioni del pulsante. Se poi aggiungete altri controlli, il Frame crescerà in modo da sistemarli al suo interno.
\index{Label, controllo}
\index{controllo!Label}

Il metodo {\tt la} crea un controllo etichetta (Label):

\begin{verbatim}
label = g.la(text='Premere il pulsante.')
\end{verbatim}
%
Di default, Tkinter impila i controlli dall'alto verso il basso e centrati. Vedremo tra poco come variare questo comportamento.

Se premete il pulsante, noterete che non fa nulla. Questo perché non lo avete ancora ``collegato'', cioè non gli avete spiegato cosa fare!

L'opzione che controlla il comportamento di un pulsante è {\tt command}.
Il valore di {\tt command} è una funzione che viene eseguita quando il pulsante viene premuto. Per esempio, ecco una funzione che crea una nuova etichetta:

\begin{verbatim}
def crea_label():
    g.la(text='Grazie.')
\end{verbatim}
%
Ora possiamo creare un pulsante che ha questa funzione come suo command:

\begin{verbatim}
button2 = g.bu(text='No, premi qui!', command=crea_label)
\end{verbatim}
%
Quando premete questo pulsante, viene eseguita \verb"crea_label",
e compare una nuova etichetta.
\index{callback}

Il valore dell'opzione {\tt command} è un oggetto funzione che viene chiamato {\bf callback} perché dopo aver chiamato {\tt bu} per creare il pulsante, il flusso di esecuzione ``chiama all'indietro'' quando l'utente preme il pulsante.
\index{programmazione!orientata agli eventi}

Questo tipo di flusso è caratteristico della {\bf programmazione orientata agli eventi}.
Le azioni dell'utente, come premere pulsanti o tasti, sono dette {\bf
eventi}.  Nella programmazione orientata agli eventi, il flusso di esecuzione è determinato dalle azioni di chi usa il programma piuttosto che dal programmatore.

La difficoltà di questo tipo di programmazione è costruire un insieme di controlli e callback che funzionino correttamente (o almeno generino appropriati messaggi di errore) per qualsiasi possibile sequenza di azioni dell'utente.

\vspace{0.2in}
\begin{exercise}

Scrivete un programma che crea una GUI con un singolo pulsante. Se si preme il pulsante, deve creare un secondo pulsante. Quando si preme il nuovo pulsante, deve creare un'etichetta con scritto ``Bel lavoro!''.

Cosa succede se premete i pulsanti più di una volta?
Soluzione: \url{http://thinkpython.com/code/button_demo.py}

\end{exercise}


\section{Controlli Canvas}
\index{Canvas!controllo}
\index{controllo!Canvas}

Il controllo Canvas è uno dei più versatili: crea un'area in cui è possibile disegnare linee, cerchi e altre forme. Se avete svolto l'Esercizio~\ref{canvas} dovreste già avere un po' di familiarità con controlli di questo tipo.

Per creare una nuova area usiamo il metodo {\tt ca}:

\begin{verbatim}
canvas = g.ca(width=500, height=500)
\end{verbatim}
%
{\tt width} e {\tt height} sono la larghezza e l'altezza dell'area espressi in pixel.
\index{config, metodo}
\index{metodo!config}

Dopo aver creato il controllo, potete ancora cambiarne i valori delle opzioni mediante il metodo
{\tt config}.  Per esempio, l'opzione {\tt bg} cambia il colore dello sfondo:

\begin{verbatim}
canvas.config(bg='white')
\end{verbatim}
%
Il valore di {\tt bg} è una stringa che è il nome di un colore. L'insieme dei valori di colore validi è diverso tra le varie implementazioni di Python, ma tutte comprendono almeno questi: 

\begin{verbatim}
white   black
red     green    blue   
cyan    yellow   magenta
\end{verbatim}
%
Le forme in un controllo Canvas sono chiamate {\bf elementi o item}.  Per esempio il metodo {\tt circle} disegna (avete già indovinato) un cerchio:
\index{Canvas!elemento}
\index{elemento!Canvas}

\begin{verbatim}
item = canvas.circle([0,0], 100, fill='red')
\end{verbatim}
%
Il primo argomento è una coppia di coordinate che specifica il centro del cerchio; il secondo è il raggio.
\index{Canvas!coordinate}
\index{coordinate!Canvas}

{\tt Gui.py} contiene un sistema standard di coordinate cartesiane con l'origine al centro dell'area e l'asse $y$ orientato verso l'alto (valori crescenti dal basso verso l'alto). In altri sistemi grafici è diverso: l'origine è l'angolo in alto a sinistra e l'asse $y$ è orientato verso il basso. 

L'opzione {\tt fill} specifica che il cerchio va riempito di rosso.

Il valore di ritorno di {\tt circle} è un oggetto Item che contiene metodi per modificare l'elemento nell'area. Potete per esempio usare {\tt config} per cambiare qualunque opzione del cerchio:

\begin{verbatim}
item.config(fill='yellow', outline='orange', width=10)
\end{verbatim}
%
{\tt width} è lo spessore del contorno in pixel;
{\tt outline} è il suo colore.

\vspace{0.2in}
\begin{exercise}
\label{circle}

Scrivete un programma che crei un'area di disegno e un pulsante; premendo il pulsante, deve essere disegnato un cerchio nell'area.

\end{exercise}


\section{Sequenze di coordinate}
\index{coordinate, sequenze di}
\index{sequenze di coordinate}

Il metodo {\tt rectangle} ha come parametro una sequenza di coordinate che specificano gli angoli opposti del rettangolo. Questo esempio disegna un rettangolo blu con l'angolo in basso a sinistra sull'origine e quello in alto a destra nel punto $(200,100)$:

\begin{verbatim}
canvas.rectangle([[0, 0], [200, 100]], 
                 fill='blue', outline='orange', width=10)
\end{verbatim}
%
Questo modo di specificare gli angoli è chiamato {\bf contenitore} perché i due punti determinano i limiti del rettangolo.
\index{contenitore}

{\tt oval} richiede come parametro un contenitore e disegna un ovale interno al rettangolo specificato:

\begin{verbatim}
canvas.oval([[0, 0], [200, 100]], outline='orange', width=10)
\end{verbatim}
%
{\tt line} prende una sequenza di coordinate e disegna una spezzata che collega tutti i punti. Questo esempio disegna due lati di un triangolo:

\begin{verbatim}
canvas.line([[0, 100], [100, 200], [200, 100]], width=10)
\end{verbatim}
%
{\tt polygon} prende gli stessi parametri, ma disegna anche l'ultimo lato di chiusura del poligono (se necessario) e lo riempie:

\begin{verbatim}
canvas.polygon([[0, 100], [100, 200], [200, 100]],
               fill='red', outline='orange', width=10)
\end{verbatim}
%


\section{Altri controlli}
\index{Text, controllo}
\index{controllo!Text}

Tkinter comprende due controlli che permettono all'utente di inserire del testo: una casella di testo semplice a riga singola (controllo Entry), e una casella di testo a righe multiple (controllo Text).
\index{Entry, controllo}
\index{controllo!Entry}

{\tt en} crea un nuovo controllo Entry:

\begin{verbatim}
entry = g.en(text='Testo di prova.')
\end{verbatim}
%
L'opzione {\tt text} permette di inserire nella casella un testo predefinito,  non appena viene creata.
Il metodo {\tt get} legge e restituisce il contenuto della casella (che può essere stato cambiato dall'utente):

\begin{verbatim}
>>> entry.get()
'Testo di prova.'
\end{verbatim}
%
{\tt te} crea un controllo Text:

\begin{verbatim}
text = g.te(width=100, height=5)
\end{verbatim}
%
{\tt width} e {\tt height} sono le dimensioni della casella, espresse rispettivamente in caratteri e righe.

{\tt insert} inserisce del testo nel controllo Text:

\begin{verbatim}
text.insert(END, 'Una riga di testo.')
\end{verbatim}
%
{\tt END} è un indice speciale che indica l'ultimo carattere presente nella casella di testo.

Potete anche specificare una posizione usando un indice puntato, come {\tt 1.1},
dove il numero prima del punto è la riga e quello dopo il punto è la colonna. L'esempio che segue aggiunge le lettere \verb"'altr" dopo il secondo carattere della prima riga.

\begin{verbatim}
>>> text.insert(1.2, "'altr")
\end{verbatim}
%
Il metodo {\tt get} legge il testo nel controllo; prende come argomenti un indice di inizio e uno di fine. L'esempio seguente restituisce tutto il testo nel controllo, incluso il carattere di ritorno a capo:

\begin{verbatim}
>>> text.get(0.0, END)
'Un'altra riga di testo.\n'
\end{verbatim}
%
Il metodo {\tt delete} cancella il testo dal controllo; questo esempio cancella tutto, tranne i primi due caratteri del testo:

\begin{verbatim}
>>> text.delete(1.2, END)
>>> text.get(0.0, END)
'Un\n'
\end{verbatim}
%

\vspace{0.2in}
\begin{exercise}
\label{circle2}

Modificate la soluzione dell'Esercizio~\ref{circle} aggiungendo un controllo Entry e un secondo pulsante. Quando l'utente preme il secondo pulsante, il programma deve leggere il nome di un colore dalla casella di testo e usarlo per cambiare il colore di riempimento del cerchio. Usate {\tt config}
per modificare il cerchio esistente, senza crearne uno nuovo.

Il programma deve gestire i casi in cui l'utente cerca di cambiare il colore di un cerchio che non è ancora stato creato, oppure il nome del colore non è valido.

Potete scaricare la mia soluzione dal sito \url{http://thinkpython.com/code/circle_demo.py}.

\end{exercise}


\section{Packing dei controlli}

Sinora abbiamo impilato i controlli uno sull'altro, su una sola colonna, ma di norma l'aspetto delle interfacce grafiche è più articolato. Per esempio, la Figura~\ref{fig.turtleworld} mostra una versione semplificata di
TurtleWorld (vedere Capitolo~\ref{turtlechap}).

\begin{figure}
\centerline{\includegraphics[scale=0.5]{figs/TurtleWorld.pdf}}
\caption{TurtleWorld dopo l'esecuzione del codice che disegna un fiocco di neve.}
\label{fig.turtleworld}
\end{figure}


In questo Paragrafo illustriamo il codice che crea questa GUI, passo dopo passo. Potete scaricare l'esempio completo da \url{http://thinkpython.com/code/SimpleTurtleWorld.py}.

Al livello superiore, questa GUI contiene due controlli---un Canvas e un Frame---disposti affiancati su una riga. Il primo passo è quindi creare la riga.
\index{SimpleTurtleWorld, classe}
\index{classe!SimpleTurtleWorld}

\begin{verbatim}
class SimpleTurtleWorld(TurtleWorld):
    """Questa classe è identica a TurtleWorld, ma il codice che
    compone la GUI è semplificato per motivi didattici."""

    def setup(self):
        self.row()
        ...
\end{verbatim}
%
{\tt setup} è la funzione che crea e dispone i controlli. La disposizione dei controlli in una GUI è chiamata {\bf packing}.
\index{packing dei controlli}
\index{controlli, packing}
\index{Frame, controllo}
\index{controllo!Frame}

{\tt row} crea un Frame riga e lo rende il ``Frame attivo''.
Finché questo frame non viene chiuso o un altro Frame non viene creato, tutti i controlli successivi verranno disposti su una riga.

Ecco il codice che crea il controllo Canvas e il Frame colonna che contiene gli altri controlli:

\begin{verbatim}
        self.canvas = self.ca(width=400, height=400, bg='white')
        self.col()
\end{verbatim}
%
Il primo controllo nella colonna è un Frame griglia che contiene quattro pulsanti disposti a coppie:

\begin{verbatim}
        self.gr(cols=2)
        self.bu(text='Print canvas', command=self.canvas.dump)
        self.bu(text='Quit', command=self.quit)
        self.bu(text='Make Turtle', command=self.make_turtle)
        self.bu(text='Clear', command=self.clear)
        self.endgr()
\end{verbatim}
%
{\tt gr} crea la griglia; l'argomento è il numero delle colonne. Nella griglia, i controlli vengono disposti nell'ordine da sinistra verso destra e dall'alto verso il basso.
\index{callback}
\index{metodo collegato}
\index{soggetto}

Il primo pulsante usa {\tt self.canvas.dump} come callback; il secondo usa {\tt self.quit}.  Questi sono {\bf metodi collegati}, cioè metodi associati ad uno specifico oggetto. Quando vengono invocati, lo sono sull'oggetto.

Il metodo successivo nella colonna è un Frame riga che contiene un pulsante e una casella di testo semplice:

\begin{verbatim}
        self.row([0,1], pady=30)
        self.bu(text='Run file', command=self.run_file)
        self.en_file = self.en(text='snowflake.py', width=5)
        self.endrow()
\end{verbatim}
%
Il primo argomento di {\tt row} è una lista di pesi che determina come viene ripartito lo spazio sovrabbondante tra i controlli presenti. La lista {\tt [0,1]} significa che tutto lo spazio extra viene assegnato al secondo controllo, cioè alla casella di testo. Se eseguite il codice e massimizzate la finestra, vedrete che la casella di testo si espande ma il pulsante no.

L'opzione {\tt pady} allarga la riga in direzione dell'asse $y$, aggiungendo 30 pixel di spazio sopra e sotto.

{\tt endrow} chiude questa riga di controlli, pertanto quelli seguenti verranno inseriti nel Frame colonna.   {\tt Gui.py} mantiene una coda dei Frame:

\begin{itemize}

\item Quando usate {\tt row}, {\tt col} o {\tt gr} per creare un Frame, questo va in cima alla coda e diventa il Frame attivo.

\item Quando usate {\tt endrow}, {\tt endcol} o {\tt endgr} per chiudere un Frame, questo viene eliminato dalla coda, e il Frame che precede nella coda diventa il Frame attivo.

\end{itemize} 

Il metodo \verb"run_file" legge il contenuto della casella di testo, lo usa come nome di file, legge i contenuti del file e li passa a \verb"run_code".  {\tt self.inter} è un oggetto Interprete capace di prendere una stringa ed eseguirla come codice Python.

\begin{verbatim}
    def run_file(self):
        filename = self.en_file.get()
        fp = open(filename)
        source = fp.read()
        self.inter.run_code(source, filename)
\end{verbatim}
%
Gli ultimi due controlli sono una casella di testo Text e un pulsante:

\begin{verbatim}
        self.te_code = self.te(width=25, height=10)
        self.te_code.insert(END, 'world.clear()\n')
        self.te_code.insert(END, 'bob = Turtle(world)\n')

        self.bu(text='Run code', command=self.run_text)
\end{verbatim}
%
\verb"run_text" è simile a \verb"run_file" a parte il fatto che legge il codice da un controllo Text anziché da un file:

\begin{verbatim}
    def run_text(self):
        source = self.te_code.get(1.0, END)
        self.inter.run_code(source, '<user-provided code>')
\end{verbatim}
%
Sfortunatamente, i dettagli della disposizione dei controlli sono diversi in altri linguaggi e tra i diversi moduli di Python. Tkinter stesso ha tre meccanismi diversi per disporre i controlli, detti {\bf gestori di geometria}.
Quello che ho illustrato in questo Capitolo è il gestore di geometria ``a griglia''; gli altri sono chiamati ``a pacchetto'' e ``a posizione''.
\index{gestore di geometria}

In compenso, molti dei concetti di questo Capitolo si applicano anche ad altri moduli GUI e ad altri linguaggi.


\section{Menu e oggetti Callable}
\index{Menubutton, controllo}
\index{controllo!Menubutton}

Un Menubutton è un controllo che ha l'aspetto di un pulsante, ma che quando viene premuto visualizza un menu. Dopo che l'utente ha scelto un elemento, il menu scompare.

Questo codice (scaricabile da \url{http://thinkpython.com/code/menubutton_demo.py}) crea un Menubutton che propone una scelta di colori:

\begin{verbatim}
g = Gui()
g.la('Scegliere un colore:')
colors = ['red', 'green', 'blue']
mb = g.mb(text=colors[0])
\end{verbatim}
%
{\tt mb} crea il Menubutton. In prima battuta, il testo del pulsante è il nome del colore predefinito. Il ciclo seguente crea un elemento di menu per ciascun colore:

\begin{verbatim}
for color in colors:
    g.mi(mb, text=color, command=Callable(set_color, color))
\end{verbatim}
%
Il primo argomento di {\tt mi} è il Menubutton al quale sono associati gli elementi di menu.
\index{callback}
\index{Callable, oggetto}
\index{oggetto!Callable}

L'opzione {\tt command} è un oggetto Callable, che è un qualcosa di nuovo.
Finora abbiamo visto funzioni e metodi collegati usati come callback, che funzionano bene, a patto di non dover passare argomenti alla funzione. Altrimenti, dovete costruire un oggetto Callable che contiene una funzione, come \verb"set_color", e i suoi argomenti, come {\tt color}.

L'oggetto Callable mantiene un riferimento alla funzione e agli argomenti sotto forma di attributi. Poi, quando l'utente fa click su un elemento del menu, il callback chiama la funzione e le passa gli argomenti così archiviati.

Ecco come si presenta \verb"set_color":

\begin{verbatim}
def set_color(color):
    mb.config(text=color)
    print color
\end{verbatim}
%
Quando l'utente seleziona una voce di menu e viene chiamato \verb"set_color", questo configura il Menubutton per visualizzare il colore scelto. Stampa inoltre il nome del colore; se provate questo esempio, avrete la conferma che
\verb"set_color" viene chiamato quando selezionate una voce (e {\em non} quando create l'oggetto Callable).


\section{Binding}
\index{binding}
\index{callback}

Un {\bf binding} è un'associazione tra un controllo, un evento e un callback: quando un evento (come la pressione di un pulsante) avviene su un controllo, viene invocato il callback. 

Molti controlli hanno dei binding di default. Ad esempio, premendo un pulsante, il binding di default cambia l'effetto in rilievo del pulsante facendolo sembrare incassato. Quando si rilascia il pulsante, il binding ripristina l'aspetto del pulsante e chiama il callback specificato con l'opzione {\tt command}.

Potete usare il metodo {\tt bind} per sovrascrivere i binding di default o per aggiungerne di nuovi. Per esempio, il codice seguente crea un binding per un oggetto Canvas (potete scaricare il codice di questo Paragrafo da \url{http://thinkpython.com/code/draggable_demo.py}):

\begin{verbatim}
ca.bind('<ButtonPress-1>', make_circle)
\end{verbatim}
%
Il primo argomento è una stringa evento; questo evento è scatenato quando l'utente preme il pulsante sinistro del mouse. Altri eventi legati al mouse sono {\tt ButtonMotion}, {\tt ButtonRelease} e {\tt Double-Button}.
\index{stringa evento}
\index{gestore di evento}
\index{evento!gestore di}
\index{evento!stringa}

Il secondo argomento è un gestore di evento, che è una funzione o un metodo collegato, come un callback, ma una differenza importante è che un gestore di evento prende come parametro un oggetto Evento. Un esempio:

\begin{verbatim}
def make_circle(event):
    pos = ca.canvas_coords([event.x, event.y])
    item = ca.circle(pos, 5, fill='red')
\end{verbatim}
%
L'oggetto Evento contiene informazioni sul tipo di evento e dettagli come le coordinate del puntatore del Mouse. In questo esempio, le informazione di cui abbiamo bisogno è l'ubicazione del click del mouse. Questi valori sono in ``coordinate pixel'', che sono definite dal sistema grafico sottostante. Il metodo \verb"canvas_coords" le trasforma in ``coordinate del Canvas'', che sono compatibili con i metodi dell'oggetto Canvas come {\tt circle}.
\index{Evento, oggetto}
\index{oggetto!Evento}

I controlli Entry sono frequentemente collegati all'evento \verb"<Return>" che si verifica quando l'utente preme il tasto {\sf Invio} o {\sf Return}.  Ad esempio il codice seguente crea un Button e un Entry.

\begin{verbatim}
bu = g.bu('Make text item:', make_text)
en = g.en()
en.bind('<Return>', make_text)
\end{verbatim}
%
\verb"make_text" viene chiamato quando viene premuto il pulsante o quando l'utente preme {\sf Invio} dopo aver scritto qualcosa nella casella di testo. Per fare funzionare il tutto, ci serve una funzione che possa essere chiamata come command (senza argomenti) o gestore di eventi (con un Evento come argomento):

\begin{verbatim}
def make_text(event=None):
    text = en.get()
    item = ca.text([0,0], text)
\end{verbatim}
%
\verb"make_text" prende il contenuto della casella di testo Entry e lo visualizza come elemento di testo nel controllo Canvas.

È anche possibile creare dei binding per gli elementi (Item) di un Canvas. Quella che segue è una definizione di classe per {\tt Draggable}, una sottoclasse di {\tt Item} che fornisce binding che implementano capacità di drag-and-drop.
\index{drag-and-drop}

\begin{verbatim}
class Draggable(Item):

    def __init__(self, item):
        self.canvas = item.canvas
        self.tag = item.tag
        self.bind('<Button-3>', self.select)
        self.bind('<B3-Motion>', self.drag)
        self.bind('<Release-3>', self.drop)
\end{verbatim}
%
Il metodo init prende un oggetto Item come parametro. Copia gli attributi di Item e quindi crea dei binding per tre eventi: la pressione di un pulsante, lo spostamento del pulsante e il rilascio del pulsante.

Il gestore di eventi {\tt select} registra le coordinate dell'evento corrente e il colore iniziale dell'elemento, quindi cambia il colore in giallo:

\begin{verbatim}
    def select(self, event):
        self.dragx = event.x
        self.dragy = event.y

        self.fill = self.cget('fill')
        self.config(fill='yellow')
\end{verbatim}
%
{\tt cget} sta per ``get configuration''; prende il nome di un'opzione come stringa e restituisce il valore attuale di quell'opzione. 

{\tt drag} calcola di quanto l'oggetto è stato spostato rispetto al punto iniziale, aggiorna le coordinate, quindi sposta l'elemento.
\index{aggiornamento!di coordinate}

\begin{verbatim}
    def drag(self, event):
        dx = event.x - self.dragx
        dy = event.y - self.dragy

        self.dragx = event.x
        self.dragy = event.y

        self.move(dx, dy)
\end{verbatim}
%
Questo calcolo è fatto in coordinate pixel; non è necessaria la conversione in coordinate del Canvas.
\index{Canvas!coordinate}
\index{coordinate!Canvas}
\index{pixel, coordinate}
\index{coordinate!pixel}

Infine, {\tt drop} ripristina il colore iniziale dell'elemento:

\begin{verbatim}
    def drop(self, event):
        self.config(fill=self.fill)
\end{verbatim}
%
Potete usare la classe {\tt Draggable} per aggiungere funzionalità drag-and-drop ad un elemento esistente. Per esempio, questa è una versione modificata di \verb"make_circle" che usa {\tt circle} per creare un Item e {\tt Draggable} per renderlo trascinabile:

\begin{verbatim}
def make_circle(event):
    pos = ca.canvas_coords([event.x, event.y])
    item = ca.circle(pos, 5, fill='red')
    item = Draggable(item)
\end{verbatim}
%
Questo esempio dimostra uno dei benefici dell'ereditarietà: potete modificare le proprietà di una classe madre senza modificare la sua definizione. Cosa particolarmente utile se volete cambiare il comportamento definito in un modulo che non avete scritto voi.


\section{Debug}
\index{debug}

Una delle problematiche della programmazione di GUI è tenere traccia di ciò che succede mentre la GUI viene costruita e di ciò che succede poi in risposta alle azioni dell'utente.
\index{callback}

Per esempio, quando impostate un callback, un errore frequente è chiamare la funzione invece di passarle un riferimento:

\begin{verbatim}
def il_callback():
    print 'Chiamato.'

g.bu(text='Sbagliato!', command=il_callback())
\end{verbatim}
%
Se eseguite questo codice, vedrete che chiama \verb"il_callback"
immediatamente, e {\em dopo} crea il pulsante. Quando premete il pulsante, non succede nulla perché il valore di ritorno di \verb"il_callback" è {\tt None}.
In genere, non dovete invocare un callback mentre state impostando la GUI; va invocato solo in risposta ad un evento generato dall'utente.
\index{flusso di esecuzione}
\index{programmazione!orientata agli eventi}

Un altro problema della programmazione di GUI è che non avete controllo sul flusso di esecuzione. Sono le azioni dell'utente a determinare quali parti del programma vengono eseguite e in che ordine. Questo significa che dovete progettare il programma in modo che funzioni correttamente per tutte le possibili sequenze di eventi.

Ad esempio, la GUI nell'Esercizio~\ref{circle2} ha due controlli: uno crea un elemento Circle e l'altro ne cambia il colore. Se l'utente crea il cerchio e poi cambia il colore va tutto bene. Ma cosa succede se l'utente cambia il colore di un cerchio che non esiste ancora? O crea più di un cerchio?

Più cresce il numero di controlli, più risulta difficile prevedere tutte le possibili sequenze di eventi. Un modo di gestire questa complessità è incapsulare la situazione del sistema in un oggetto e quindi considerare:

\begin{itemize}

\item Quali sono le possibili situazioni? Nell'esempio del cerchio, dobbiamo considerarne due: prima e dopo che l'utente ha creato il primo cerchio.

\item In ciascuna situazione, che eventi possono verificarsi? Nell'esempio, l'utente può premere uno dei due pulsanti o uscire dal programma.

\item Per ogni coppia situazione-evento, qual è il risultato desiderato? Siccome ci sono due situazioni e due pulsanti, ci sono quattro coppie situazione-evento da considerare.

\item Cosa può causare una transizione da una situazione a un'altra? In questo caso, c'è una transizione quando l'utente crea il primo cerchio.

\end{itemize}

Può essere anche utile definire e controllare delle invarianti che dovrebbero valere indipendentemente dalla sequenza di eventi.
\index{invariante}

Questo approccio alla programmazione di GUI vi può aiutare a scrivere del codice corretto, senza perdere tempo a provare ogni possibile sequenza di eventi generati dall'utente!


\section{Glossario}

\begin{description}

\item[GUI:] Un'interfaccia grafica utente.
\index{GUI}

\item[controllo o widget:] Uno degli elementi che costituiscono una GUI, come pulsanti, menu, caselle di testo, ecc. 
\index{widget}
\index{controllo}

\item[opzione:] Un valore da cui dipende l'aspetto o la funzione di un controllo.
\index{opzione}

\item[argomento con nome:] Argomento che indica il nome del parametro che fa parte della chiamata di una funzione.
\index{argomento!con nome}

\item[callback:] Funzione associata ad un controllo che viene chiamata quando l'utente esegue una determinata azione. 
\index{callback}

\item[metodo collegato:] Metodo associato ad una particolare istanza.
\index{metodo collegato}

\item[programmazione ad eventi:] Stile di programmazione in cui il flusso di esecuzione è determinato dalle azioni dell'utente.
\index{programmazione!orientata agli eventi}

\item[evento:] Un'azione dell'utente, come un click del mouse o la pressione di un tasto, che causa una risposta della GUI.
\index{evento}

\item[evento ciclico:] Ciclo infinito che attende un'azione dell'utente e risponde.
\index{evento!ciclico}

\item[elemento o item:] Elemento grafico su un controllo Canvas.
\index{elemento!Canvas}

\item[contenitore:] Rettangolo che include un insieme di elementi, di solito identificato mediante due angoli opposti.
\index{contenitore}

\item[packing:] Disporre gli elementi su una GUI.
\index{packing dei controlli}

\item[gestore di geometria:] Sistema di packing dei controlli in una GUI.
\index{gestore di geometria}

\item[binding:] Associazione tra un controllo, un evento e un gestore di evento. Il gestore di evento viene chiamato quando si verifica l'evento nel controllo.
\index{binding}

\end{description}


\section{Esercizi}

\begin{exercise}
\index{immagini, visualizzatore di}

In questo esercizio, scriverete un visualizzatore di immagini. Ecco un semplice esempio:

\begin{verbatim}
g = Gui()
canvas = g.ca(width=300)
photo = PhotoImage(file='danger.gif')
canvas.image([0,0], image=photo)
g.mainloop()
\end{verbatim}
%
{\tt PhotoImage} legge un file e restituisce un oggetto {\tt PhotoImage} che Tkinter è in grado di visualizzare.  {\tt Canvas.image} dispone l'immagine nell'area di lavoro, centrata sulle coordinate date. Potete mettere immagini anche su etichette, pulsanti, e qualche altro controllo:

\begin{verbatim}
g.la(image=photo)
g.bu(image=photo)
\end{verbatim}
%
PhotoImage può gestire solo pochi formati di immagine, come GIF e PPM, ma possiamo far uso della Python Imaging Library (PIL) per leggerne altri.
\index{Python Imaging Library (PIL)}
\index{PIL (Python Imaging Library)}
\index{Image, modulo}
\index{modulo!Image}

Il nome del modulo PIL è {\tt Image}, ma Tkinter definisce già un oggetto con lo stesso nome. Per evitare conflitti, dovete usare {\tt import...as} in questo modo:

\begin{verbatim}
import Image as PIL
import ImageTk
\end{verbatim}
%
La prima riga importa {\tt Image} assegnandogli il nome locale {\tt PIL}.  La seconda importa {\tt ImageTk}, che è in grado di trasformare un'immagine PIL in un PhotoImage di Tkinter. Ecco un esempio: 

\begin{verbatim}
image = PIL.open('allen.png')
photo2 = ImageTk.PhotoImage(image)
g.la(image=photo2)
\end{verbatim}
%

\begin{enumerate}

\item Scaricate \verb"image_demo.py", \verb"danger.gif" e \verb"allen.png"
da \url{http://thinkpython.com/code}.  Eseguite \verb"image_demo.py".  Probabilmente dovrete installare {\tt PIL} e {\tt ImageTk},  
che dovrebbero essere presenti nel vostro repository software, altrimenti li potete scaricare da \url{http://pythonware.com/products/pil}.

\item In \verb"image_demo.py" cambiate il nome del secondo
PhotoImage da {\tt photo2} a {\tt photo} ed eseguite di nuovo il programma. Dovreste riuscire a vedere il secondo Photoimage ma non il primo.

Il problema sta nel fatto che quando riassegnate {\tt photo}, sovrascrive il riferimento al primo PhotoImage, che così sparisce. Lo stesso capita se assegnate un PhotoImage a una variabile locale: sparisce quando la funzione termina.

Per evitare questo problema dovete registrare un riferimento ad ogni
PhotoImage che volete mantenere. Potete usare una variabile globale, o conservarli in una struttura di dati o come attributi di un oggetto.

Questo comportamento può dare dei fastidi, ed è il motivo per cui vi sto mettendo sull'avviso (e l'immagine di esempio dice ``Pericolo!'').
\index{bug!il peggiore}
\index{peggior bug}

\item Partendo da questo esempio, scrivete un programma che prenda il nome di una directory e analizzi con un ciclo tutti i file, mostrando quelli che PIL riconosce come immagini. Potete usare un'istruzione {\tt try}
per gestire i file non riconosciuti da PIL. 

Quando l'utente fa clic sull'immagine, il programma deve mostrare quella successiva.

\item PIL fornisce svariati metodi per trattare le immagini. Potete saperne di più leggendo \url{http://pythonware.com/library/pil/handbook}.
Per i più bravi, scegliete alcuni di questi metodi e create una GUI per applicarli alle immagini.

\end{enumerate}

Soluzione: \url{http://thinkpython.com/code/ImageBrowser.py}.

\end{exercise}

\vspace{0.2in}
\begin{exercise}
\index{grafica vettoriale}
\index{SVG}

Un editor di grafica vettoriale è un programma che consente di disegnare e modificare forme sullo schermo e generare file di output in formati grafici vettoriali come Postscript e SVG.

Scrivete un semplice editor di grafica vettoriale usando Tkinter. Per lo meno, dovrebbe consentire all'utente di disegnare linee, cerchi e rettangoli, e usare {\tt Canvas.dump} per generare una descrizione Postscript dei contenuti del Canvas.

I più coraggiosi possono anche consentire all'utente di selezionare e ridimensionare gli elementi sul Canvas.

% TODO: write a solution!

\end{exercise}

\vspace{0.2in}
\begin{exercise}

Usate Tkinter per scrivere un web browser basilare. Deve avere un controllo Text dove l'utente può scrivere l'indirizzo web e un Canvas per mostrare il contenuto della pagina.
\index{urllib, modulo}
\index{modulo!urllib}
\index{URL}
\index{HTMLParser, modulo}
\index{modulo!HTMLParser}

Per scaricare i file usate il modulo {\tt urllib} (vedere Esercizio~\ref{urllib}) e per analizzare i tag HTML il modulo {\tt HTMLParser} (vedere \url{http://docs.python.org/2/library/htmlparser.html}).
\index{testo!semplice}
\index{hyperlink}

Come minimo il vostro web browser dovrebbe gestire il testo semplice e i collegamenti. Se volete fare di più, anche i colori di sfondo, i tag di formattazione del testo e le immagini.

% TODO: write a solution!

\end{exercise}



\appendix

\chapter{Debug}

\index{debug}
In un programma si possono verificare diversi tipi di errore, ed è utile distinguerli in modo da poterli rintracciare più velocemente:

\begin{itemize}

\item Gli errori di sintassi sono prodotti da Python quando traduce il codice sorgente in codice macchina. Di solito, indicano che c'è qualcosa di sbagliato nella sintassi del programma. Esempio: omettere i due punti alla fine di una istruzione {\tt def} provoca il messaggio, un po' ridondante, {\tt SyntaxError: invalid syntax}.

\item Gli errori di runtime sono prodotti dall'interprete se qualcosa va storto durante l'esecuzione del programma. Nella maggior parte dei casi, il messaggio di errore specifica dove si è verificato l'errore e quali funzioni erano in esecuzione. Esempio: una ricorsione infinita causa un errore di runtime ``{\tt maximum recursion depth exceeded}''.

\item Gli errori di semantica sono dei problemi con un programma che viene eseguito senza produrre messaggi di errore, ma che non fa le cose nel modo giusto. Esempio: un'espressione può essere valutata secondo un ordine diverso da quello che si intendeva, generando un risultato non corretto.

\end{itemize}
\index{sintassi!errore di}
\index{errore!di sintassi}
\index{errore!in esecuzione}
\index{errore!di runtime}
\index{semantica!errore di}
\index{errore!di semantica}
\index{eccezione}

La prima cosa da fare nel debug è capire con che tipo di errore abbiamo a che fare. Anche se i paragrafi che seguono sono organizzati per tipo di errore, alcune tecniche sono applicabili in più di una situazione.


\section{Errori di sintassi}
\index{errore!messaggio di}

Gli errori di sintassi sono in genere facili da sistemare, una volta capito in cosa consistono. Purtroppo, il messaggio di errore spesso è poco utile. Quelli più comuni sono: {\tt SyntaxError: invalid syntax} e
{\tt SyntaxError: invalid token}, nessuno dei quali è molto esplicativo.

In compenso, il messaggio comunica il punto del programma dove si è verificato il problema. Più precisamente, dice dove Python ha notato il problema, che non è necessariamente il punto in cui si trova l'errore.
A volte l'errore è prima del punto indicato dal messaggio, spesso nella riga precedente.
\index{sviluppo incrementale}
\index{tecnica di sviluppo!incrementale}

Se state costruendo il programma in modo incrementale, è molto probabile che l'errore sia nell'ultima riga che avete aggiunto.

Se state copiando il codice da un libro, cominciate confrontando attentamente il vostro codice con quello del libro. Controllate ogni carattere. Ricordate però che anche il libro può essere sbagliato, e se vedete qualcosa che somiglia a un errore di sintassi, potrebbe esserlo.

Ecco alcuni modi di evitare i più comuni errori di sintassi:
\index{sintassi}

\begin{enumerate}

\item Accertatevi di non usare parole chiave di Python come nomi di variabile.
\index{parola chiave}

\item Controllate che ci siano i due punti alla fine di ogni intestazione di ogni istruzione composta, inclusi {\tt for}, {\tt while},
{\tt if}, e le istruzioni {\tt def}.
\index{intestazione}
\index{due punti}

\item Accertatevi che ogni stringa nel codice sia racchiusa da una coppia di virgolette o apici.
\index{virgolette}

\item Se avete stringhe a righe multiple con triple virgolette, accertatevi di averle chiuse in modo appropriato. Una stringa non chiusa può causare un errore di {\tt invalid token} al termine del programma, oppure può trattare la parte che segue del programma come fosse una stringa, finché non incontra la stringa successiva. Nel secondo caso, potrebbe anche non produrre affatto un messaggio di errore!
\index{stringa!a righe multiple}

\item Un operatore di apertura non chiuso---\verb+(+, \verb+{+, o
  \verb+[+---fa sì che Python consideri la riga successiva come parte dell'istruzione corrente. In genere, si verifica un errore nella riga immediatamente successiva.

\item Controllate che non ci sia il classico {\tt =} al posto di {\tt ==} all'interno di un'istruzione condizionale.
\index{istruzione!condizionale}

\item Controllate l'indentazione per assicurarvi che allinei il codice nel modo corretto. Python può gestire sia spazi che tabulazioni, ma se li mescolate possono esserci problemi. Il modo migliore di evitarli è usare un editor di testo appositamente realizzato per Python, che gestisca l'indentazione in modo coerente.
\index{indentazione}
\index{spazi}

\end{enumerate}

Se nulla di tutto questo funziona, continuate con il paragrafo seguente...


\subsection{Continuo a fare modifiche ma non cambia nulla.}

Se l'interprete dice che c'è un errore ma non lo trovate, può essere che voi e l'interprete non stiate guardando lo stesso codice. Controllate il vostro ambiente di programmazione per assicurarvi che il programma che state modificando sia proprio quello che Python sta tentando di eseguire.

Se non ne siete certi, provate a mettere deliberatamente un evidente errore di sintassi all'inizio del programma e rieseguitelo. Se l'interprete non trova l'errore, non state eseguendo il nuovo codice.

Alcune cause possibili:

\begin{itemize}

\item Avete modificato il file e dimenticato di salvare le modifiche prima dell'esecuzione. Alcuni ambienti di programmazione lo fanno automaticamente, ma altri no.

\item Avete cambiato il nome del file, ma state eseguendo ancora quello con il vecchio nome.

\item Qualcosa nel vostro ambiente di sviluppo non è configurato correttamente.

\item Se state scrivendo un modulo usando {\tt import}, accertatevi di non dare al vostro modulo lo stesso nome di uno dei moduli standard di Python.
\index{modulo!reload}
\index{reload, funzione}
\index{funzione!reload}

\item Se state usando {\tt import} per leggere un modulo, ricordatevi che dovete riavviare l'interprete o usare {\tt reload} per leggere un file modificato. Se importate nuovamente il modulo, non succederà nulla.

\end{itemize}

Se vi bloccate e non riuscite a capire cosa sta succedendo, un'alternativa è ripartire con un nuovo programma come ``Ciao, mondo!'', e accertarvi di avere un programma ben conosciuto da eseguire. Quindi, aggiungete gradualmente i pezzi del programma originale a quello nuovo.


\section{Errori di runtime}

Una volta che il programma è sintatticamente corretto, Python può compilarlo e quantomeno cominciare ad eseguirlo. Cosa può succedere di spiacevole?


\subsection{Il programma non fa assolutamente nulla.}

È il problema più frequente se il vostro file consiste di funzioni e classi, ma in realtà non invoca nulla per avviare l'esecuzione. Può essere una cosa intenzionale, se intendete utilizzarlo solo come modulo da importare allo scopo di fornire le classi e le funzioni.

Se non è questo il caso, assicuratevi che venga invocata una funzione per avviare l'esecuzione, o eseguitene una dal prompt interattivo. Vedete anche il paragrafo ``Flusso di esecuzione'' più avanti.


\subsection{Il programma si blocca.}
\index{ciclo!infinito}
\index{ricorsione!infinita}
\index{blocco}

Se un programma si blocca e pare che non stia succedendo nulla, spesso vuol dire che è incappato in un ciclo infinito o in una ricorsione infinita.

\begin{itemize}

\item Se c'è un ciclo particolare dove sospettate che stia il problema, aggiungete un'istruzione di stampa immediatamente prima del ciclo che dice:
``Sto entrando nel ciclo'' e una immediatamente dopo che dice:
``Sto uscendo dal ciclo''.

Eseguite il programma. Se viene visualizzato il primo messaggio ma non il secondo, c'è un ciclo infinito. Proseguite con il Paragrafo ``Ciclo infinito'' più sotto.

\item Il più delle volte, in presenza di una ricorsione infinita, il programma funziona per qualche tempo per poi produrre un errore ``RuntimeError: Maximum
recursion depth exceeded''.  Se succede questo, andate al Paragrafo
``Ricorsione infinita''.

Se non ottenete questo errore ma sospettate che ci sia un problema con un metodo o funzione ricorsivi, potete usare ugualmente le tecniche illustrate nel Paragrafo ``Ricorsione infinita''.

\item Se nessuno di questi punti funziona, fate delle prove su altri cicli o funzioni e metodi ricorsivi.

\item Se ancora non funziona, forse non avete ben chiaro il flusso di esecuzione del vostro programma. Andate al relativo Paragrafo.

\end{itemize}


\subsubsection{Ciclo infinito}
\index{ciclo!infinito}
\index{condizione}
\index{ciclo!condizione}

Se sospettate che vi sia un ciclo infinito e di sapere quale ciclo in particolare stia causando il problema, aggiungete un'istruzione di stampa alla fine del ciclo in modo da visualizzare il valore delle variabili nella condizione e il valore della condizione.

Per esempio:

\begin{verbatim}
while x > 0 and y < 0 :
    # fa qualcosa con x
    # fa qualcosa con y

    print "x: ", x
    print "y: ", y
    print "condizione: ", (x > 0 and y < 0)
\end{verbatim}
%
Ora, eseguendo il programma, vedrete tre righe di output per ogni ripetizione del ciclo. All'ultimo passaggio, la condizione dovrebbe risultare {\tt False}.  Se il ciclo continua, vedrete comunque i valori di {\tt x} e {\tt y}, e potrete capire meglio il motivo per cui non vengono aggiornati correttamente.


\subsubsection{Ricorsione infinita}
\index{ricorsione!infinita}

Il più delle volte, una ricorsione infinita provocherà un errore di {\tt Maximum recursion depth exceeded}.

Se sospettate che una funzione o un metodo stia provocando una ricorsione infinita, controllate innanzitutto che esista un caso base, vale a dire un qualche tipo di condizione che provoca il ritorno della funzione o del metodo senza generare un'altra chiamata ricorsiva. Se no, occorre ripensare l'algoritmo e stabilire un caso base.

Se il caso base c'è ma sembra che il programma non lo raggiunga mai, aggiungete un'istruzione di stampa all'inizio della funzione/metodo in modo da visualizzare i parametri. Ora, eseguendo il programma vedrete alcune righe di output con i parametri per ogni chiamata alla funzione o al metodo. Se i parametri non tendono verso il caso base, avrete qualche spunto per capire il perché.


\subsubsection{Flusso di esecuzione}
\index{flusso di esecuzione}

Se non siete sicuri di come il flusso di esecuzione si muova dentro il vostro programma, aggiungete delle istruzioni di stampa all'inizio di ogni funzione con un messaggio del tipo ``sto eseguendo la funzione {\tt pippo}'', dove
{\tt pippo} è il nome della funzione.

Ora, eseguendo il programma, verrà stampata una traccia di ogni funzione che viene invocata.


\subsection{Quando eseguo il programma è sollevata un'eccezione.}
\index{eccezione}
\index{errore!in esecuzione}

Se qualcosa non va durante l'esecuzione, Python stampa un messaggio che include il nome dell'eccezione, la riga del programma dove il problema si è verificato, ed un traceback.
\index{traceback}

Il traceback identifica la funzione che era in esecuzione, quella che l'aveva chiamata, quella che {\em a sua volta} l'aveva chiamata e così via. In altre parole, traccia la sequenza di chiamate di funzione che hanno condotto alla situazione attuale. Include anche il numero di riga del file dove è avvenuta ciascuna chiamata.

Innanzitutto bisogna esaminare il punto del programma dove è emerso l'errore e vedere se si riesce a capire cosa è successo. Questi sono alcuni dei più comuni errori in esecuzione:

\begin{description}

\item[NameError:]  State cercando di usare una variabile che non esiste nell'ambiente attuale. Ricordate che le variabili locali sono, per l'appunto, locali: non potete fare loro riferimento dall'esterno della funzione in cui sono definite.
\index{NameError}
\index{TypeError}
\index{eccezione!NameError}
\index{eccezione!TypeError}

\item[TypeError:] Ci sono alcune possibili cause:

\begin{itemize}

\item  State cercando di usare un valore in modo improprio. Esempio: indicizzare una stringa, lista o tupla con qualcosa di diverso da un numero intero. 
\index{indice}

\item C'è una mancata corrispondenza tra gli elementi in una stringa di formato e gli elementi passati per la conversione. Succede se il numero degli elementi non corrisponde o se viene tentata una conversione non valida.
\index{formato!operatore di}
\index{operatore!di formato}

\item State passando a una funzione o a un metodo un numero sbagliato di argomenti. Per i metodi, guardatetene la definizione e controllate che il primo parametro sia {\tt self}.  Quindi guardate l'invocazione: assicuratevi di invocare il metodo su un oggetto con il giusto tipo e di fornire correttamente gli altri argomenti.

\end{itemize}

\item[KeyError:]  State tentando di accedere a un elemento di un dizionario usando una chiave che nel dizionario non esiste.
\index{KeyError}
\index{eccezione!KeyError}
\index{dizionario}

\item[AttributeError:] State tentando di accedere a un attributo o a un metodo che non esiste. Controllate se è scritto giusto! Potete usare
{\tt dir} per elencare gli attributi esistenti.

Se un AttributeError indica che un oggetto è di tipo {\tt NoneType},
vuol dire che è {\tt None}.  Una causa frequente è dimenticare di ritornare un valore da una funzione: se arrivate in fondo a una funzione senza intercettare un'istruzione {\tt return}, questa restituisce {\tt None}.  Un'altra causa frequente è usare il risultato di un metodo di una lista, come {\tt sort}, che restituisce {\tt None}.
\index{AttributeError}
\index{eccezione!AttributeError}

\item[IndexError:] L'indice che state usando per accedere a una lista, stringa o tupla è maggiore della lunghezza della sequenza meno uno. Immediatamente prima dell'ubicazione dell'errore aggiungete un'istruzione di stampa che mostri il valore dell'indice e la lunghezza della struttura. Quest'ultima è della lunghezza esatta? E l'indice ha il valore corretto?
\index{IndexError}
\index{eccezione!IndexError}

\end{description}
\index{debugger (pdb)}
\index{Python debugger (pdb)}
\index{pdb (Python debugger)}

Il debugger Python ({\tt pdb}) è utile per catturare le Eccezioni perché vi permette di esaminare lo stato del programma immediatamente prima dell'errore. Potete leggere approfondimenti su {\tt pdb} sul sito \url{http://docs.python.org/2/library/pdb.html}.


\subsection{Ho aggiunto talmente tante istruzioni di stampa che sono sommerso di output.}
\index{print, istruzione}
\index{istruzione!print}

Una controindicazione delle istruzioni di stampa nel debugging è che si rischia di essere inondati di messaggi. Ci sono due modi di procedere: o semplificate l'output o semplificate il programma.

Per semplificare l'output, potete rimuovere o commentare le istruzioni {\tt print} superflue, o accorparle, o dare all'output un formato più leggibile.

Per semplificare il programma, ci sono diverse opzioni. Primo, riducete il problema che il programma sta affrontando. Per esempio, se state cercando una lista, cercatene una {\em piccola}.  Se il programma riceve input dall'utente, dategli il dato più semplice che causa il problema.
\index{codice morto}

Secondo, ripulite il programma. Togliete il codice inutile e riorganizzate il programma in modo da renderlo il più facile possibile da leggere. Per esempio, se sospettate che l'errore sia in una parte profondamente nidificata del programma, cercate di riscrivere quella parte con una struttura più semplice. Se sospettate di una corposa funzione, provate a suddividerla in funzioni più piccole e a testarle separatamente.
\index{test!caso di prova minimo}
\index{caso di prova minimo}

Spesso, il procedimento di ricercare il caso di prova più circoscritto porta a trovare l'errore. Se riscontrate che il programma funziona in un caso ma non in un altro, questo vi dà una chiave di lettura di quello che sta succedendo.

Allo stesso modo, riscrivere un pezzo di codice vi può aiutare a trovare errori insidiosi. Una modifica che pensavate ininfluente sul programma, e che invece influisce, può farvi trovare il bandolo della matassa.


\section{Errori di semantica}
\index{semantica!errore di}
\index{errore!di semantica}

Gli errori di semantica sono i più difficili da affrontare, perché l'interprete non fornisce informazioni su ciò che non va. Sapete solo quello che il programma dovrebbe fare.

Innanzitutto occorre stabilire una connessione logica tra il testo del programma e il comportamento che vedete. Vi serve un'ipotesi di cosa sta facendo in realtà il programma. Quello che rende difficili le cose è che i computer eseguono le operazioni in tempi rapidissimi. 

Vi capiterà di desiderare di poter rallentare il programma ad una velocità umana, e in effetti con alcuni strumenti di debug potete farlo. Ma il tempo che ci vuole per inserire alcune istruzioni di stampa ben calibrate è spesso più breve di quello necessario a impostare il debugger, inserire e togliere i punti di interruzione, ed eseguire i passi per portare il programma dove l'errore si verifica.

\subsection{Il mio programma non funziona.}

Dovreste porvi queste domande:

\begin{itemize}

\item C'è qualcosa che il programma dovrebbe fare ma che non sembra accadere? Trovate la parte del codice che esegue quella funzione e assicuratevi che sia effettivamente eseguita quando ritenete che dovrebbe esserlo.

\item Sta succedendo qualcosa che non dovrebbe succedere? Trovate il codice che genera quella funzione e controllate se viene eseguita quando invece non dovrebbe esserlo.

\item Una porzione di codice sta producendo effetti inattesi? Assicuratevi di capire il codice in questione, specie se coinvolge invocazioni a funzioni o metodi in altri moduli Python. Leggete la documentazione delle funzioni che invocate. Provatele scrivendo semplici test e controllando i risultati.

\end{itemize}

Per programmare, dovete avere un modello mentale di come funziona il programma. Se scrivete un programma che non fa quello che volete, molto spesso il problema non è nel programma ma nel vostro modello mentale.
\index{modello mentale}

Il modo migliore per correggere il vostro modello mentale è spezzare il programma nei suoi componenti (di solito funzioni e metodi) e provare indipendentemente ogni singolo componente.
Quando avrete trovato la discrepanza tra il vostro modello e la realtà, potrete risolvere il problema.

Naturalmente, dovreste costruire e provare i componenti mentre state sviluppando il programma. Così, se vi imbattete in un problema, dovrebbe esserci solo una piccola quantità di codice di cui occorre verificare l'esattezza.


\subsection{Ho una grande e complicata espressione che non fa quello che voglio.}
\index{espressione!grande e complicata}


Scrivere espressioni complesse va bene fino a quando restano leggibili, ma possono essere difficili da correggere. Un buon consiglio è di spezzare un'espressione complessa in una serie di assegnazioni a variabili temporanee.

Per esempio:

\begin{verbatim}
self.mani[i].aggiungiCarta(self.mani[self.trovaVicino(i)].togliCarta())
\end{verbatim}
%
Può essere riscritta così:

\begin{verbatim}
vicino = self.trovaVicino(i)
cartaScelta = self.mani[vicino].togliCarta()
self.mani[i].aggiungiCarta(cartaScelta)
\end{verbatim}
%
La versione esplicita è più leggibile perché i nomi delle variabili aggiungono informazione, ed è più facile da correggere perché potete controllare i tipi delle variabili intermedie e visualizzare il loro valore.
\index{variabile!temporanea}
\index{ordine delle operazioni}
\index{precedenza}

Un altro problema che si verifica con le grandi espressioni è che l'ordine di valutazione delle operazioni può essere diverso da quello che pensate.
Per esempio, nel tradurre in Python l'espressione
$\frac{x}{2 \pi}$, potreste scrivere:

\begin{verbatim}
y = x / 2 * math.pi
\end{verbatim}
%
È sbagliato, perché moltiplicazione e divisione hanno la stessa priorità e vengono calcolate da sinistra verso destra; quindi quell'espressione calcola $x \pi / 2$.

Un buon modo di fare il debug delle espressioni è aggiungere delle parentesi per rendere esplicito l'ordine delle operazioni.

\begin{verbatim}
 y = x / (2 * math.pi)
\end{verbatim}
%
Usate le parentesi ogni volta che non siete certi dell'ordine delle operazioni. Non solo il programma sarà corretto (nel senso che farà quello che volete), sarà anche più leggibile da altre persone che non hanno imparato a memoria le regole di precedenza.


\subsection{Ho una funzione o metodo che non restituisce quello che voglio.}
\index{return, istruzione}
\index{istruzione!return}

Se avete un'istruzione {\tt return} associata ad un'espressione complessa, non avete modo di stampare il valore prima del ritorno. Di nuovo, usate una variabile temporanea. Per esempio, anziché:

\begin{verbatim}
return self.mani[i].togliUguali()
\end{verbatim}
%
potete scrivere:

\begin{verbatim}
conta = self.mani[i].togliUguali()
return conta
\end{verbatim}
%
Ora potete stampare il valore di {\tt conta} prima che sia restituito.


\subsection{Sono proprio bloccato e mi serve aiuto.}

Per prima cosa, staccatevi dal computer per qualche minuto. I computer emettono onde che influenzano il cervello, causando questi sintomi:

\begin{itemize}

\item Frustrazione e rabbia.
\index{frustrazione}
\index{rabbia}
\index{debug!risposta emotiva}
\index{emotività, nel debug}

\item Credenze superstiziose (``il computer mi odia'') e influssi magici (``il programma funziona solo quando indosso il berretto all'indietro'').
\index{debug!superstizione}


\item Programmazione a tentoni (il tentativo di programmare scrivendo ogni possibile programma e prendendo quello che funziona).
\index{programmazione!a tentoni}
\index{tecnica di sviluppo!programmazione a tentoni}

\end{itemize}

Se accusate qualcuno di questi sintomi, alzatevi e andate a fare una passeggiata. Quando vi siete calmati, ripensate al programma. Cosa sta facendo? Quali sono le possibili cause del suo comportamento? Quand'era l'ultima volta che avete avuto un programma funzionante, e cosa avete fatto dopo?

A volte per trovare un bug è richiesto solo del tempo. Io trovo spesso bug mentre non sono al computer e distraggo la mente. Tra i posti migliori per trovare bug: in treno, sotto la doccia, a letto appena prima di addormentarsi.


\subsection{No, ho davvero bisogno di aiuto.}

Capita. Anche i migliori programmatori a volte si bloccano. Magari avete lavorato talmente a lungo sul programma da non riuscire a vedere un errore. Un paio di occhi freschi sono quello che ci vuole.

Prima di rivolgervi a qualcun altro, dovete fare dei preparativi. Il vostro programma dovrebbe essere il più semplice possibile, e dovete fare in modo di lavorare sul più circoscritto input che causa l'errore.
Dovete posizionare delle istruzioni di stampa nei posti adatti (e l'output che producono deve essere comprensibile). Il problema va compreso abbastanza bene da poterlo descrivere in poche parole.

Quando portate qualcuno ad aiutarvi, assicuratevi di dargli tutte le informazioni che servono:

\begin{itemize}

\item Se c'è un messaggio di errore, di cosa si tratta e quale parte del programma indica?

\item Qual è l'ultima cosa che avete fatto prima della comparsa dell'errore? Quali erano le ultime righe di codice che avevate scritto, oppure il nuovo caso di prova che non è riuscito?

\item Cosa avete provato a fare finora, e cosa avete appreso dai tentativi?

\end{itemize}

Quando trovate l'errore, prendetevi un attimo di tempo per pensare cosa avreste potuto fare per trovarlo più velocemente: la prossima volta che incontrerete qualcosa di simile, vi sarà più facile scoprire l'errore.

Ricordate che lo scopo non è solo far funzionare il programma, ma imparare a farlo funzionare.


\chapter{Analisi degli Algoritmi}

\begin{quote}
Questa Appendice è un estratto adattato da {\it Think Complexity}, di
Allen B. Downey, pure pubblicato da O'Reilly Media (2011).  Quando avete finito questo libro, vi invito a prenderlo in considerazione.
\end{quote}

L'{\bf analisi degli algoritmi} è una branca dell'informatica che studia le prestazioni degli algoritmi, in particolare il tempo di esecuzione e i requisiti di memoria. Vedere anche
\url{http://en.wikipedia.org/wiki/Analysis_of_algorithms}.
\index{algoritmo} \index{analisi degli algoritmi}

L'obiettivo pratico dell'analisi degli algoritmi è predire le prestazioni di algoritmi diversi in modo da orientare le scelte di progettazione.

Durante la campagna elettorale per le Presidenziali degli Stati Uniti del 2008, al candidato Barack Obama fu chiesto di fare un'analisi estemporanea in occasione della sua visita a Google. Il direttore esecutivo Eric Schmidt gli chiese scherzosamente ``il modo più efficiente di ordinare un milione di interi a 32-bit''.
Obama era stato presumibilmente messo sull'avviso, poiché replicò subito: ``Credo che un ordinamento a bolle sarebbe il modo sbagliato di procedere''.
Vedere \url{http://www.youtube.com/watch?v=k4RRi_ntQc8}.
\index{Obama, Barack}
\index{Schmidt, Eric}
\index{bubble sort}

È vero: l'ordinamento a bolle, o ``bubble sort'', è concettualmente semplice ma è lento per grandi insiemi di dati. La risposta che Schmidt probabilmente si aspettava era ``radix sort'' (\url{http://it.wikipedia.org/wiki/Radix_sort})\footnote{Ma se vi capita una domanda come questa in un'intervista, ritengo che una risposta migliore sarebbe: ``Il modo più rapido di ordinare un milione di interi è usare una qualsiasi funzione di ordinamento di cui dispone il linguaggio di programmazione che uso. Il suo rendimento sarà abbastanza buono per la maggior parte delle applicazioni, ma se proprio capitasse che la mia fosse troppo lenta, userei un profiler per controllare dove viene impiegato il tempo. Se risultasse che un algoritmo di ordinamento più rapido avrebbe un impatto significativo sulle prestazioni, cercherei una buona implementazione del radix sort''.}.
\index{radix sort}

Scopo dell'analisi degli algoritmi è fare dei confronti significativi tra algoritmi, ma occorre tener conto di alcuni problemi:
\index{confronto di algoritmi}

\begin{itemize}

\item L'efficienza relativa degli algoritmi può dipendere dalle caratteristiche dell'hardware, per cui un algoritmo può essere più veloce sulla Macchina A, un altro sulla Macchina B. La soluzione in genere è specificare un
{\bf modello di macchina} e quindi analizzare il numero di passi, o operazioni, che un algoritmo richiede su quel dato modello.
\index{macchina, modello di}

\item L'efficienza relativa può dipendere da alcuni dettagli dell'insieme di dati, Per esempio, alcuni algoritmi di ordinamento sono più veloci se i dati sono già parzialmente ordinati; altri in casi simili sono più lenti. Un modo di affrontare il problema è di analizzare lo scenario del {\bf caso peggiore}. Talvolta è utile anche analizzare le prestazioni del caso medio, ma questo comporta più difficoltà e può non essere facile stabilire quale insieme di dati mediare.
\index{caso!peggiore}
\index{caso!medio}

\item L'efficienza relativa dipende anche dalle dimensioni del problema. Un algoritmo di ordinamento che è veloce per liste corte può diventare lento su liste lunghe. La soluzione più comune è di esprimere il tempo di esecuzione (o il numero di operazioni) in funzione delle dimensioni, e confrontare le funzioni {\bf asintoticamente}, al crescere delle dimensioni del problema.
\index{analisi asintotica}

\end{itemize}

Il lato buono di questo tipo di confronto è che conduce a una semplice classificazione degli algoritmi. Ad esempio, se sappiamo che il tempo di esecuzione dell'algoritmo A tende ad essere proporzionale alle dimensioni dell'input, $n$, e l'algoritmo B tende ad essere proporzionale a $n^2$, allora possiamo attenderci che A sia più veloce di B al crescere di $n$.

Questo tipo di analisi ha alcune avvertenze, ma ci torneremo più avanti.


\section{Ordine di complessità}

Supponiamo che abbiate analizzato due algoritmi esprimendo i loro tempi di esecuzione in funzione delle dimensioni dell'input: l'Algoritmo A impiega $100n+1$ operazioni per risolvere un problema di dimensione $n$; l'Algoritmo B impiega $n^2 + n + 1$ operazioni.
\index{complessità!ordine di}

La tabella seguente mostra il tempo di esecuzione di questi algoritmi per diverse dimensioni del problema:

\begin{tabular}{|r|r|r|}
\hline
Dimensione &   Tempo          & Tempo \\
dell'input	   &   Algoritmo A    & Algoritmo B \\
\hline
10        &   1 001           & 111         \\
100       &   10 001          & 10 101         \\
1 000     &   100 001         & 1 001 001         \\
10 000    &   1 000 001       & $> 10^{10}$         \\
\hline
\end{tabular}

Per $n=10$, l'Algoritmo A si comporta piuttosto male: impiega quasi 10 volte il tempo dell'Algoritmo B.  Ma per $n=100$ sono circa equivalenti, e per grandi valori A è molto migliore.

Il motivo fondamentale è che, per grandi valori di n, ogni funzione che contiene un termine $n^2$ crescerà più rapidamente di una che ha come termine dominante $n$.  Il {\bf termine dominante} è quello con il più alto esponente.
\index{termine dominante}
\index{esponente}

Per l'algoritmo A, il termine dominante ha un grande coefficiente, 100, ed è per questo che B è migliore di A per piccoli valori di $n$.  Ma indipendentemente dal coefficiente, esisterà un valore di $n$ a partire dal quale
$a n^2 > b n$.
\index{coefficiente dominante}

Stesso discorso vale per i termini secondari. Anche se il tempo di esecuzione dell'Algoritmo A fosse $n+1000000$, sarebbe sempre migliore di B per valori sufficientemente grandi di $n$.

In genere, possiamo aspettarci che un algoritmo con piccolo termine dominante sia migliore per problemi di dimensione maggiore, ma per quelli di minori dimensioni può esistere un {\bf punto di intersezione} dove un altro algoritmo diventa migliore. Questo punto dipende dai dettagli dell'algoritmo, dai dati di input e dall'hardware, quindi di solito è trascurato per gli scopi dell'analisi degli algoritmi. Ma non significa che dobbiate scordarvene.
\index{punto di intersezione}

Se due algoritmi hanno il termine dominante dello stesso ordine, è difficile stabilire quale sia migliore; ancora, la risposta dipende dai dettagli. Per l'analisi degli algoritmi, le funzioni dello stesso ordine sono considerate equivalenti, anche se hanno coefficienti diversi.

Un {\bf ordine di complessità} è dato da un insieme di funzioni il cui comportamento di crescita asintotica è considerato equivalente.  Per esempio, $2n$, $100n$ e $n+1$ appartengono allo stesso ordine di complessità, che si scrive $O(n)$ nella {\bf notazione O-grande} e viene chiamato {\bf lineare} perché tutte le funzioni dell'insieme crescono in maniera lineare al crescere di $n$.
\index{O-grande, notazione}
\index{complessità!lineare}

Tutte le funzioni con termine dominante $n^2$ appartengono a $O(n^2)$; sono dette {\bf quadratiche}, che è una parolona per denotare le funzioni di termine $n^2$.
\index{complessità!quadratica}

La tabella seguente mostra alcuni degli ordini di complessità più comuni nell'analisi degli algoritmi, in ordine crescente di inefficienza.
\index{inefficienza}

\begin{tabular}{|r|r|r|}
\hline
Ordine di     &   Nome      \\
complessità       &               \\
\hline
$O(1)$             & costante \\
$O(\log_b n)$      & logaritmico (per qualunque $b$) \\
$O(n)$             & lineare \\
$O(n \log_b n)$    & ``enne log enne'' \\
$O(n^2)$           & quadratico     \\
$O(n^3)$           & cubico     \\
$O(c^n)$           & esponenziale (per qualunque $c$)    \\
\hline
\end{tabular}

Per i termini logaritmici, la base del logaritmo non ha importanza; cambiare base equivale a moltiplicare per una costante, il che non modifica l'ordine di complessità. Allo stesso modo, tutte le funzioni esponenziali appartengono allo stesso ordine indipendentemente dall'esponente. Dato che le funzioni esponenziali crescono molto velocemente, gli algoritmi esponenziali sono utili solo per problemi di piccole dimensioni.
\index{complessità!logaritmica}
\index{complessità!esponenziale}

\vspace{0.2in}
\begin{exercise}

Leggete la pagina di Wikipedia sulla notazione O-grande: 
\url{http://it.wikipedia.org/wiki/O-grande} e rispondete alle seguenti domande:

\begin{enumerate}
\item Qual è l'ordine di complessità di $n^3 + n^2$?
E di $1000000 n^3 + n^2$?
E di $n^3 + 1000000 n^2$?

\item Qual è l'ordine di complessità $(n^2 + n) \cdot (n + 1)$?  Prima di iniziare a moltiplicare, ricordate che vi interessa solo il termine dominante.

\item Se $f$ appartiene a $O(g)$, per una non specificata funzione $g$, cosa possiamo dire di $af+b$?

\item Se $f_1$ e $f_2$ appartengono a $O(g)$, cosa possiamo dire di $f_1 + f_2$?

\item Se $f_1$ appartiene a $O(g)$
e $f_2$ appartiene a $O(h)$,
cosa possiamo dire di  $f_1 + f_2$?

\item Se  $f_1$ appartiene a $O(g)$ e $f_2$ appartiene a $O(h)$,
cosa possiamo dire di  $f_1 \cdot f_2$?
\end{enumerate}

\end{exercise}

I programmatori attenti alle prestazioni sono spesso critici su questo tipo di analisi. Ne hanno un motivo: a volte i coefficienti e i termini secondari fanno davvero differenza. E a volte i dettagli dell'hardware, del linguaggio di programmazione, e delle caratteristiche dell'input fanno una grande differenza. E per i piccoli problemi, l'analisi asintotica è irrilevante.
\index{algoritmi!analisi pratica}

Ma tenute presenti queste avvertenze, l'analisi degli algoritmi è uno strumento utile. Almeno per i grandi problemi, l'algoritmo ``migliore'' è effettivamente migliore, e a volte {\em molto} migliore. La differenza tra due algoritmi dello stesso ordine di solito è un fattore costante, ma la differenza tra un buon algoritmo e uno cattivo è illimitata!



\section{Analisi delle operazioni fondamentali di Python}

Molte operazioni aritmetiche richiedono un tempo costante: di solito la moltiplicazione impiega più tempo di addizione e sottrazione, e la divisione impiega ancora di più, ma i tempi di esecuzione sono indipendenti dalla grandezza degli operandi. Fanno eccezione gli interi molto grandi: in tal caso il tempo di elaborazione cresce al crescere del numero delle cifre.
\index{analisi delle primitive}

Le operazioni di indicizzazione---lettura e scrittura di elementi di una sequenza o dizionario---sono anch'esse a tempo costante, indipendentemente dalle dimensioni della struttura di dati.
\index{indicizzazione}

Un ciclo {\tt for} che attraversa una sequenza o un dizionario è di solito lineare, a patto che tutte le operazioni nel corpo del ciclo siano a tempo costante. Per esempio, la sommatoria degli elementi di una lista è lineare:

\begin{verbatim}
    totale = 0
    for x in t:
        totale += x
\end{verbatim}

La funzione predefinita {\tt sum} è pure lineare, visto che fa la stessa cosa, ma tende ad essere più rapida perché è un'implementazione più efficiente: nel linguaggio dell'analisi degli algoritmi, ha un coefficiente del termine dominante più piccolo.

Se usate lo stesso ciclo per ``sommare'' una lista di stringhe, il tempo di esecuzione è quadratico perché il concatenamento di stringhe è lineare.
\index{stringa!concatenamento}

Il metodo delle stringhe {\tt join} di solito è più veloce, perché è lineare rispetto alla lunghezza totale delle stringhe.
\index{join@{\tt join}}

Come regola di massima, se il corpo di un ciclo appartiene a $O(n^a)$ allora il ciclo nel suo complesso appartiene a $O(n^{a+1})$.  Fa eccezione il caso in cui il ciclo esce dopo un numero di iterazioni costante. Se un ciclo viene eseguito per $k$ volte indipendentemente da $n$, allora il ciclo appartiene a $O(n^a)$, anche per grandi valori di $k$.

Moltiplicare per $k$ non cambia l'ordine di complessità, ma nemmeno dividere. Pertanto se il corpo del ciclo appartiene $O(n^a)$ e viene eseguito
$n/k$ volte, il ciclo appartiene a $O(n^{a+1})$, anche per grandi valori di $k$.

La maggioranza delle operazioni su stringhe e tuple sono lineari, eccetto l'indicizzazione e {\tt   len}, che sono a tempo costante. Le funzioni predefinite {\tt min} e {\tt max} sono lineari. Il tempo di esecuzione dello slicing è proporzionale alla lunghezza del risultato, ma indipendente dalle dimensioni del dato di partenza.

\index{stringa!metodi}
\index{tupla!metodi}

Tutti i metodi delle stringhe sono lineari, ma se le lunghezze delle stringhe sono limitate da una costante---ad esempio operazioni su singoli caratteri---sono considerati a tempo costante.

La maggior parte dei metodi delle liste sono lineari, con alcune eccezioni:
\index{lista!metodi}

\begin{itemize}

\item L'aggiunta di un elemento alla fine di una lista è mediamente a tempo costante; quando si supera lo spazio disponibile, occasionalmente la lista viene copiata in uno spazio più ampio, ma il tempo totale per $n$ operazioni è $O(n)$, quindi possiamo considerare che il tempo ``spalmato'' su una operazione è $O(1)$.

\item La rimozione di un elemento dalla fine della lista è a tempo costante.

\item L'ordinamento appartiene a $O(n \log n)$.
\index{ordinamento}

\end{itemize}

La maggior parte delle operazioni e dei metodi dei dizionari sono lineari, con alcune eccezioni:
\index{dizionario!metodi}

\begin{itemize}

\item Il tempo di esecuzione di {\tt copy} è proporzionale al numero di elementi, ma non alle loro dimensioni (copia i riferimenti e non gli elementi in sé).

\item Il tempo di esecuzione di {\tt update} è proporzionale alle dimensioni del dizionario passato come parametro, non del dizionario che viene aggiornato.

\item {\tt keys}, {\tt values} e {\tt items} sono lineari perché restituiscono nuove liste; {\tt iterkeys}, {\tt itervalues} e {\tt iteritems} sono costanti perché restituiscono iteratori. Ma se fate un ciclo su un iteratore, il ciclo sarà lineare. Usare le funzioni ``iter'' risparmia qualche spesa, ma non cambia l'ordine di incremento, a meno che il numero di elementi a cui accedete non abbia un limite.

\end{itemize}

Le prestazioni dei dizionari sono uno dei piccoli miracoli dell'informatica. Vedremo come funzionano nel Paragrafo~\ref{hashtable}.

\vspace{0.2in}
\begin{exercise}

Leggete la pagina di Wikipedia sugli algoritmi di ordinamento:
\url{http://it.wikipedia.org/wiki/Algoritmo_di_ordinamento} e rispondete alle seguenti domande:
\index{ordinamento}

\begin{enumerate}

\item Che cos'è un ordinamento per confronto (``comparison sort'')? Qual è l'ordine di complessità minimo, nel peggiore dei casi, per un ordinamento per confronto? Qual è l'ordine di complessità minimo, nel peggiore dei casi, per qualsiasi algoritmo di ordinamento?
\index{comparison sort}

\item Qual è l'ordine di complessità dell'ordinamento a bolle (o bubblesort), e perché Barack Obama pensa che sia ``il modo sbagliato di procedere''?

\item Qual è l'ordine di complessità del radix sort? Quali precondizioni devono essere soddisfatte per poterlo usare?

\item Che cos'è un ordinamento stabile (``stable sort'') e perché è interessante in pratica?
\index{stable sort}

\item Qual è il peggior algoritmo di ordinamento (tra quelli che hanno un nome)?

\item Quale algoritmo di ordinamento usa la libreria C? Quale usa Python? Questi algoritmi sono stabili? Eventualmente fate alcune ricerche sul web per trovare le risposte.

\item Molti degli ordinamenti che non operano per confronto sono lineari, allora perché Python usa un ordinamento per confronto di tipo $O(n \log n)$ ?

\end{enumerate}

\end{exercise}


\section{Analisi degli algoritmi di ricerca}

Una {\bf ricerca} è un algoritmo che, data una raccolta e un elemento, determina se l'elemento appartiene alla raccolta, restituendo di solito il suo indice.
\index{ricerca}

Il più semplice algoritmo di ricerca è una ``ricerca lineare'', che attraversa gli elementi della raccolta nel loro ordine, fermandosi se trova quello che cerca. Nel caso peggiore, dovrà attraversare tutta la raccolta, quindi il tempo di esecuzione è lineare.
\index{ricerca!lineare}

L'operatore {\tt in} delle sequenze usa una ricerca lineare, come pure i metodi delle stringhe {\tt find} e {\tt count}.
\index{in, operatore}

Se gli elementi della sequenza sono ordinati, potete usare una {\bf ricerca binaria}, che appartiene a $O(\log n)$.  È simile all'algoritmo che usate per cercare una voce in un vocabolario. Invece di partire dall'inizio e controllare ogni voce nell'ordine, cominciate con un elemento nel mezzo e controllate se quello che cercate viene prima o dopo. Se viene prima, cercate nella prima metà della sequenza, altrimenti nella seconda metà. In ogni caso, dimezzate il numero di elementi rimanenti.
\index{ricerca!binaria}

Se una sequenza ha 1.000.000 di elementi, ci vorranno al massimo una ventina di passaggi per trovare la parola o concludere che non esiste. Quindi è circa 50.000 volte più veloce di una ricerca lineare.

\vspace{0.2in}
\begin{exercise}

Scrivete una funzione di nome {\tt bisezione} che prenda una lista ordinata e un valore da cercare, e restituisca l'indice di quel valore nella lista, se esiste, oppure {\tt None} se non esiste.
\index{bisect, modulo}
\index{modulo!bisect}

Oppure leggete la documentazione del metodo {\tt bisect} e usate quello!

\end{exercise}

La ricerca binaria può essere molto più veloce di quella lineare, ma richiede che la sequenza sia ordinata, il che può comportare del lavoro supplementare.

Esiste un'altra struttura di dati, chiamata {\bf tabella hash}, che è ancora più veloce---è in grado di effettuare una ricerca a tempo costante---e non richiede che gli elementi siano ordinati. I dizionari di Python sono implementati usando tabelle hash, e questo è il motivo per cui la maggior parte delle operazioni sui dizionari, incluso l'operatore {\tt in}, sono a tempo costante.


\section{Tabelle hash}
\label{hashtable}

Per spiegare come funzionano le tabelle hash e perché le loro prestazioni sono così buone, inizierò con un'implementazione semplice di una mappatura e la migliorerò gradualmente fino a farla diventare una tabella hash.
\index{tabella hash}

Per illustrare questa implementazione userò Python, ma in pratica non scriverete mai codice del genere in Python: userete semplicemente un dizionario! Pertanto, per il resto di questo capitolo immaginate che i dizionari non esistano, e di voler implementare una struttura di dati che fa corrispondere delle chiavi a dei valori. Le operazioni che bisogna implementare sono:

\begin{description}

\item[{\tt add(k, v)}:] Aggiunge un nuovo elemento che fa corrispondere la chiave {\tt k} al valore {\tt v}.  Con un dizionario Python, {\tt d}, questa operazione si scrive {\tt d[k] = v}.

\item[{\tt get(target)}:] Cerca e restituisce il valore corrispondente alla chiave {\tt target}.  Con un dizionario Python, {\tt d}, questa operazione si scrive {\tt d[target]} oppure {\tt d.get(target)}.

\end{description}

Per ora, supponiamo che ogni chiave compaia solo una volta. L'implementazione più semplice di questa interfaccia usa una lista di tuple, dove ogni tupla è una coppia chiave-valore.
\index{MappaLineare@{\tt MappaLineare}}

\begin{verbatim}
class MappaLineare(object):

    def __init__(self):
        self.items = []

    def add(self, k, v):
        self.items.append((k, v))

    def get(self, k):
        for chiave, valore in self.items:
            if chiave == k:
                return valore
        raise KeyError
\end{verbatim}

{\tt add} accoda una tupla chiave-valore alla lista di elementi, operazione che è a tempo costante.

{\tt get} usa un ciclo {\tt for} per ricercare nella lista: se trova la chiave target restituisce il corrispondente valore, altrimenti solleva un {\tt KeyError}. Quindi {\tt get} è lineare.
\index{KeyError}

Un'alternativa è mantenere la lista ordinata per chiavi. Allora, {\tt get}
potrebbe usare una ricerca binaria, che appartiene a $O(\log n)$. Ma l'inserimento di un nuovo elemento in mezzo a una lista è lineare, quindi questa potrebbe non essere l'opzione migliore. Esistono altre strutture di dati (vedere
  \url{http://it.wikipedia.org/wiki/RB-Albero}) in grado di implementare {\tt add} e {\tt get} in tempo logaritmico, ma non va ancora così bene come il tempo costante, quindi andiamo avanti.
  
\index{RB-albero}

Un modo di migliorare {\tt MappaLineare} è di spezzare la lista di coppie chiave-valore in liste più piccole. Ecco un'implementazione chiamata
{\tt MappaMigliore}, che è una lista di 100 MappeLineari.  Vedremo in un istante che l'ordine di complessità di {\tt get} è sempre lineare, ma {\tt MappaMigliore} è un passo in direzione delle tabelle hash:
\index{MappaMigliore@{\tt MappaMigliore}}

\begin{verbatim}
class MappaMigliore(object):

    def __init__(self, n=100):
        self.maps = []
        for i in range(n):
            self.maps.append(MappaLineare())

    def trova_mappa(self, k):
        indice = hash(k) % len(self.maps)
        return self.maps[indice]

    def add(self, k, v):
        m = self.trova_mappa(k)
        m.add(k, v)

    def get(self, k):
        m = self.trova_mappa(k)
        return m.get(k)
\end{verbatim}

\verb"__init__" crea una lista di {\tt n} {\tt MappeLineari}.

\verb"trova_mappa" è usata da
{\tt add} e {\tt get} per capire in quale mappatura inserire il nuovo elemento o in quale mappatura ricercare.

\verb"trova_mappa" usa la funzione predefinita {\tt hash}, che accetta pressoché qualunque oggetto Python e restituisce un intero. Un limite di questa implementazione è che funziona solo con chiavi a cui è applicabile un hash, e i tipi mutabili come liste e dizionari non lo sono.
\index{hash, funzione}

Gli oggetti hash-abili che vengono considerati uguali restituiscono lo stesso valore hash, ma l'inverso non è necessariamente vero: due oggetti diversi possono restituire lo stesso valore hash.

\verb"trova_mappa" usa l'operatore modulo per inglobare i valori hash nell'intervallo da 0 a {\tt len(self.maps)}, in modo che il risultato sia un indice valido per la lista. Naturalmente, ciò significa che molti valori hash diversi saranno inglobati nello stesso indice. Ma se la funzione hash distribuisce le cose abbastanza uniformemente (che è quello per cui le funzioni hash sono progettate), possiamo attenderci $n/100$ elementi per MappaLineare.

Siccome il tempo di esecuzione di {\tt MappaLineare.get} è proporzionale al numero di elementi, possiamo attenderci che MappaMigliore sia circa 100 volte più veloce di MappaLineare. L'ordine di complessità è sempre lineare, ma il coefficiente del termine dominante è più piccolo. Risultato discreto, ma non ancora come una tabella hash.

Ed ecco (finalmente) il punto cruciale che rende veloci le tabelle hash: se riuscite a mantenere limitata la lunghezza massima delle MappeLineari, {\tt
  MappaLineare.get} diventa a tempo costante.  Quello che bisogna fare è tenere conto del numero di elementi, e quando questo numero per MappaLineare eccede una soglia, ridimensionare la tabella hash aggiungendo altre MappeLineari.

Ecco un'implementazione di una tabella hash:
\index{MappaHash}

\begin{verbatim}
class MappaHash(object):

    def __init__(self):
        self.maps = MappaMigliore(2)
        self.num = 0

    def get(self, k):
        return self.maps.get(k)

    def add(self, k, v):
        if self.num == len(self.maps.maps):
            self.resize()

        self.maps.add(k, v)
        self.num += 1

    def ridimensiona(self):
        new_maps = MappaMigliore(self.num * 2)

        for m in self.maps.maps:
            for k, v in m.items:
                new_maps.add(k, v)

        self.maps = new_maps
\end{verbatim}

Ogni {\tt MappaHash} contiene una {\tt MappaMigliore}; \verb"__init__" comincia con sole 2 MappeLineari e inizializza {\tt num}, che tiene il conto del numero di elementi.

{\tt get} rinvia semplicemente a {\tt MappaMigliore}.  Il lavoro vero si svolge in {\tt add}, che controlla il numero di elementi e le dimensioni di
{\tt MappaMigliore}: se sono uguali, il numero medio di elementi per MappaLineare è 1, quindi chiama {\tt ridimensiona}.

{\tt ridimensiona} crea una nuova {\tt MappaMigliore}, di capienza doppia della precedente, e ricalcola l'hash degli elementi dalla vecchia mappatura alla nuova.

Il ricalcolo è necessario perché cambiare il numero di MappeLineari cambia il denominatore dell'operatore modulo in \verb"trova_mappa".  Ciò significa che alcuni oggetti che erano inglobati nella stessa MappaLineare saranno separati (che era quello che volevamo, no?).
\index{rehashing}

Il ricalcolo dell'hash è lineare, quindi {\tt ridimensiona} è lineare, il che può sembrare negativo dato che mi ripromettevo che {\tt add} diventasse a tempo costante.  Ma ricordate che non dobbiamo ridimensionare ogni volta, quindi {\tt add} è di norma costante e solo qualche volta lineare. Il lavoro complessivo per eseguire {\tt add} $n$ volte è proporzionale a $n$, quindi il tempo medio di ogni {\tt add} è costante!
\index{tempo costante}

Per capire come funziona, supponiamo di iniziare con una tabella hash vuota e aggiungere una sequenza di elementi. Iniziamo con 2 MappeLineari, quindi le prime 2 aggiunte saranno veloci (nessun ridimensionamento richiesto). Diciamo che richiedono una unità lavoro ciascuna. L'aggiunta successiva richiede il ridimensionamento, e dobbiamo ricalcolare l'hash dei primi due elementi (diciamo 2 unità lavoro in più), quindi aggiungere il terzo elemento (1 altra unità). Aggiungere l'elemento successivo costa 1 unità, e in totale fanno 6 unità lavoro per 4 elementi.

Il successivo {\tt add} costa 5 unità, ma i tre successivi solo 1 unità ciascuno, in totale 14 unità per 8 aggiunte.

L'aggiunta successiva costa 9 unità, ma poi possiamo aggiungerne altre 7 prima del ridimensionamento successivo, per un totale di 30 unità lavoro per le prime 16 aggiunte.

Dopo 32 aggiunte, il costo totale è 62 unità, e spero stiate cominciando ad avere chiaro lo schema. Dopo $n$ aggiunte, con $n$ potenza di 2, il costo totale è $2n-2$ unità, per cui il lavoro medio per aggiunta è poco meno di 2 unità. Con $n$ potenza di 2 si ha il caso migliore; per altri valori di $n$ il lavoro medio è leggermente più alto, ma non in modo importante. La cosa importante è che sia
$O(1)$.
\index{costo medio}

La Figura~\ref{fig.hash} illustra graficamente il funzionamento. Ogni quadrato è una unità di lavoro. Le colonne mostrano il lavoro totale per ogni aggiunta nell'ordine da sinistra verso destra: le prime due aggiunte costano 1 unità, la terza 3, ecc.

\begin{figure}
\centerline{\includegraphics[scale=0.6]{figs/towers.pdf}}
\caption{Costo delle aggiunte a una Tabella Hash.\label{fig.hash}}
\end{figure}

Il lavoro supplementare di ricalcolo appare come una sequenza di torri sempre più alte e con spazi sempre più ampi tra due torri successive. Ora, se abbattete le torri, mediando il costo del ridimensionamento su tutte le aggiunte, potete vedere graficamente che il costo del lavoro totale dopo $n$ aggiunte è $2n - 2$.

Una caratteristica importante di questo algoritmo è che quando ridimensioniamo la tabella hash, cresce geometricamente, cioè moltiplichiamo la dimensione per una costante. Se incrementaste le dimensioni aritmeticamente, aggiungendo ogni volta un numero fisso, il tempo medio per aggiunta sarebbe lineare.
\index{ridimensionamento geometrico}

Potete scaricare la mia implementazione di MappaHash da
\url{http://thinkpython/code/Map.py}, ma ricordate che non c'è alcuna buona ragione per usarla. Piuttosto, se dovete fare una mappatura, usate un dizionario di Python.






\chapter{Lumpy}
\label{lumpy}

Nel corso del libro, ho utilizzato dei diagrammi per rappresentare la situazione di un programma in esecuzione.
\index{Lumpy}

Nel Paragrafo~\ref{variables}, abbiamo usato un diagramma di stato per mostrare nomi e valori delle variabili.  Nel Paragrafo~\ref{stackdiagram} ho presentato il diagramma di stack, che mostra un frame per ciascuna chiamata di funzione. Ogni frame contiene i parametri e le variabili locali della funzione o del metodo. Diagrammi di stack per le funzioni ricorsive compaiono nei Paragrafi~\ref{recursive.stack} e~\ref{more.recursion}.
\index{diagramma!di stato}
\index{diagramma!di stack}

Il Paragrafo~\ref{mutable} illustra come appare una lista in un diagramma di stato, nel Paragrafo~\ref{invert} come appare un dizionario, e nel Paragrafo~\ref{dictuple} vi sono due modi di raffigurare le tuple.

Il Paragrafo~\ref{attributes} presenta i diagrammi di oggetto, che mostrano lo stato degli attributi di un oggetto, e dei loro attributi, e così via. Il Paragrafo~\ref{rectangles} contiene diagrammi di oggetto dei Rettangoli e dei loro Punti contenuti. Nel Paragrafo~\ref{time.object} viene illustrato lo stato di un oggetto Tempo.
Nel Paragrafo~\ref{class.attribute} c'è un diagramma che comprende un oggetto classe e un'istanza, ciascuna con i relativi attributi.

\index{diagramma!di oggetto}

Infine, il Paragrafo~\ref{class.diagram} presenta i diagrammi di classe, che schematizzano le classi che costituiscono un programma e le relazioni tra di esse.
\index{diagramma!di classe}

Questi diagrammi sono basati sull'{\em Unified Modeling Language} (UML), che è un linguaggio grafico standardizzato usato dai programmatori per scambiarsi informazioni sul progetto dei programmi, in particolare per quelli orientati agli oggetti.
\index{Unified Modeling Language}
\index{UML}

L'UML è un linguaggio ricco con molti tipi di diagrammi che rappresentano molti tipi di relazioni tra oggetti e classi. Quella che ho mostrato in questo libro è solo una piccola parte del linguaggio, ma è quella più comunemente usata nella pratica.

Lo scopo di questa Appendice è di riassumere i diagrammi illustrati nei capitoli precedenti e di presentare Lumpy. Lumpy sta per ``UML in Python'', con qualche lettera scambiata, ed è parte di Swampy, che avete già installato per lavorare sulle Esercitazioni dei Capitoli~\ref{turtlechap} e~\ref{tkinter}, oppure se avete svolto l'Esercizio~\ref{canvas}.
\index{Lumpy}
\index{Swampy}

Lumpy usa il modulo di Python {\tt inspect} per esaminare lo stato di un programma in esecuzione e generare diagrammi di oggetto (inclusi diagrammi di stack) e diagrammi di classe.

\section{Diagramma di stato}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo1.pdf}}
\caption{Diagramma di stato generato da Lumpy.}
\label{fig.lumpy1}
\end{figure}

Ecco un esempio che utilizza Lumpy per generare un diagramma di stato.
\index{diagramma!di stato}

\begin{verbatim}
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

messaggio = 'Ed ora qualcosa di completamente diverso'
n = 17
pi = 3.1415926535897932

lumpy.object_diagram()
\end{verbatim}

La prima riga importa la classe Lumpy da {\tt swampy.Lumpy}.
Se non avete installato Swampy come pacchetto, assicuratevi che i file di Swampy siano nel percorso di ricerca di Python e usate invece questa istruzione
{\tt import}:

\begin{verbatim}
from Lumpy import Lumpy
\end{verbatim}

La riga successiva crea un oggetto {\tt Lumpy} e crea un punto di ``riferimento'', cioè Lumpy registra gli oggetti che vengono definiti da questo punto in poi.

Definiamo poi delle nuove variabili, per poi invocare \verb"object_diagram",
che disegna gli oggetti che sono stati definiti a partire dal punto di riferimento, in questo caso {\tt messaggio}, {\tt n} e {\tt pi}.

La Figura~\ref{fig.lumpy1} mostra il risultato. Lo stile grafico è diverso da quello visto sinora, ad esempio ogni riferimento è rappresentato da un cerchietto vicino al nome della variabile e da una linea con il valore. E le stringhe troppo lunghe vengono troncate. Ma l'informazione contenuta nel diagramma è la stessa.

I nomi delle variabili si trovano in un riquadro etichettato \verb"<module>", che indica che si tratta di variabili a livello di modulo, dette anche globali.
\index{variabile!globale}
\index{variabile!a livello di modulo}

Potete scaricare questo esempio da
\url{http://thinkpython.com/code/lumpy_demo1.py}.  Provate ad aggiungere qualche altra assegnazione e a vedere come si presenta il diagramma.


\section{Diagramma di stack}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo2.pdf}}
\caption{Diagramma di stack.}
\label{fig.lumpy2}
\end{figure}

Ecco un esempio che utilizza Lumpy per generare un diagramma di stack. Lo potete scaricare da \url{http://thinkpython.com/code/lumpy_demo2.py}.
\index{diagramma!di stack}

\begin{verbatim}
from swampy.Lumpy import Lumpy

def contoallarovescia(n):
    if n <= 0:
        print 'Via!'
        lumpy.object_diagram()
    else:
        print n
        contoallarovescia(n-1)

lumpy = Lumpy()
lumpy.make_reference()
contoallarovescia(3)
\end{verbatim}

La Figura~\ref{fig.lumpy2} mostra il risultato. Ogni frame è rappresentato da un riquadro che reca all'esterno il nome della funzione, e le relative variabili all'interno. Dato che questa funzione è ricorsiva, c'è un riquadro per ogni livello di ricorsione.
\index{ricorsione}
\index{funzione!frame di}
\index{frame}

Ricordate che un diagramma di stack mostra lo stato del programma in un ben determinato punto della sua esecuzione. Per ottenere il diagramma che volete, dovrete pensare a dove invocare \verb"object_diagram".

In questo caso ho invocato \verb"object_diagram" dopo l'esecuzione del caso base della ricorsione: in questo modo il diagramma mostra ciascun livello. Potete anche chiamare \verb"object_diagram" più volte per ottenere una sequenza di istantanee dell'esecuzione del programma.
\index{caso base}


\section{Diagrammi di oggetto}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo3.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.lumpy3}
\end{figure}

Questo esempio genera un diagramma di oggetto che illustra le liste del Paragrafo~\ref{sequence}.  Potete scaricarlo da
\url{http://thinkpython.com/code/lumpy_demo3.py}.
\index{diagramma!di oggetto}

\begin{verbatim}
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

formaggi = ['Cheddar', 'Edam', 'Gouda']
numeri = [17, 123]
vuota = []

lumpy.object_diagram()
\end{verbatim}

Il risultato è riportato in Figura~\ref{fig.lumpy3}.  Le liste sono rappresentate da un riquadro che contiene gli indici corrispondenti agli elementi. Questa rappresentazione è un po' impropria, perché gli indici in realtà non fanno parte della lista, ma ritengo che renda più leggibile il diagramma. La lista vuota è rappresentata da un riquadro vuoto.
\index{lista!indice}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo4.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.lumpy4}
\end{figure}

Ecco ora un esempio che mostra i dizionari del Paragrafo~\ref{invert}, scaricabile da \url{http://thinkpython.com/code/lumpy_demo4.py}.
\index{dizionario}

\begin{verbatim}
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

isto = istogramma('parrot')
inverso = inverti_diz(isto)

lumpy.object_diagram()
\end{verbatim}

In Figura~\ref{fig.lumpy4} il risultato.  {\tt isto} è un dizionario che fa corrispondere caratteri (le singole lettere di una stringa) ad interi; 
{\tt inverso} fa una mappatura da interi a liste di stringhe.

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo5.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.lumpy5}
\end{figure}

Quest'altro esempio genera un diagramma di oggetto per gli oggetti Punto e Rettangolo visti nel Paragrafo~\ref{copying}.  Potete scaricarlo da
\url{http://thinkpython.com/code/lumpy_demo5.py}.
\index{Punto, classe}
\index{classe!Punto}
\index{Rettangolo, classe}
\index{classe!Rettangolo}

\begin{verbatim}
import copy
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

box = Rettangolo()
box.larghezza = 100.0
box.altezza = 200.0
box.angolo = Punto()
box.angolo.x = 0.0
box.angolo.y = 0.0

box2 = copy.copy(box)

lumpy.object_diagram()
\end{verbatim}

La Figura~\ref{fig.lumpy5} mostra il risultato.  {\tt copy.copy} produce una copia shallow, quindi {\tt box} e {\tt box2} hanno le loro proprie {\tt larghezza} e {\tt altezza}, ma condividono lo stesso oggetto contenuto Punto. Questo tipo di condivisione di solito va bene se gli oggetti sono immutabili, ma con tipi mutabili è altamente soggetta ad errori.
\index{copia}
\index{copia!shallow}

\section{Oggetti funzione e classe}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo6.pdf}}
\caption{Diagramma di oggetto.}
\label{fig.lumpy6}
\end{figure}

Quando uso Lumpy per generare diagrammi di oggetto, di solito definisco funzioni e classi prima di fissare il punto di riferimento. In questo modo, gli oggetti funzione e classe non compaiono nel diagramma.
\index{oggetto!funzione}
\index{oggetto!classe}

Ma se state passando funzioni e classi come parametri, può essere preferibile che compaiano. Questo esempio mostra come si presenta il diagramma; lo potete scaricare da
\url{http://thinkpython.com/code/lumpy_demo6.py}.

\begin{verbatim}
import copy
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

class Punto(object):
    """Rappresenta un punto nel piano cartesiano."""

class Rettangolo(object):
    """Rappresenta un rettangolo."""

def istanzia(constructor):
    """Istanzia un nuovo oggetto."""
    obj = constructor()
    lumpy.object_diagram()
    return obj

punto = istanzia(Punto)
\end{verbatim}

La Figura~\ref{fig.lumpy6} mostra il risultato. Dato che invochiamo
\verb"object_diagram" dentro una funzione, otteniamo un diagramma di stack con un riquadro per le variabili a livello di modulo e uno per l'invocazione di
{\tt istanzia}.

A livello di modulo, {\tt Punto} e {\tt Rettangolo} si riferiscono ad oggetti classe (che sono di tipo {\tt type}); {\tt istanzia}
si riferisce a un oggetto funzione.
\index{istanziare}
\index{costruttore}

Questo diagramma aiuta a chiarire due punti che di solito generano malintesi: (1) la differenza tra l'oggetto classe, {\tt Punto}, e l'istanza di Punto, {\tt obj}, e (2) la differenza tra l'oggetto funzione creato quando {\tt istanzia} viene definita e il frame creato quando viene chiamata.


\section{Diagrammi di classe}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo7.pdf}}
\caption{Diagramma di classe.}
\label{fig.lumpy7}
\end{figure}

\begin{figure}
\centerline
{\includegraphics[scale=0.7]{figs/lumpydemo8.pdf}}
\caption{Diagramma di classe.}
\label{fig.lumpy8}
\end{figure}

Sebbene io faccia distinzione tra diagrammi di stato, diagrammi di stack e diagrammi di oggetto, in fondo sono più o meno la stessa cosa: mostrano la situazione di un programma in esecuzione, in un certo momento.

I diagrammi di classe sono diversi. Mostrano le classi che costituiscono un programma e le relazioni tra di esse. Sono indipendenti dal tempo, nel senso che descrivono globalmente il programma, non in un particolare momento. Per esempio, se un'istanza della Classe A contiene in generale un riferimento ad un'istanza della Classe B, diciamo che c'è una ``relazione HAS-A'' tra queste due classi.
\index{HAS-A, relazione}
\index{diagramma!di classe}
\index{UML}

Ecco un esempio che mostra una relazione HAS-A. Lo potete scaricare da \url{http://thinkpython.com/code/lumpy_demo7.py}.

\begin{verbatim}
from swampy.Lumpy import Lumpy

lumpy = Lumpy()
lumpy.make_reference()

box = Rettangolo()
box.larghezza = 100.0
box.altezza = 200.0
box.angolo = Punto()
box.angolo.x = 0.0
box.angolo.y = 0.0

lumpy.class_diagram()
\end{verbatim}

La Figura~\ref{fig.lumpy7} mostra il risultato. Ogni classe viene rappresentata da un riquadro che contiene il nome, tutti i metodi che la classe fornisce, tutte le variabili di classe e tutte le variabili di istanza. In questo esempio, {\tt Rettangolo} e {\tt Punto} hanno variabili di istanza ma nessun metodo né variabili di classe.

La freccia da {\tt Rettangolo} a {\tt Punto} mostra che i Rettangoli contengono un Punto come oggetto contenuto. Inoltre, sia {\tt Rettangolo} che {\tt
  Punto} ereditano da {\tt object}, che è rappresentato nel diagramma da una freccia con la testa a triangolo.
\index{IS-A, relazione}

Ecco ora un esempio più complesso che utilizza la soluzione dell'Esercizio~\ref{poker}.
Il codice è scaricabile da  \url{http://thinkpython.com/code/lumpy_demo8.py};
vi servirà anche \url{http://thinkpython.com/code/PokerHand.py}.

\begin{verbatim}
from swampy.Lumpy import Lumpy

from ManoDiPoker import *

lumpy = Lumpy()
lumpy.make_reference()

mazzo = Mazzo()
mano = ManoDiPoker()
mazzo.move_cards(mano, 7)

lumpy.class_diagram()
\end{verbatim}

La Figura~\ref{fig.lumpy8} mostra il risultato.  
{\tt ManoDiPoker} eredita da {\tt Mano}, che a sua volta eredita da {\tt Mazzo}.
Sia {\tt Mazzo} che {\tt ManoDiPoker} contengono Carte.
\index{Carta, classe}
\index{Mazzo, classe}
\index{Mano, classe}

Il diagramma non evidenzia che anche  {\tt Mano} contiene Carte, perché nel programma non ci sono istanze di Mano. Questo esempio dimostra un limite di Lumpy: viene a conoscenza solo degli attributi e delle relazioni HAS-A di oggetti che sono istanziati.

\printindex

\clearemptydoublepage
%\blankpage
%\blankpage
%\blankpage


\end{document}
